<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://deut-erium.github.io/WriteUps/WriteUps/feed.xml" rel="self" type="application/atom+xml" /><link href="https://deut-erium.github.io/WriteUps/WriteUps/" rel="alternate" type="text/html" hreflang="en" /><updated>2022-05-19T18:11:26+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/feed.xml</id><title type="html">CTF Writeups</title><subtitle></subtitle><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><entry><title type="html">SDCTF 2022 Crypto - Tasty Crypto Roll</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2022/sdctf/crypto/tasty_crypto_roll/2022-05-10-SDCTF-2022-Tasty-Crypto-Roll" rel="alternate" type="text/html" title="SDCTF 2022 Crypto - Tasty Crypto Roll" /><published>2022-05-10T00:00:00+05:30</published><updated>2022-05-10T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2022/sdctf/crypto/tasty_crypto_roll/SDCTF-2022-Tasty-Crypto-Roll</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2022/sdctf/crypto/tasty_crypto_roll/2022-05-10-SDCTF-2022-Tasty-Crypto-Roll"><![CDATA[<h1 id="tasty-crypto-roll">Tasty Crypto Roll</h1>
<h2 id="description">Description</h2>
<p>CRYPTO - Hard <br />
Tasty Crypto Roll<br />
Bob, the genius intern at our company, invented AES-improved. It is based on AES but with layers after layers of proprietary encryption techniques on top of it.</p>

<p>The end result is an encryption scheme that achieves both confusion and diffusion. The more layers of crypto you add, the better the security, right?</p>

<p>Encrypter<br />
<a href="encrypt.py">encrypt.py</a><br />
Encrypted file<br />
<a href="enc.bin">enc.bin</a><br />
Note<br />
The intended solution requires very little brute force and runs under 5 seconds on our machine.<br />
By k3v1n</p>

<h2 id="source">Source</h2>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">secrets</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">Crypto.Cipher</span> <span class="kn">import</span> <span class="n">AES</span>

<span class="n">ENCODING</span> <span class="o">=</span> <span class="s">'utf-8'</span>

<span class="k">def</span> <span class="nf">generate_key</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">secrets</span><span class="p">.</span><span class="n">token_bytes</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">to_binary</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">'{:08b}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">from_binary</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">8</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">8</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="n">cipher</span> <span class="o">=</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cipher</span><span class="p">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="n">key1</span><span class="p">,</span> <span class="n">key2</span> <span class="o">=</span> <span class="n">generate_key</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Using Key:</span><span class="se">\n</span><span class="si">{</span><span class="n">key1</span><span class="si">}</span><span class="s">:</span><span class="si">{</span><span class="n">key2</span><span class="p">.</span><span class="nb">hex</span><span class="p">()</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_flag</span><span class="p">():</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">'Enter the flag to encrypt: '</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'sdctf{'</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">'}'</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">.</span><span class="n">isascii</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">flag</span><span class="si">}</span><span class="s"> is not a valid flag for this challenge'</span><span class="p">)</span>
        <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flag</span>

<span class="n">plaintext</span> <span class="o">=</span> <span class="n">get_flag</span><span class="p">()[</span><span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">plaintext</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">ENCODING</span><span class="p">)</span>

<span class="n">codes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0x1b0</span><span class="p">)))</span>
<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sboxes</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Bad key, try again"</span><span class="p">)</span>
    <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">sboxes</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">data</span><span class="p">).</span><span class="n">encode</span><span class="p">(</span><span class="n">ENCODING</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key2</span><span class="p">,</span> <span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">).</span><span class="n">encode</span><span class="p">(</span><span class="n">ENCODING</span><span class="p">))</span>

<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>

<span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits</span><span class="p">))</span>

<span class="n">ciphertext</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Encrypted: </span><span class="si">{</span><span class="n">ciphertext</span><span class="p">.</span><span class="nb">hex</span><span class="p">()</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'enc.bin2'</span><span class="p">,</span> <span class="s">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">ef</span><span class="p">:</span>
    <span class="n">ef</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="analysis">Analysis</h2>
<p>Here we can see mainly two parts</p>
<ol>
  <li>There are two keys
    <ul>
      <li><code class="language-plaintext highlighter-rouge">key1</code>: pid of current process</li>
      <li><code class="language-plaintext highlighter-rouge">key2</code>: secure random key of 16 bytes</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">key1</code> is used as seed at a lot of places and is bruteforcable (&lt; 2^15)
<code class="language-plaintext highlighter-rouge">key_final</code> and <code class="language-plaintext highlighter-rouge">sboxes</code> are derived from <code class="language-plaintext highlighter-rouge">key1</code>, shuffling is done using <code class="language-plaintext highlighter-rouge">key1</code></li>
</ol>

<h3 id="steps-to-crack">Steps to crack</h3>
<ol>
  <li>decrypt using <code class="language-plaintext highlighter-rouge">key_final</code></li>
  <li>convert the intermediate ciphertext <code class="language-plaintext highlighter-rouge">to_binary</code></li>
  <li>de-shuffle the bits</li>
  <li>generate <code class="language-plaintext highlighter-rouge">from_binary</code> intermediate ciphertext of the deshuffled bits</li>
  <li>decrypt using <code class="language-plaintext highlighter-rouge">key2</code>???</li>
</ol>

<h3 id="how-to-find-key1">How to find <code class="language-plaintext highlighter-rouge">key1</code>?</h3>
<p>Assume you have the correct <code class="language-plaintext highlighter-rouge">key1</code>, reverse for the key, validate the results <br />
using some validator/logical assumption.</p>

<p><code class="language-plaintext highlighter-rouge">codes</code> is a list of <code class="language-plaintext highlighter-rouge">2*(0x1b0-0xb0)</code> = <code class="language-plaintext highlighter-rouge">512</code> characters, utf-8 encoding of
which is 2-bytes each <br />
<code class="language-plaintext highlighter-rouge">sboxes</code> will have 4char strings, which encode to 8 bytes each on utf-8 (i.e
        after substitution)<br />
<code class="language-plaintext highlighter-rouge">data</code> is now <code class="language-plaintext highlighter-rouge">4*2 = 8</code> times each byte of the original plaintext<br />
<code class="language-plaintext highlighter-rouge">data</code> is converted <code class="language-plaintext highlighter-rouge">to_binary</code> before encryption hence each byte is converted<br />
to 8 <code class="language-plaintext highlighter-rouge">b"0"</code> or <code class="language-plaintext highlighter-rouge">b"1"</code> byte. Hence each character is substituted to some<br />
<code class="language-plaintext highlighter-rouge">8*8 = 64</code> byte string before encryption.<br />
Hence len of flag = <code class="language-plaintext highlighter-rouge">len(ciphertext)//64</code> = <code class="language-plaintext highlighter-rouge">3520//64 = 55</code> bytes</p>

<h4 id="assumption-1">Assumption 1</h4>
<p>Since length of flag is 55 characters, would it be reasonable to assume that<br />
there would be repeatitions of characters. And since each flag character is<br />
substituted to fixed 64-byte strings before encryption which is a multiple<br />
of AES block size of 16, AES also acts like simple substitution of the flag<br />
but we do not know the mapping.<br />
Hence if we reverse till step 4 above, we can simply check if there are any<br />
repeating 64-byte blocks, as incorrect shuffling of bits will result in each 
block to be distinct with almost 1 probability.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'enc.bin'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">ciphertext</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">to_binary</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">'{:08b}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">from_binary</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">8</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">8</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">encrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">decrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">unshuffle</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">):</span>
        <span class="n">res</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">def</span> <span class="nf">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">data_bits_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data_bits_uns</span> <span class="o">=</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">,</span> <span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits_uns</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">data</span>
</code></pre></div></div>

<p>Lets add a few validation too</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">key_final_enc</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_unshuffle</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="mi">1337</span><span class="p">))</span>
    <span class="n">random_text_shuffled</span> <span class="o">=</span> <span class="n">random_text</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">shuffle_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">random_text</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1337</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1337</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">)</span> <span class="o">==</span> <span class="n">random_text</span>

<span class="k">def</span> <span class="nf">test_key_final_dec</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="mi">1337</span><span class="p">,</span> <span class="n">key_final_enc</span><span class="p">(</span><span class="mi">1337</span><span class="p">,</span> <span class="n">random_text</span><span class="p">))</span> <span class="o">==</span> <span class="n">random_text</span>

<span class="n">test_unshuffle</span><span class="p">()</span>
<span class="n">test_key_final_dec</span><span class="p">()</span>
</code></pre></div></div>
<p>Looks like all the decryption functions are correct, lets proceed with<br />
bruteforcing for <code class="language-plaintext highlighter-rouge">key1</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">),</span><span class="n">desc</span><span class="o">=</span><span class="s">'solving for key1'</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">substitutions</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">64</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">64</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substitutions</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">64</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"pid ="</span><span class="p">,</span><span class="n">key1</span><span class="p">)</span>
        <span class="k">break</span>
</code></pre></div></div>
<p>After waiting for an eternity, and exhausting the search space of possible pidâ€™s<br />
yet not getting any <code class="language-plaintext highlighter-rouge">key1</code> got me confused. I checked my script locally for a <br />
test flag it seemed to work fine. There could only be one possibility <br />
<strong>the flag contains 55 distinct characters</strong><br />
But how would I find <code class="language-plaintext highlighter-rouge">key1</code> now?</p>

<h4 id="missed-catch">Missed Catch</h4>
<p>@Utaha#6878 pointed out, that since there are only 256 distinct values in
<code class="language-plaintext highlighter-rouge">codes</code> each repeated twice, and each character encoded to some <code class="language-plaintext highlighter-rouge">b"0"</code> or <code class="language-plaintext highlighter-rouge">b"1"</code><br />
byte strings of length 16, It must be encrypted to the same block always.<br />
Since the flag is <code class="language-plaintext highlighter-rouge">55*4 = 220</code> such 16-byte codes and each code is used twice<br />
for most of the characters, there will be repating 16-byte blocks even with <br />
distinct flag characters.</p>

<h4 id="assumption-2">Assumption 2</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">),</span><span class="n">desc</span><span class="o">=</span><span class="s">'solving for key1'</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">substitutions</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">16</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">16</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substitutions</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">16</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"pid ="</span><span class="p">,</span><span class="n">key1</span><span class="p">)</span>
        <span class="k">break</span>
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">pid = 83</code></p>
</blockquote>

<p>And we found our <code class="language-plaintext highlighter-rouge">key1</code>!<br />
And we can confirm that the flag is indeed 55 distinct characters.</p>

<p>Wait, if the flag is 55 distinct characters, how will we solve for the subs?<br />
We have no statistical advantage and hence bye bye Mr 
<a href="https://quipqiup.com/">quipquip</a></p>

<h3 id="how-do-we-find-mapping-for-substitution">How do we find mapping for substitution?</h3>
<p>Each <code class="language-plaintext highlighter-rouge">sbox</code> entry is composed of 4 2-byte strings, which can be one of 256<br />
possible values. Moreover, their order is fixed, which is determined by <code class="language-plaintext highlighter-rouge">key1</code>.</p>

<p>If we try to solve for all valid mappings for <code class="language-plaintext highlighter-rouge">AES(binary(sbox(char)))</code> we will
probably end up on the correct mapping and get our flag.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+---------------+---------------+------------------------+---------------+
|flag0          |    flag1      |                        |   flag55      |
+---------------+---------------+         ....           +---------------+
|  sbox         |   sbox        |                        |    sbox       |
+---+---+---+---+---+---+---+---+------------------------+---------------+
|c1 |c2 |c3 |c4 |c5 |c6 |c7 |c8 |                        |               |
|   |   |   |   |   |   |   |   |                        |               |
+---+---+---+---+---+---+---+---+         ....           +---------------+
|   AES         |    AES        |                        |               |
+---+---+-------+---------------+------------------------+---------------+
|   |   +------+                                                          
|   +--+       |                                                          
+------+-------+-------+------+                                           
|E(c1) | E(c2) | E(c3) | E(c4)|                                             
+------+-------+-------+------+   
</code></pre></div></div>

<h3 id="enter-z3">Enter Z3</h3>
<p>We can assume our flag to be a list of <code class="language-plaintext highlighter-rouge">BitVec</code> of 7 bits each<br />
And let the sboxes be a mapping from 7 bits to 64 bits each (16x4)<br />
This can be achieved by assuming sbox to be an array which is indexed<br />
by <code class="language-plaintext highlighter-rouge">BitVec(7)</code> and contains elements of <code class="language-plaintext highlighter-rouge">BitVec(64)</code><br />
And we assume AES to be some function form <code class="language-plaintext highlighter-rouge">BitVec(16)</code> to <code class="language-plaintext highlighter-rouge">BitVec(128)</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">flag</span> <span class="o">=</span> <span class="p">[</span><span class="n">BitVec</span><span class="p">(</span><span class="s">'flag_'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="mi">7</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">64</span><span class="p">)]</span>
<span class="n">sboxmap</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s">'sbox'</span><span class="p">,</span><span class="n">BitVecSort</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
<span class="n">aes_encryption</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">'AES'</span><span class="p">,</span><span class="n">BitVecSort</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">codes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0x1b0</span><span class="p">)))</span>
<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="c1"># keeping sboxes utf encoded already
</span><span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">]).</span><span class="n">encode</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>

<span class="n">sbytes</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">sboxes</span><span class="p">)</span>
<span class="n">sboxints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">'big'</span><span class="p">),</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">sbytes</span><span class="p">),</span><span class="mi">2</span><span class="p">))))</span>
<span class="c1"># integer values for 2-byte codes from sbox, will be explained shortly
</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="s">'big'</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxes</span><span class="p">]</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
<span class="c1"># converting intermediate decryption to 128 bit ints
</span><span class="n">data_int</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">16</span><span class="p">):</span>
    <span class="n">data_int</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">16</span><span class="p">],</span><span class="s">'big'</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># we know the sbox already
</span><span class="n">constraints</span> <span class="o">=</span> <span class="p">[</span><span class="n">sboxmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">sboxes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">64</span><span class="p">):</span>
    <span class="n">four_code</span> <span class="o">=</span> <span class="n">sboxmap</span><span class="p">[</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="c1"># splitting 64 bit quantity to 16 bit individual sbox codes
</span>    <span class="n">four_code_parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Extract</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="o">*</span><span class="n">i</span><span class="p">,</span><span class="n">four_code</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="c1"># for each code, matching aes_encryption with the observed value
</span>    <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data_int</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">:</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span> <span class="n">four_code_parts</span><span class="p">):</span>
        <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">==</span><span class="n">a</span><span class="p">)</span>
    <span class="c1"># last but not least, aes_encryption(i) is unique for each plaintext
</span>    <span class="c1"># how would z3 know? Distinct function encodes them appropriately to
</span>    <span class="c1"># be distinct
</span>    <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Distinct</span><span class="p">([</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxints</span><span class="p">]))</span>

<span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">solver</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">all_smt</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
    <span class="c1"># lets check for all satisfying flags (in case there are more than one
</span>    <span class="c1"># possible mappings and we will rule out invalid ones in that scenario?
</span>    <span class="n">flag_bytes</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]).</span><span class="n">as_long</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flag</span><span class="p">))])</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">64</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">64</span><span class="p">)))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">)</span> 
</code></pre></div></div>

<h2 id="flag">Flag</h2>
<p>After running the script, we finally get our flag!</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">b'r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU'</code></p>
</blockquote>

<p>And it turns out to be the only satisfying assignment.<br />
Turns out if there were repeated characters in the flag, we will get multiple<br />
possible satisfying values. So the admins have not been so cheeky afterall</p>

<h2 id="full-script">Full <a href="solve.py">script</a></h2>
<p>Note that it takes a couple of seconds to find the z3 model</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">Crypto.Cipher</span> <span class="kn">import</span> <span class="n">AES</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">z3</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="k">def</span> <span class="nf">all_smt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">initial_terms</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">block_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">fix_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">all_smt_rec</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sat</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">check</span><span class="p">():</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">model</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">m</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)):</span>
                <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">()</span>
                <span class="n">block_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">terms</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">fix_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">terms</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">yield</span> <span class="k">from</span> <span class="n">all_smt_rec</span><span class="p">(</span><span class="n">terms</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
                <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">yield</span> <span class="k">from</span> <span class="n">all_smt_rec</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">initial_terms</span><span class="p">))</span>


<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'enc.bin'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">ciphertext</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">to_binary</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">'{:08b}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">from_binary</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">8</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">encrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">decrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">key_final_enc</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">unshuffle</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">):</span>
        <span class="n">res</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">test_unshuffle</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span>
    <span class="n">random_text_shuffled</span> <span class="o">=</span> <span class="n">random_text</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">shuffle_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">random_text</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">)</span> <span class="o">==</span> <span class="n">random_text</span>


<span class="n">test_unshuffle</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">data_bits_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data_bits_uns</span> <span class="o">=</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">,</span> <span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits_uns</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">test_key_final_dec</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">key_final_enc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_text</span><span class="p">))</span> <span class="o">==</span> <span class="n">random_text</span>


<span class="n">test_key_final_dec</span><span class="p">()</span>

<span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s">'solving for key1'</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">substitutions</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">16</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substitutions</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="mi">16</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"pid ="</span><span class="p">,</span> <span class="n">key1</span><span class="p">)</span>
        <span class="k">break</span>

<span class="n">codes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0x1b0</span><span class="p">)))</span>
<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">]).</span><span class="n">encode</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>
<span class="n">sbytes</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">sboxes</span><span class="p">)</span>
<span class="n">sboxints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">'big'</span><span class="p">),</span> <span class="nb">set</span><span class="p">(</span>
    <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sbytes</span><span class="p">),</span> <span class="mi">2</span><span class="p">))))</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">'big'</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxes</span><span class="p">]</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
<span class="n">data_int</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">16</span><span class="p">):</span>
    <span class="n">data_int</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="s">'big'</span><span class="p">))</span>

<span class="n">flag</span> <span class="o">=</span> <span class="p">[</span><span class="n">BitVec</span><span class="p">(</span><span class="s">'flag_'</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">7</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="mi">64</span><span class="p">)]</span>
<span class="n">sboxmap</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s">'sbox'</span><span class="p">,</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
<span class="n">aes_encryption</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">'AES'</span><span class="p">,</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span>

<span class="n">constraints</span> <span class="o">=</span> <span class="p">[</span><span class="n">sboxmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">sboxes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="mi">64</span><span class="p">):</span>
    <span class="n">four_code</span> <span class="o">=</span> <span class="n">sboxmap</span><span class="p">[</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="n">four_code_parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Extract</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="n">four_code</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data_int</span><span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span><span class="p">:</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">],</span> <span class="n">four_code_parts</span><span class="p">):</span>
        <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Distinct</span><span class="p">([</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxints</span><span class="p">]))</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">solver</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
<span class="c1"># if solver.check() == sat:
# m = solver.model()
</span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">all_smt</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
    <span class="n">flag_bytes</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]).</span><span class="n">as_long</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flag</span><span class="p">))])</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
        <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">64</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">64</span><span class="p">)))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"failed to solve"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="alternate-solution-by-teammate-utaha6878">Alternate Solution by teammate (Utaha#6878)</h3>

<p>All due regards to him for solving the challenge while I was stuck over finding<br />
<code class="language-plaintext highlighter-rouge">key1</code> XD</p>

<p>All parts will be almost same except the substitution solving part, which he<br />
did by manual bruteforcing i.e. recursively enumerating all mappings and
backtracking on contradictions</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">codes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">)],</span> <span class="n">start</span><span class="o">=</span><span class="p">[])</span> 
<span class="c1"># notice that the range is changed from [0xb0, 0x1b0) to [0, 256). 
# It's just for relabeling.
</span><span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
	<span class="s">"""
	equate two objects elementwise ignoring if the entry is -1
	"""</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>

<span class="n">answers</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">getFlag</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">):</span> 
<span class="c1"># get the flag based on current mapping, unknown char will be shown as '?'
</span>    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cip</span><span class="p">:</span>
        <span class="n">afterMap</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span>
        <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sboxes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">afterMap</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s">'?'</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">brute</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">):</span>
    <span class="s">"""
    cip and sboxes remain unchanged throughout the recursive call, 
    but I feel bad using global varaibles.
    """</span>
    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">getFlag</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">))</span>

    <span class="c1"># check is finished
</span>    <span class="n">isFinished</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cip</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">mp</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">isFinished</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="n">isFinished</span><span class="p">:</span>
        <span class="n">answers</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">getFlag</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Found an answer!!!!!!!"</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># try matching
</span>    <span class="n">isContradiction</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Find the one with least possible matches.
</span>    <span class="n">min_pos</span> <span class="o">=</span> <span class="mi">256</span>
    <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cip</span><span class="p">):</span>
        <span class="n">afterMap</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span>
        <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">afterMap</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sboxes</span> <span class="k">if</span> <span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">afterMap</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">isContradiction</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">min_pos</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="n">min_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">isContradiction</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># now bruteforce all possibilities
</span>    <span class="k">assert</span> <span class="n">index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">afterMap</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cip</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sboxes</span> <span class="k">if</span> <span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">afterMap</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cip</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">mp</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">brute</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">)</span>

<span class="c1"># This is based on the repetition
</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">132</span><span class="p">,</span> <span class="mi">197</span><span class="p">]:</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="p">{</span><span class="mi">35</span><span class="p">:</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">109</span><span class="p">:</span> <span class="mi">144</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="n">_</span><span class="p">}</span>
    <span class="n">brute</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Answers:"</span><span class="p">)</span>
<span class="n">answers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">answers</span><span class="p">))</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">answers</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">b</span><span class="s">"sdctf{"</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"}"</span><span class="p">)</span>

<span class="c1"># The fourth one is the actual answer
</span></code></pre></div></div>

<blockquote>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ciphertext repetition:
[4, 5, 4, 6]
[34, 35, 36, 35]
[109, 60, 110, 109]
Sbox repetition:
[132, 93, 132, 211]
[197, 32, 197, 248]
[144, 86, 67, 144]
[165, 224, 27, 224]
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Answers:
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}'
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}'
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}'
</code></pre></div>  </div>
</blockquote>

<p>full script in <a href="./solve2.py">solve2.py</a></p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="SDCTF" /><category term="2022" /><category term="cryptography" /><category term="AES" /><category term="z3" /><category term="substitution" /><category term="permutation" /><summary type="html"><![CDATA[Tasty Crypto Roll Description CRYPTO - Hard Tasty Crypto Roll Bob, the genius intern at our company, invented AES-improved. It is based on AES but with layers after layers of proprietary encryption techniques on top of it. The end result is an encryption scheme that achieves both confusion and diffusion. The more layers of crypto you add, the better the security, right? Encrypter encrypt.py Encrypted file enc.bin Note The intended solution requires very little brute force and runs under 5 seconds on our machine. By k3v1n Source import os import random import secrets import sys from Crypto.Cipher import AES ENCODING = 'utf-8' def generate_key(): return os.getpid(), secrets.token_bytes(16) def to_binary(b: bytes): return ''.join(['{:08b}'.format(c) for c in b]) def from_binary(s: str): return bytes(int(s[i:i+8], 2) for i in range(0, len(s), 8)) def encrypt(key: bytes, message: bytes): cipher = AES.new(key, AES.MODE_ECB) return cipher.encrypt(message) key1, key2 = generate_key() print(f'Using Key:\n{key1}:{key2.hex()}') def get_flag(): flag = input('Enter the flag to encrypt: ') if not flag.startswith('sdctf{') or not flag.endswith('}') or not flag.isascii(): print(f'{flag} is not a valid flag for this challenge') sys.exit(1) return flag plaintext = get_flag()[6:-1] data = plaintext.encode(ENCODING) codes = list(''.join(chr(i) * 2 for i in range(0xb0, 0x1b0))) random.seed(key1) random.shuffle(codes) sboxes = [''.join(codes[i*4:(i+1)*4]) for i in range(128)] if len(set(sboxes)) &lt; 128: print("Bad key, try again") sys.exit(1) data = ''.join(sboxes[c] for c in data).encode(ENCODING) data = encrypt(key2, to_binary(data).encode(ENCODING)) random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data_bits = list(to_binary(data)) random.shuffle(data_bits) data = from_binary(''.join(data_bits)) ciphertext = encrypt(key_final, data) print(f'Encrypted: {ciphertext.hex()}') with open('enc.bin2', 'wb') as ef: ef.write(ciphertext) Analysis Here we can see mainly two parts There are two keys key1: pid of current process key2: secure random key of 16 bytes key1 is used as seed at a lot of places and is bruteforcable (&lt; 2^15) key_final and sboxes are derived from key1, shuffling is done using key1 Steps to crack decrypt using key_final convert the intermediate ciphertext to_binary de-shuffle the bits generate from_binary intermediate ciphertext of the deshuffled bits decrypt using key2??? How to find key1? Assume you have the correct key1, reverse for the key, validate the results using some validator/logical assumption. codes is a list of 2*(0x1b0-0xb0) = 512 characters, utf-8 encoding of which is 2-bytes each sboxes will have 4char strings, which encode to 8 bytes each on utf-8 (i.e after substitution) data is now 4*2 = 8 times each byte of the original plaintext data is converted to_binary before encryption hence each byte is converted to 8 b"0" or b"1" byte. Hence each character is substituted to some 8*8 = 64 byte string before encryption. Hence len of flag = len(ciphertext)//64 = 3520//64 = 55 bytes Assumption 1 Since length of flag is 55 characters, would it be reasonable to assume that there would be repeatitions of characters. And since each flag character is substituted to fixed 64-byte strings before encryption which is a multiple of AES block size of 16, AES also acts like simple substitution of the flag but we do not know the mapping. Hence if we reverse till step 4 above, we can simply check if there are any repeating 64-byte blocks, as incorrect shuffling of bits will result in each block to be distinct with almost 1 probability. with open('enc.bin', 'rb') as f: ciphertext = f.read() def to_binary(b: bytes): return ''.join(['{:08b}'.format(c) for c in b]) def from_binary(s: str): return bytes(int(s[i:i+8], 2) for i in range(0, len(s), 8)) def encrypt(key, message): return AES.new(key, AES.MODE_ECB).encrypt(message) def decrypt(key: bytes, message: bytes): return AES.new(key, AES.MODE_ECB).decrypt(message) def unshuffle(data_list, shuffle_order): res = [None]*len(data_list) for i,v in enumerate(shuffle_order): res[v] = data_list[i] return res def key_final_dec(key1, ciphertext): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data = decrypt(key_final, ciphertext) data_bits = list(to_binary(data)) data_bits_order = list(range(len(data_bits))) random.shuffle(data_bits_order) data_bits_uns = unshuffle(data_bits, data_bits_order) data = from_binary(''.join(data_bits_uns)) return data Lets add a few validation too def key_final_enc(key1, data): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data_bits = list(to_binary(data)) random.shuffle(data_bits) data = from_binary(''.join(data_bits)) return encrypt(key_final, data) def test_unshuffle(): random_text = list(random.randbytes(16*1337)) random_text_shuffled = random_text.copy() shuffle_order = list(range(len(random_text))) random.seed(1337) random.shuffle(random_text_shuffled) random.seed(1337) random.shuffle(shuffle_order) assert unshuffle(random_text_shuffled, shuffle_order) == random_text def test_key_final_dec(): random_text = random.randbytes(16*100) assert key_final_dec(1337, key_final_enc(1337, random_text)) == random_text test_unshuffle() test_key_final_dec() Looks like all the decryption functions are correct, lets proceed with bruteforcing for key1 for key1 in tqdm(range(2**15),desc='solving for key1'): data = key_final_dec(key1, ciphertext) substitutions = Counter(data[i:i+64] for i in range(0,len(data),64)) if len(substitutions)!=len(data)//64: print("pid =",key1) break After waiting for an eternity, and exhausting the search space of possible pidâ€™s yet not getting any key1 got me confused. I checked my script locally for a test flag it seemed to work fine. There could only be one possibility the flag contains 55 distinct characters But how would I find key1 now? Missed Catch @Utaha#6878 pointed out, that since there are only 256 distinct values in codes each repeated twice, and each character encoded to some b"0" or b"1" byte strings of length 16, It must be encrypted to the same block always. Since the flag is 55*4 = 220 such 16-byte codes and each code is used twice for most of the characters, there will be repating 16-byte blocks even with distinct flag characters. Assumption 2 for key1 in tqdm(range(2**15),desc='solving for key1'): data = key_final_dec(key1, ciphertext) substitutions = Counter(data[i:i+16] for i in range(0,len(data),16)) if len(substitutions)!=len(data)//16: print("pid =",key1) break pid = 83 And we found our key1! And we can confirm that the flag is indeed 55 distinct characters. Wait, if the flag is 55 distinct characters, how will we solve for the subs? We have no statistical advantage and hence bye bye Mr quipquip How do we find mapping for substitution? Each sbox entry is composed of 4 2-byte strings, which can be one of 256 possible values. Moreover, their order is fixed, which is determined by key1. If we try to solve for all valid mappings for AES(binary(sbox(char))) we will probably end up on the correct mapping and get our flag. +---------------+---------------+------------------------+---------------+ |flag0 | flag1 | | flag55 | +---------------+---------------+ .... +---------------+ | sbox | sbox | | sbox | +---+---+---+---+---+---+---+---+------------------------+---------------+ |c1 |c2 |c3 |c4 |c5 |c6 |c7 |c8 | | | | | | | | | | | | | | +---+---+---+---+---+---+---+---+ .... +---------------+ | AES | AES | | | +---+---+-------+---------------+------------------------+---------------+ | | +------+ | +--+ | +------+-------+-------+------+ |E(c1) | E(c2) | E(c3) | E(c4)| +------+-------+-------+------+ Enter Z3 We can assume our flag to be a list of BitVec of 7 bits each And let the sboxes be a mapping from 7 bits to 64 bits each (16x4) This can be achieved by assuming sbox to be an array which is indexed by BitVec(7) and contains elements of BitVec(64) And we assume AES to be some function form BitVec(16) to BitVec(128) flag = [BitVec('flag_'+str(i),7) for i in range(len(data)//64)] sboxmap = Array('sbox',BitVecSort(7), BitVecSort(64)) aes_encryption = Function('AES',BitVecSort(16), BitVecSort(128)) codes = list(''.join(chr(i) * 2 for i in range(0xb0, 0x1b0))) random.seed(key1) random.shuffle(codes) # keeping sboxes utf encoded already sboxes = [''.join(codes[i*4:(i+1)*4]).encode() for i in range(128)] sbytes = b''.join(sboxes) sboxints = list(map(lambda x:int.from_bytes(x,'big'), set(sbytes[i:i+2] for i in range(0,len(sbytes),2)))) # integer values for 2-byte codes from sbox, will be explained shortly sboxes = [int.from_bytes(i,'big') for i in sboxes] data = key_final_dec(key1, ciphertext) # converting intermediate decryption to 128 bit ints data_int = [] for i in range(0,len(data),16): data_int.append(int.from_bytes(data[i:i+16],'big')) # we know the sbox already constraints = [sboxmap[i]==sboxes[i] for i in range(128)] for i in range(len(data)//64): four_code = sboxmap[flag[i]] # splitting 64 bit quantity to 16 bit individual sbox codes four_code_parts = [Extract(16*i+15,16*i,four_code) for i in range(3,-1,-1)] # for each code, matching aes_encryption with the observed value for a,b in zip(data_int[4*i:4*i+4], four_code_parts): constraints.append(aes_encryption(b)==a) # last but not least, aes_encryption(i) is unique for each plaintext # how would z3 know? Distinct function encodes them appropriately to # be distinct constraints.append(Distinct([aes_encryption(i) for i in sboxints])) solver = Solver() solver.add(constraints) for m in all_smt(solver, flag): # lets check for all satisfying flags (in case there are more than one # possible mappings and we will rule out invalid ones in that scenario? flag_bytes = bytes([m.eval(flag[i]).as_long() for i in range(len(flag))]) assert len(set(flag_bytes)) == len(Counter(data[i:i+64] for i in range(0,len(data),64))) print(flag_bytes) Flag After running the script, we finally get our flag! b'r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU' And it turns out to be the only satisfying assignment. Turns out if there were repeated characters in the flag, we will get multiple possible satisfying values. So the admins have not been so cheeky afterall Full script Note that it takes a couple of seconds to find the z3 model import random from Crypto.Cipher import AES from collections import Counter from tqdm import tqdm from z3 import * import sys def all_smt(s, initial_terms): def block_term(s, m, t): s.add(t != m.eval(t)) def fix_term(s, m, t): s.add(t == m.eval(t)) def all_smt_rec(terms): if sat == s.check(): m = s.model() yield m for i in range(len(terms)): s.push() block_term(s, m, terms[i]) for j in range(i): fix_term(s, m, terms[j]) yield from all_smt_rec(terms[i:]) s.pop() yield from all_smt_rec(list(initial_terms)) with open('enc.bin', 'rb') as f: ciphertext = f.read() def to_binary(b: bytes): return ''.join(['{:08b}'.format(c) for c in b]) def from_binary(s: str): return bytes(int(s[i:i + 8], 2) for i in range(0, len(s), 8)) def encrypt(key, message): return AES.new(key, AES.MODE_ECB).encrypt(message) def decrypt(key: bytes, message: bytes): return AES.new(key, AES.MODE_ECB).decrypt(message) def key_final_enc(key1, data): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data_bits = list(to_binary(data)) random.shuffle(data_bits) data = from_binary(''.join(data_bits)) return encrypt(key_final, data) def unshuffle(data_list, shuffle_order): res = [None] * len(data_list) for i, v in enumerate(shuffle_order): res[v] = data_list[i] return res def test_unshuffle(): random_text = list(random.randbytes(16 * 100)) random_text_shuffled = random_text.copy() shuffle_order = list(range(len(random_text))) random.seed(10) random.shuffle(random_text_shuffled) random.seed(10) random.shuffle(shuffle_order) assert unshuffle(random_text_shuffled, shuffle_order) == random_text test_unshuffle() def key_final_dec(key1, ciphertext): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data = decrypt(key_final, ciphertext) data_bits = list(to_binary(data)) data_bits_order = list(range(len(data_bits))) random.shuffle(data_bits_order) data_bits_uns = unshuffle(data_bits, data_bits_order) data = from_binary(''.join(data_bits_uns)) return data def test_key_final_dec(): random_text = random.randbytes(16 * 100) assert key_final_dec(10, key_final_enc(10, random_text)) == random_text test_key_final_dec() for key1 in tqdm(range(2**15), desc='solving for key1'): data = key_final_dec(key1, ciphertext) substitutions = Counter(data[i:i + 16] for i in range(0, len(data), 16)) if len(substitutions) != len(data) // 16: print("pid =", key1) break codes = list(''.join(chr(i) * 2 for i in range(0xb0, 0x1b0))) random.seed(key1) random.shuffle(codes) sboxes = [''.join(codes[i * 4:(i + 1) * 4]).encode() for i in range(128)] sbytes = b''.join(sboxes) sboxints = list(map(lambda x: int.from_bytes(x, 'big'), set( sbytes[i:i + 2] for i in range(0, len(sbytes), 2)))) sboxes = [int.from_bytes(i, 'big') for i in sboxes] data = key_final_dec(key1, ciphertext) data_int = [] for i in range(0, len(data), 16): data_int.append(int.from_bytes(data[i:i + 16], 'big')) flag = [BitVec('flag_' + str(i), 7) for i in range(len(data) // 64)] sboxmap = Array('sbox', BitVecSort(7), BitVecSort(64)) aes_encryption = Function('AES', BitVecSort(16), BitVecSort(128)) constraints = [sboxmap[i] == sboxes[i] for i in range(128)] for i in range(len(data) // 64): four_code = sboxmap[flag[i]] four_code_parts = [Extract(16 * i + 15, 16 * i, four_code) for i in range(3, -1, -1)] for a, b in zip(data_int[4 * i:4 * i + 4], four_code_parts): constraints.append(aes_encryption(b) == a) constraints.append(Distinct([aes_encryption(i) for i in sboxints])) solver = Solver() solver.add(constraints) # if solver.check() == sat: # m = solver.model() for m in all_smt(solver, flag): flag_bytes = bytes([m.eval(flag[i]).as_long() for i in range(len(flag))]) assert len(set(flag_bytes)) == len( Counter(data[i:i + 64] for i in range(0, len(data), 64))) print(flag_bytes) else: print("failed to solve") Alternate Solution by teammate (Utaha#6878) All due regards to him for solving the challenge while I was stuck over finding key1 XD All parts will be almost same except the substitution solving part, which he did by manual bruteforcing i.e. recursively enumerating all mappings and backtracking on contradictions mp = dict() codes = sum([[i, i] for i in range(256)], start=[]) # notice that the range is changed from [0xb0, 0x1b0) to [0, 256). # It's just for relabeling. random.seed(key1) random.shuffle(codes) sboxes = [codes[i*4:(i+1)*4] for i in range(128)] def match(a, b): """ equate two objects elementwise ignoring if the entry is -1 """ for x, y in zip(a, b): if x == -1 or y == -1: continue if x != y: return False return True answers = [] def getFlag(cip, sboxes, mp): # get the flag based on current mapping, unknown char will be shown as '?' res = [] for c in cip: afterMap = [mp.get(x, -1) for x in c] found = False for i, s in enumerate(sboxes): if s == afterMap: res.append(i) found = True break if not found: res.append(ord('?')) return bytes(res) def brute(cip, sboxes, mp): """ cip and sboxes remain unchanged throughout the recursive call, but I feel bad using global varaibles. """ if DEBUG: print(getFlag(cip, sboxes, mp)) # check is finished isFinished = True for c in cip: if all(x in mp for x in c): pass else: isFinished = False if isFinished: answers.append(getFlag(cip, sboxes, mp)) print("Found an answer!!!!!!!") return # try matching isContradiction = False mp = mp.copy() # Find the one with least possible matches. min_pos = 256 index = -1 for idx, c in enumerate(cip): afterMap = [mp.get(x, -1) for x in c] if -1 not in afterMap: continue matches = [s for s in sboxes if match(s, afterMap)] if len(matches) == 0: isContradiction = True break if min_pos &gt; len(matches): index = idx min_pos = len(matches) if isContradiction: return # now bruteforce all possibilities assert index != -1 afterMap = [mp.get(x, -1) for x in cip[index]] matches = [s for s in sboxes if match(s, afterMap)] for m in matches: for x, y in zip(cip[index], m): mp[x] = y brute(cip, sboxes, mp) # This is based on the repetition for _ in [132, 197]: mp = {35: 224, 109: 144, 4: _} brute(cip, sboxes, mp) print("Answers:") answers = list(set(answers)) for x in answers: print(b"sdctf{" + x + b"}") # The fourth one is the actual answer Ciphertext repetition: [4, 5, 4, 6] [34, 35, 36, 35] [109, 60, 110, 109] Sbox repetition: [132, 93, 132, 211] [197, 32, 197, 248] [144, 86, 67, 144] [165, 224, 27, 224] Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Answers: b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}' b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}' b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}' full script in solve2.py]]></summary></entry><entry><title type="html">Nahamcon 2020 Crypto - December</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/December/2020-06-14-Nahamcon-2020-December" rel="alternate" type="text/html" title="Nahamcon 2020 Crypto - December" /><published>2020-06-14T00:00:00+05:30</published><updated>2020-06-14T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/December/Nahamcon-2020-December</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/December/2020-06-14-Nahamcon-2020-December"><![CDATA[<h1 id="december">December</h1>

<p><img src="Capture.PNG" alt="" /></p>

<p>We are provided with <a href="source.py">source.py</a>, which reads</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span>
<span class="kn">from</span> <span class="nn">Crypto.Cipher</span> <span class="kn">import</span> <span class="n">DES</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'flag.txt'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">handle</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">padding_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">8</span> <span class="o">-</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span> <span class="p">))</span>
<span class="n">flag</span> <span class="o">=</span> <span class="n">flag</span><span class="p">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">padding_size</span><span class="p">,</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">)</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'key'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">handle</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">strip</span><span class="p">()</span>

<span class="n">iv</span> <span class="o">=</span> <span class="s">"13371337"</span>
<span class="n">des</span> <span class="o">=</span> <span class="n">DES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">DES</span><span class="p">.</span><span class="n">MODE_OFB</span><span class="p">,</span> <span class="n">iv</span><span class="p">)</span>
<span class="n">ct</span> <span class="o">=</span> <span class="n">des</span><span class="p">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'ciphertext'</span><span class="p">,</span><span class="s">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
        <span class="n">handle</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>
</code></pre></div></div>

<p>And a binary <a href="ciphertext">ciphertext</a></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00000000: d6a2 6fe5 c75c 22e0 5413 5e4e 1140 5d58  ..o..\".T.^N.@]X
00000010: f5ea 69f9 d419 31f7 5513 5745 5452 5e44  ..i...1.U.WETR^D
00000020: 889e 62ff d15c 2ae1 115e 5617 4141 5643  ..b..\*..^V.AAVC
00000030: e7a4 6eff cc1b 49f4 5d52 544c 455b 5a44  ..n...I.]RTLE[ZD
00000040: dda3 79c9 c310 2fcd 586c 5d52 5457 4e37  ..y.../.Xl]RTWN7
</code></pre></div></div>
<p>Which is quite unusual in the sense that most of it is readable in unusual sizes of <code class="language-plaintext highlighter-rouge">8</code>.<br />
This could be another instance of <a href="https://en.wikipedia.org/wiki/Weak_key#Weak_keys_in_DES">Weak keys</a><br />
Lets quickly run through the 4 weak keys</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">m</span> <span class="n">Crypto</span><span class="p">.</span><span class="n">Cipher</span> <span class="kn">import</span> <span class="nn">DES</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'ciphertext'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">ct_file</span><span class="p">:</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="n">ct_file</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">weak_keys</span> <span class="o">=</span> <span class="p">[</span>
    <span class="sa">b</span><span class="s">'</span><span class="se">\x01\x01\x01\x01\x01\x01\x01\x01</span><span class="s">'</span><span class="p">,</span>
    <span class="sa">b</span><span class="s">'</span><span class="se">\xFE\xFE\xFE\xFE\xFE\xFE\xFE\xFE</span><span class="s">'</span><span class="p">,</span>
    <span class="sa">b</span><span class="s">'</span><span class="se">\xE0\xE0\xE0\xE0\xF1\xF1\xF1\xF1</span><span class="s">'</span><span class="p">,</span>
    <span class="sa">b</span><span class="s">'</span><span class="se">\x1F\x1F\x1F\x1F\x0E\x0E\x0E\x0E</span><span class="s">'</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">weak_keys</span><span class="p">:</span>
    <span class="n">iv</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"13371337"</span>
    <span class="n">des</span> <span class="o">=</span> <span class="n">DES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">DES</span><span class="p">.</span><span class="n">MODE_OFB</span><span class="p">,</span> <span class="n">iv</span><span class="p">)</span>
    <span class="n">pt</span> <span class="o">=</span> <span class="n">des</span><span class="p">.</span><span class="n">decrypt</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
</code></pre></div></div>

<p>Which produces the plaintexts</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sa">b</span><span class="s">'</span><span class="se">\xaf\xe0\xda\x8c</span><span class="s">=</span><span class="se">\xed</span><span class="s">G</span><span class="se">\xe4</span><span class="s">e my sno</span><span class="se">\x8c\xa8\xdc\x90</span><span class="s">.</span><span class="se">\xa8</span><span class="s">T</span><span class="se">\xf3</span><span class="s">d dreams</span><span class="se">\xf1\xdc\xd7\x96</span><span class="s">+</span><span class="se">\xed</span><span class="s">O</span><span class="se">\xe5</span><span class="s"> me pret</span><span class="se">\x9e\xe6\xdb\x96</span><span class="s">6</span><span class="se">\xaa</span><span class="s">,</span><span class="se">\xf0</span><span class="s">lag{this</span><span class="se">\xa4\xe1\xcc\xa0</span><span class="s">9</span><span class="se">\xa1</span><span class="s">J</span><span class="se">\xc9</span><span class="s">i_need}</span><span class="se">\x00</span><span class="s">'</span>
<span class="sa">b</span><span class="s">'</span><span class="se">\xb8</span><span class="s">(</span><span class="se">\xff\x82\xb0</span><span class="s">)</span><span class="se">\x06</span><span class="s">$e my sno</span><span class="se">\x9b</span><span class="s">`</span><span class="se">\xf9\x9e\xa3</span><span class="s">l</span><span class="se">\x15</span><span class="s">3d dreams</span><span class="se">\xe6\x14\xf2\x98\xa6</span><span class="s">)</span><span class="se">\x0e</span><span class="s">% me pret</span><span class="se">\x89</span><span class="s">.</span><span class="se">\xfe\x98\xbb</span><span class="s">nm0lag{this</span><span class="se">\xb3</span><span class="s">)</span><span class="se">\xe9\xae\xb4</span><span class="s">e</span><span class="se">\x0b\t</span><span class="s">i_need}</span><span class="se">\x00</span><span class="s">'</span>
<span class="sa">b</span><span class="s">'c</span><span class="se">\xad\xc7\x9d</span><span class="s">VR$</span><span class="se">\xb2</span><span class="s">e my sno@</span><span class="se">\xe5\xc1\x81</span><span class="s">E</span><span class="se">\x17</span><span class="s">7</span><span class="se">\xa5</span><span class="s">d dreams=</span><span class="se">\x91\xca\x87</span><span class="s">@R,</span><span class="se">\xb3</span><span class="s"> me pretR</span><span class="se">\xab\xc6\x87</span><span class="s">]</span><span class="se">\x15</span><span class="s">O</span><span class="se">\xa6</span><span class="s">lag{thish</span><span class="se">\xac\xd1\xb1</span><span class="s">R</span><span class="se">\x1e</span><span class="s">)</span><span class="se">\x9f</span><span class="s">i_need}</span><span class="se">\x00</span><span class="s">'</span>
<span class="sa">b</span><span class="s">'These are my snow covered dreams</span><span class="se">\n</span><span class="s">This is me pretending</span><span class="se">\n</span><span class="s">flag{this_is_all_i_need}</span><span class="se">\x00</span><span class="s">'</span>
</code></pre></div></div>

<h3 id="flagthis_is_all_i_need">flag{this_is_all_i_need}</h3>

<h2 id="how-to-solve-the-challenge-if-not-aware-of-weak-keys">How to solve the challenge if not aware of weak keys?</h2>

<p><img src="ctftime1.PNG" alt="" /></p>

<p><img src="ctftime2.PNG" alt="" /></p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="nahamcon" /><category term="2020" /><category term="cryptography" /><category term="DES" /><category term="weak_keys" /><summary type="html"><![CDATA[December We are provided with source.py, which reads #!/usr/bin/env python from Crypto.Cipher import DES with open('flag.txt', 'rb') as handle: flag = handle.read() padding_size = len(flag) + (8 - ( len(flag) % 8 )) flag = flag.ljust(padding_size, b'\x00') with open('key', 'rb') as handle: key = handle.read().strip() iv = "13371337" des = DES.new(key, DES.MODE_OFB, iv) ct = des.encrypt(flag) with open('ciphertext','wb') as handle: handle.write(ct) And a binary ciphertext 00000000: d6a2 6fe5 c75c 22e0 5413 5e4e 1140 5d58 ..o..\".T.^N.@]X 00000010: f5ea 69f9 d419 31f7 5513 5745 5452 5e44 ..i...1.U.WETR^D 00000020: 889e 62ff d15c 2ae1 115e 5617 4141 5643 ..b..\*..^V.AAVC 00000030: e7a4 6eff cc1b 49f4 5d52 544c 455b 5a44 ..n...I.]RTLE[ZD 00000040: dda3 79c9 c310 2fcd 586c 5d52 5457 4e37 ..y.../.Xl]RTWN7 Which is quite unusual in the sense that most of it is readable in unusual sizes of 8. This could be another instance of Weak keys Lets quickly run through the 4 weak keys m Crypto.Cipher import DES with open('ciphertext', 'rb') as ct_file: ct = ct_file.read() weak_keys = [ b'\x01\x01\x01\x01\x01\x01\x01\x01', b'\xFE\xFE\xFE\xFE\xFE\xFE\xFE\xFE', b'\xE0\xE0\xE0\xE0\xF1\xF1\xF1\xF1', b'\x1F\x1F\x1F\x1F\x0E\x0E\x0E\x0E' ] for key in weak_keys: iv = b"13371337" des = DES.new(key, DES.MODE_OFB, iv) pt = des.decrypt(ct) print(pt) Which produces the plaintexts b'\xaf\xe0\xda\x8c=\xedG\xe4e my sno\x8c\xa8\xdc\x90.\xa8T\xf3d dreams\xf1\xdc\xd7\x96+\xedO\xe5 me pret\x9e\xe6\xdb\x966\xaa,\xf0lag{this\xa4\xe1\xcc\xa09\xa1J\xc9i_need}\x00' b'\xb8(\xff\x82\xb0)\x06$e my sno\x9b`\xf9\x9e\xa3l\x153d dreams\xe6\x14\xf2\x98\xa6)\x0e% me pret\x89.\xfe\x98\xbbnm0lag{this\xb3)\xe9\xae\xb4e\x0b\ti_need}\x00' b'c\xad\xc7\x9dVR$\xb2e my sno@\xe5\xc1\x81E\x177\xa5d dreams=\x91\xca\x87@R,\xb3 me pretR\xab\xc6\x87]\x15O\xa6lag{thish\xac\xd1\xb1R\x1e)\x9fi_need}\x00' b'These are my snow covered dreams\nThis is me pretending\nflag{this_is_all_i_need}\x00' flag{this_is_all_i_need} How to solve the challenge if not aware of weak keys?]]></summary></entry><entry><title type="html">Nahamcon 2020 Crypto - Docxor</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/Docxor/2020-06-14-Nahamcon-2020-Docxor" rel="alternate" type="text/html" title="Nahamcon 2020 Crypto - Docxor" /><published>2020-06-14T00:00:00+05:30</published><updated>2020-06-14T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/Docxor/Nahamcon-2020-Docxor</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/Docxor/2020-06-14-Nahamcon-2020-Docxor"><![CDATA[<h1 id="docxor">Docxor</h1>

<p><img src="Capture.PNG" alt="" /></p>

<p>Getting hints from the name, one could tell, it is XOR and its about a doc.<br />
Still, first thing to consider is running the <code class="language-plaintext highlighter-rouge">file</code> command to see whats the <a href="homework">homework</a> file is about</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>file homework
homework: data
</code></pre></div></div>
<p>Cool! this means, the <code class="language-plaintext highlighter-rouge">homework</code> file is simply XOR encryption of a <code class="language-plaintext highlighter-rouge">.doc</code> file with 4 byte key. But hey that should ring bells since the first few bytes are <a href="https://en.wikipedia.org/wiki/List_of_file_signatures">file signature</a> also called magic bytes sometimes.<br />
Using the magic bytes, we can recover the xor key and hence the full document after xoring with the xor key.<br />
<img src="magic.PNG" alt="" /></p>

<p>The magic bytes we seek are <code class="language-plaintext highlighter-rouge">50 4B 03 04</code>.
The first four bytes of the <code class="language-plaintext highlighter-rouge">homework</code> are <code class="language-plaintext highlighter-rouge">0a0a 9abf</code>, the xor key should be <code class="language-plaintext highlighter-rouge">0a0a9abf ^ 504b0304</code> = <code class="language-plaintext highlighter-rouge">5a4199bb</code> 
Lets write a quick script.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="n">xor</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'homework'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">homework_file</span><span class="p">:</span>
    <span class="n">homework_data</span> <span class="o">=</span> <span class="n">homework_file</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">HEADER</span> <span class="o">=</span> <span class="n">homework_data</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span>
<span class="n">MAGIC</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"</span><span class="se">\x50\x4B\x03\x04</span><span class="s">"</span>
<span class="n">XOR_KEY</span> <span class="o">=</span> <span class="n">xor</span><span class="p">(</span><span class="n">HEADER</span><span class="p">,</span> <span class="n">MAGIC</span><span class="p">)</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'decrypted.doc'</span><span class="p">,</span> <span class="s">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">decrypted</span><span class="p">:</span>
    <span class="n">decrypted</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">xor</span><span class="p">(</span><span class="n">XOR_KEY</span><span class="p">,</span> <span class="n">homework_data</span><span class="p">))</span>
</code></pre></div></div>

<p>This produces <a href="decrypted.doc">decrypted.doc</a> which when opened looks like
<img src="doc_contents.PNG" alt="" /></p>

<h3 id="flagxor_is_not_for_security">flag{xor_is_not_for_security}</h3>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="nahamcon" /><category term="2020" /><category term="cryptography" /><category term="magic" /><category term="xor" /><category term="known_plaintext" /><summary type="html"><![CDATA[Docxor Getting hints from the name, one could tell, it is XOR and its about a doc. Still, first thing to consider is running the file command to see whats the homework file is about file homework homework: data Cool! this means, the homework file is simply XOR encryption of a .doc file with 4 byte key. But hey that should ring bells since the first few bytes are file signature also called magic bytes sometimes. Using the magic bytes, we can recover the xor key and hence the full document after xoring with the xor key. The magic bytes we seek are 50 4B 03 04. The first four bytes of the homework are 0a0a 9abf, the xor key should be 0a0a9abf ^ 504b0304 = 5a4199bb Lets write a quick script. from pwn import xor with open('homework', 'rb') as homework_file: homework_data = homework_file.read() HEADER = homework_data[0:4] MAGIC = b"\x50\x4B\x03\x04" XOR_KEY = xor(HEADER, MAGIC) with open('decrypted.doc', 'wb') as decrypted: decrypted.write(xor(XOR_KEY, homework_data)) This produces decrypted.doc which when opened looks like flag{xor_is_not_for_security}]]></summary></entry><entry><title type="html">Nahamcon 2020 Crypto - Homecooked</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/Homecooked/2020-06-14-Nahamcon-2020-Homecooked" rel="alternate" type="text/html" title="Nahamcon 2020 Crypto - Homecooked" /><published>2020-06-14T00:00:00+05:30</published><updated>2020-06-14T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/Homecooked/Nahamcon-2020-Homecooked</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/Homecooked/2020-06-14-Nahamcon-2020-Homecooked"><![CDATA[<h1 id="homecooked">Homecooked</h1>

<p><img src="Capture.PNG" alt="" /></p>

<p>We are provided <a href="decrypt.py">decrypt.py</a>, the contents of which read</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">base64</span>
<span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">cipher_b64</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"MTAwLDExMSwxMDAsOTYsMTEyLDIxLDIwOSwxNjYsMjE2LDE0MCwzMzAsMzE4LDMyMSw3MDIyMSw3MDQxNCw3MDU0NCw3MTQxNCw3MTgxMCw3MjIxMSw3MjgyNyw3MzAwMCw3MzMxOSw3MzcyMiw3NDA4OCw3NDY0Myw3NTU0MiwxMDAyOTAzLDEwMDgwOTQsMTAyMjA4OSwxMDI4MTA0LDEwMzUzMzcsMTA0MzQ0OCwxMDU1NTg3LDEwNjI1NDEsMTA2NTcxNSwxMDc0NzQ5LDEwODI4NDQsMTA4NTY5NiwxMDkyOTY2LDEwOTQwMDA="</span>

<span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">num</span><span class="p">):</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>

<span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="n">my_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
    <span class="n">rev_str</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">my_str</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">my_str</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">rev_str</span><span class="p">):</span>
       <span class="k">return</span> <span class="bp">True</span>
    <span class="k">else</span><span class="p">:</span>
       <span class="k">return</span> <span class="bp">False</span>


<span class="n">cipher</span> <span class="o">=</span> <span class="n">base64</span><span class="p">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">cipher_b64</span><span class="p">).</span><span class="n">decode</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="s">","</span><span class="p">)</span>

<span class="k">while</span><span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cipher</span><span class="p">)):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="n">num</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="n">num</span><span class="p">)):</span>
            <span class="k">print</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">cipher</span><span class="p">[</span><span class="n">count</span><span class="p">])</span> <span class="o">^</span> <span class="n">num</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">13</span><span class="p">):</span>
                <span class="n">num</span> <span class="o">=</span> <span class="mi">50000</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">26</span><span class="p">):</span>
                <span class="n">num</span> <span class="o">=</span> <span class="mi">500000</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">num</span><span class="o">+=</span><span class="mi">1</span>

<span class="k">print</span><span class="p">()</span>
</code></pre></div></div>
<p>Here two functions <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are of primary focus,</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">num</span><span class="p">):</span>  <span class="c1">#From all numbers from 2 to num - 1
</span>            <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">%</span> <span class="n">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1">#check if the number i divides num
</span>                <span class="k">return</span> <span class="bp">False</span>    <span class="c1">#if it divides, then its composite
</span>                <span class="k">break</span>
        <span class="k">return</span> <span class="bp">True</span>  <span class="c1"># No such number found hence prime
</span>    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>
<p>Seems like, its looping over all possible numbers to check if the provided number <code class="language-plaintext highlighter-rouge">num</code> is a prime or not</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="n">my_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="c1"># string representation of number
</span>    <span class="n">rev_str</span> <span class="o">=</span> <span class="nb">reversed</span><span class="p">(</span><span class="n">my_str</span><span class="p">)</span>  <span class="c1"># reverse the string
</span>    <span class="k">if</span> <span class="nb">list</span><span class="p">(</span><span class="n">my_str</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">(</span><span class="n">rev_str</span><span class="p">):</span> <span class="c1"># check if both equal
</span>       <span class="k">return</span> <span class="bp">True</span>  <span class="c1"># the input is a palindrome
</span>    <span class="k">else</span><span class="p">:</span>
       <span class="k">return</span> <span class="bp">False</span>
</code></pre></div></div>
<p>This function just checks if <code class="language-plaintext highlighter-rouge">num</code> is a <a href="https://en.wikipedia.org/wiki/Palindrome">palindrome</a></p>

<p>The <code class="language-plaintext highlighter-rouge">cipher_b64</code> is simply a base64 encoding of a comma separated list of numbers</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>100,111,100,96,112,21,209,166,216,140,330,318,321,70221,70414,70544,71414,71810,72211,72827,73000,73319,73722,74088,74643,75542,1002903,1008094,1022089,1028104,1035337,1043448,1055587,1062541,1065715,1074749,1082844,1085696,1092966,1094000
</code></pre></div></div>

<p>It is simply taking number from the list and xoring with next prime-palindrome to give the character in sets of 13. Lets simply run the <code class="language-plaintext highlighter-rouge">decrypt.py</code> to see what happens</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3 decrypt.py
flag{pR1m3s_4re_co0ler_Wh3
</code></pre></div></div>
<p>Hmm, seems stuck. Whatâ€™s the issue?<br />
The issue is with function <code class="language-plaintext highlighter-rouge">a</code> which checks for prime by dividing it by all numbers.<br />
This can be done pretty efficiently by better <a href="https://en.wikipedia.org/wiki/Primality_test">primality tests</a>.<br />
One could simply use <code class="language-plaintext highlighter-rouge">is_prime</code> from <code class="language-plaintext highlighter-rouge">gmpy2</code> library of python and replace the function <code class="language-plaintext highlighter-rouge">a</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">base64</span>
<span class="kn">import</span> <span class="nn">gmpy2</span>
<span class="n">num</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">cipher_b64</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"MTAwLDExMSwxMDAsOTYsMTEyLDIxLDIwOSwxNjYsMjE2LDE0MCwzMzAsMzE4LDMyMSw3MDIyMSw3MDQxNCw3MDU0NCw3MTQxNCw3MTgxMCw3MjIxMSw3MjgyNyw3MzAwMCw3MzMxOSw3MzcyMiw3NDA4OCw3NDY0Myw3NTU0MiwxMDAyOTAzLDEwMDgwOTQsMTAyMjA4OSwxMDI4MTA0LDEwMzUzMzcsMTA0MzQ0OCwxMDU1NTg3LDEwNjI1NDEsMTA2NTcxNSwxMDc0NzQ5LDEwODI4NDQsMTA4NTY5NiwxMDkyOTY2LDEwOTQwMDA="</span>

<span class="k">def</span> <span class="nf">a</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">gmpy2</span><span class="p">.</span><span class="n">is_prime</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">b</span><span class="p">(</span><span class="n">num</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="o">==</span> <span class="nb">str</span><span class="p">(</span><span class="n">num</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="n">cipher</span> <span class="o">=</span> <span class="n">base64</span><span class="p">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">cipher_b64</span><span class="p">).</span><span class="n">decode</span><span class="p">().</span><span class="n">split</span><span class="p">(</span><span class="s">","</span><span class="p">)</span>

<span class="k">while</span><span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">cipher</span><span class="p">)):</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">(</span><span class="n">num</span><span class="p">)):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="p">(</span><span class="n">num</span><span class="p">)):</span>
            <span class="k">print</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">cipher</span><span class="p">[</span><span class="n">count</span><span class="p">])</span> <span class="o">^</span> <span class="n">num</span><span class="p">),</span> <span class="n">end</span><span class="o">=</span><span class="s">''</span><span class="p">,</span> <span class="n">flush</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">13</span><span class="p">):</span>
                <span class="n">num</span> <span class="o">=</span> <span class="mi">50000</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">26</span><span class="p">):</span>
                <span class="n">num</span> <span class="o">=</span> <span class="mi">500000</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="n">num</span><span class="o">+=</span><span class="mi">1</span>

<span class="k">print</span><span class="p">()</span>
</code></pre></div></div>
<p>Now running <a href="solve.py">solve.py</a> spews the flag instantly</p>

<h3 id="flagpr1m3s_4re_co0ler_wh3n_pal1ndr0mic">flag{pR1m3s_4re_co0ler_Wh3n_pal1nDr0miC}</h3>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="nahamcon" /><category term="2020" /><category term="cryptography" /><category term="base64" /><category term="prime" /><category term="palindrome" /><summary type="html"><![CDATA[Homecooked We are provided decrypt.py, the contents of which read import base64 num = 0 count = 0 cipher_b64 = b"MTAwLDExMSwxMDAsOTYsMTEyLDIxLDIwOSwxNjYsMjE2LDE0MCwzMzAsMzE4LDMyMSw3MDIyMSw3MDQxNCw3MDU0NCw3MTQxNCw3MTgxMCw3MjIxMSw3MjgyNyw3MzAwMCw3MzMxOSw3MzcyMiw3NDA4OCw3NDY0Myw3NTU0MiwxMDAyOTAzLDEwMDgwOTQsMTAyMjA4OSwxMDI4MTA0LDEwMzUzMzcsMTA0MzQ0OCwxMDU1NTg3LDEwNjI1NDEsMTA2NTcxNSwxMDc0NzQ5LDEwODI4NDQsMTA4NTY5NiwxMDkyOTY2LDEwOTQwMDA=" def a(num): if (num &gt; 1): for i in range(2,num): if (num % i) == 0: return False break return True else: return False def b(num): my_str = str(num) rev_str = reversed(my_str) if list(my_str) == list(rev_str): return True else: return False cipher = base64.b64decode(cipher_b64).decode().split(",") while(count &lt; len(cipher)): if (a(num)): if (b(num)): print(chr(int(cipher[count]) ^ num), end='', flush=True) count += 1 if (count == 13): num = 50000 if (count == 26): num = 500000 else: pass num+=1 print() Here two functions a and b are of primary focus, def a(num): if (num &gt; 1): for i in range(2,num): #From all numbers from 2 to num - 1 if (num % i) == 0: #check if the number i divides num return False #if it divides, then its composite break return True # No such number found hence prime else: return False Seems like, its looping over all possible numbers to check if the provided number num is a prime or not def b(num): my_str = str(num) # string representation of number rev_str = reversed(my_str) # reverse the string if list(my_str) == list(rev_str): # check if both equal return True # the input is a palindrome else: return False This function just checks if num is a palindrome The cipher_b64 is simply a base64 encoding of a comma separated list of numbers 100,111,100,96,112,21,209,166,216,140,330,318,321,70221,70414,70544,71414,71810,72211,72827,73000,73319,73722,74088,74643,75542,1002903,1008094,1022089,1028104,1035337,1043448,1055587,1062541,1065715,1074749,1082844,1085696,1092966,1094000 It is simply taking number from the list and xoring with next prime-palindrome to give the character in sets of 13. Lets simply run the decrypt.py to see what happens python3 decrypt.py flag{pR1m3s_4re_co0ler_Wh3 Hmm, seems stuck. Whatâ€™s the issue? The issue is with function a which checks for prime by dividing it by all numbers. This can be done pretty efficiently by better primality tests. One could simply use is_prime from gmpy2 library of python and replace the function a import base64 import gmpy2 num = 0 count = 0 cipher_b64 = b"MTAwLDExMSwxMDAsOTYsMTEyLDIxLDIwOSwxNjYsMjE2LDE0MCwzMzAsMzE4LDMyMSw3MDIyMSw3MDQxNCw3MDU0NCw3MTQxNCw3MTgxMCw3MjIxMSw3MjgyNyw3MzAwMCw3MzMxOSw3MzcyMiw3NDA4OCw3NDY0Myw3NTU0MiwxMDAyOTAzLDEwMDgwOTQsMTAyMjA4OSwxMDI4MTA0LDEwMzUzMzcsMTA0MzQ0OCwxMDU1NTg3LDEwNjI1NDEsMTA2NTcxNSwxMDc0NzQ5LDEwODI4NDQsMTA4NTY5NiwxMDkyOTY2LDEwOTQwMDA=" def a(num): return gmpy2.is_prime(num) def b(num): return str(num) == str(num)[::-1] cipher = base64.b64decode(cipher_b64).decode().split(",") while(count &lt; len(cipher)): if (a(num)): if (b(num)): print(chr(int(cipher[count]) ^ num), end='', flush=True) count += 1 if (count == 13): num = 50000 if (count == 26): num = 500000 else: pass num+=1 print() Now running solve.py spews the flag instantly flag{pR1m3s_4re_co0ler_Wh3n_pal1nDr0miC}]]></summary></entry><entry><title type="html">Nahamcon 2020 Crypto - Oo la la</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/Ooo-la-la/2020-06-14-Nahamcon-2020-Ooo-la-la" rel="alternate" type="text/html" title="Nahamcon 2020 Crypto - Oo la la" /><published>2020-06-14T00:00:00+05:30</published><updated>2020-06-14T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/Ooo-la-la/Nahamcon-2020-Ooo-la-la</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/Ooo-la-la/2020-06-14-Nahamcon-2020-Ooo-la-la"><![CDATA[<h1 id="ooo-la-la">Ooo-la-la</h1>

<p><img src="Capture.PNG" alt="" /></p>

<p>We are provided <a href="prompt.txt">prompt.txt</a>, the contents of which read</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>N = 3349683240683303752040100187123245076775802838668125325785318315004398778586538866210198083573169673444543518654385038484177110828274648967185831623610409867689938609495858551308025785883804091
e = 65537
c = 87760575554266991015431110922576261532159376718765701749513766666239189012106797683148334771446801021047078003121816710825033894805743112580942399985961509685534309879621205633997976721084983
</code></pre></div></div>
<p>Seems like usual RSA, lets see if we can factor <code class="language-plaintext highlighter-rouge">N</code> over <a href="https://www.alpertron.com.ar/ECM.HTM">alpetron</a></p>

<p><img src="alpetron.PNG" alt="" />
Which almost instantly factors the <code class="language-plaintext highlighter-rouge">N</code> using <a href="https://en.wikipedia.org/wiki/Lenstra_elliptic-curve_factorization">Elliptic Curve Method</a></p>

<p>Knowing the factors or phi, rest of the job is easy</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">gmpy2</span> <span class="kn">import</span> <span class="n">invert</span>
<span class="n">p</span> <span class="o">=</span> <span class="mi">1830213987675567884451892843232991595746198390911664175679946063194531096037459873211879206428207</span>
<span class="n">q</span> <span class="o">=</span> <span class="mi">1830213987675567884451892843232991595746198390911664175679946063194531096037459873211879206428213</span>

<span class="n">N</span> <span class="o">=</span> <span class="mi">3349683240683303752040100187123245076775802838668125325785318315004398778586538866210198083573169673444543518654385038484177110828274648967185831623610409867689938609495858551308025785883804091</span>
<span class="n">e</span> <span class="o">=</span> <span class="mi">65537</span>
<span class="n">c</span> <span class="o">=</span> <span class="mi">87760575554266991015431110922576261532159376718765701749513766666239189012106797683148334771446801021047078003121816710825033894805743112580942399985961509685534309879621205633997976721084983</span>

<span class="n">d</span> <span class="o">=</span> <span class="n">invert</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>

<span class="n">pt</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">N</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">pt</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]).</span><span class="n">decode</span><span class="p">())</span>
</code></pre></div></div>

<h3 id="flagooo_la_la_those_are_sexy_primes">flag{ooo_la_la_those_are_sexy_primes}</h3>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="nahamcon" /><category term="2020" /><category term="cryptography" /><category term="RSA" /><category term="alpertron" /><category term="ECM" /><summary type="html"><![CDATA[Ooo-la-la We are provided prompt.txt, the contents of which read N = 3349683240683303752040100187123245076775802838668125325785318315004398778586538866210198083573169673444543518654385038484177110828274648967185831623610409867689938609495858551308025785883804091 e = 65537 c = 87760575554266991015431110922576261532159376718765701749513766666239189012106797683148334771446801021047078003121816710825033894805743112580942399985961509685534309879621205633997976721084983 Seems like usual RSA, lets see if we can factor N over alpetron Which almost instantly factors the N using Elliptic Curve Method Knowing the factors or phi, rest of the job is easy from gmpy2 import invert p = 1830213987675567884451892843232991595746198390911664175679946063194531096037459873211879206428207 q = 1830213987675567884451892843232991595746198390911664175679946063194531096037459873211879206428213 N = 3349683240683303752040100187123245076775802838668125325785318315004398778586538866210198083573169673444543518654385038484177110828274648967185831623610409867689938609495858551308025785883804091 e = 65537 c = 87760575554266991015431110922576261532159376718765701749513766666239189012106797683148334771446801021047078003121816710825033894805743112580942399985961509685534309879621205633997976721084983 d = invert(e, (p-1)*(q-1)) pt = pow(c,d,N) print(bytes.fromhex(hex(pt)[2:]).decode()) flag{ooo_la_la_those_are_sexy_primes}]]></summary></entry><entry><title type="html">Nahamcon 2020 Crypto - Raspberry</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/Raspberry/2020-06-14-Nahamcon-2020-Raspberry" rel="alternate" type="text/html" title="Nahamcon 2020 Crypto - Raspberry" /><published>2020-06-14T00:00:00+05:30</published><updated>2020-06-14T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/Raspberry/Nahamcon-2020-Raspberry</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/Raspberry/2020-06-14-Nahamcon-2020-Raspberry"><![CDATA[<h1 id="raspberry">Raspberry</h1>

<p><img src="Capture.PNG" alt="" /></p>

<p>We are provided with <a href="prompt.txt">prompt.txt</a>, the contents of which read</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>n = 7735208939848985079680614633581782274371148157293352904905313315409418467322726702848189532721490121708517697848255948254656192793679424796954743649810878292688507385952920229483776389922650388739975072587660866986603080986980359219525111589659191172937047869008331982383695605801970189336227832715706317
e = 65537
c = 5300731709583714451062905238531972160518525080858095184581839366680022995297863013911612079520115435945472004626222058696229239285358638047675780769773922795279074074633888720787195549544835291528116093909456225670152733191556650639553906195856979794273349598903501654956482056938935258794217285615471681
</code></pre></div></div>

<p>Lets again head to <a href="https://www.alpertron.com.ar/ECM.HTM">alpetron</a>, suspecting there may be a lot of small prime factors</p>

<p><img src="alpetron.PNG" alt="" /></p>

<p>Which almost instantly factors the <code class="language-plaintext highlighter-rouge">N</code> using <a href="https://en.wikipedia.org/wiki/Lenstra_elliptic-curve_factorization">Elliptic Curve Method</a> indicating my suspicion was true.</p>

<p>Now we have a lot of prime factors, one may simply grab the Eulerâ€™s Totient, I however prefer working over primes to demonstrate how its calculated</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">gmpy2</span> <span class="kn">import</span> <span class="n">invert</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">prod</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">7735208939848985079680614633581782274371148157293352904905313315409418467322726702848189532721490121708517697848255948254656192793679424796954743649810878292688507385952920229483776389922650388739975072587660866986603080986980359219525111589659191172937047869008331982383695605801970189336227832715706317</span>
<span class="n">e</span> <span class="o">=</span> <span class="mi">65537</span>
<span class="n">c</span> <span class="o">=</span> <span class="mi">5300731709583714451062905238531972160518525080858095184581839366680022995297863013911612079520115435945472004626222058696229239285358638047675780769773922795279074074633888720787195549544835291528116093909456225670152733191556650639553906195856979794273349598903501654956482056938935258794217285615471681</span>

<span class="n">factors</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2208664111</span><span class="p">,</span><span class="mi">2214452749</span><span class="p">,</span><span class="mi">2259012491</span><span class="p">,</span><span class="mi">2265830453</span><span class="p">,</span><span class="mi">2372942981</span><span class="p">,</span><span class="mi">2393757139</span><span class="p">,</span><span class="mi">2465499073</span><span class="p">,</span><span class="mi">2508863309</span><span class="p">,</span><span class="mi">2543358889</span><span class="p">,</span><span class="mi">2589229021</span><span class="p">,</span><span class="mi">2642723827</span><span class="p">,</span><span class="mi">2758626487</span><span class="p">,</span><span class="mi">2850808189</span><span class="p">,</span><span class="mi">2947867051</span><span class="p">,</span><span class="mi">2982067987</span><span class="p">,</span><span class="mi">3130932919</span><span class="p">,</span><span class="mi">3290718047</span><span class="p">,</span><span class="mi">3510442297</span><span class="p">,</span><span class="mi">3600488797</span><span class="p">,</span><span class="mi">3644712913</span><span class="p">,</span><span class="mi">3650456981</span><span class="p">,</span><span class="mi">3726115171</span><span class="p">,</span><span class="mi">3750978137</span><span class="p">,</span><span class="mi">3789130951</span><span class="p">,</span><span class="mi">3810149963</span><span class="p">,</span><span class="mi">3979951739</span><span class="p">,</span><span class="mi">4033877203</span><span class="p">,</span><span class="mi">4128271747</span><span class="p">,</span><span class="mi">4162800959</span><span class="p">,</span><span class="mi">4205130337</span><span class="p">,</span><span class="mi">4221911101</span><span class="p">,</span><span class="mi">4268160257</span><span class="p">]</span>

<span class="n">phi</span> <span class="o">=</span> <span class="n">prod</span><span class="p">(</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">factors</span><span class="p">)</span> <span class="c1"># cool new function in python3.8 ;)
# just take the product of prime - 1 for all primes to calculate phi
# since no prime is repeated
</span><span class="n">d</span> <span class="o">=</span> <span class="n">invert</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">phi</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">d</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">m</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]).</span><span class="n">decode</span><span class="p">())</span>
</code></pre></div></div>

<p>If you got stuck over the challenge, I would suggest reading <a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function">wikipedia</a> for more information.</p>
<h3 id="flagthere_are_a_few_extra_berries_in_this_one">flag{there_are_a_few_extra_berries_in_this_one}</h3>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="nahamcon" /><category term="2020" /><category term="cryptography" /><category term="RSA" /><category term="alpertron" /><category term="small_factors" /><category term="ECM" /><summary type="html"><![CDATA[Raspberry We are provided with prompt.txt, the contents of which read n = 7735208939848985079680614633581782274371148157293352904905313315409418467322726702848189532721490121708517697848255948254656192793679424796954743649810878292688507385952920229483776389922650388739975072587660866986603080986980359219525111589659191172937047869008331982383695605801970189336227832715706317 e = 65537 c = 5300731709583714451062905238531972160518525080858095184581839366680022995297863013911612079520115435945472004626222058696229239285358638047675780769773922795279074074633888720787195549544835291528116093909456225670152733191556650639553906195856979794273349598903501654956482056938935258794217285615471681 Lets again head to alpetron, suspecting there may be a lot of small prime factors Which almost instantly factors the N using Elliptic Curve Method indicating my suspicion was true. Now we have a lot of prime factors, one may simply grab the Eulerâ€™s Totient, I however prefer working over primes to demonstrate how its calculated from gmpy2 import invert from math import prod n = 7735208939848985079680614633581782274371148157293352904905313315409418467322726702848189532721490121708517697848255948254656192793679424796954743649810878292688507385952920229483776389922650388739975072587660866986603080986980359219525111589659191172937047869008331982383695605801970189336227832715706317 e = 65537 c = 5300731709583714451062905238531972160518525080858095184581839366680022995297863013911612079520115435945472004626222058696229239285358638047675780769773922795279074074633888720787195549544835291528116093909456225670152733191556650639553906195856979794273349598903501654956482056938935258794217285615471681 factors = [2208664111,2214452749,2259012491,2265830453,2372942981,2393757139,2465499073,2508863309,2543358889,2589229021,2642723827,2758626487,2850808189,2947867051,2982067987,3130932919,3290718047,3510442297,3600488797,3644712913,3650456981,3726115171,3750978137,3789130951,3810149963,3979951739,4033877203,4128271747,4162800959,4205130337,4221911101,4268160257] phi = prod(i-1 for i in factors) # cool new function in python3.8 ;) # just take the product of prime - 1 for all primes to calculate phi # since no prime is repeated d = invert(e,phi) m = pow(c,d,n) print(bytes.fromhex(hex(m)[2:]).decode()) If you got stuck over the challenge, I would suggest reading wikipedia for more information. flag{there_are_a_few_extra_berries_in_this_one}]]></summary></entry><entry><title type="html">Nahamcon 2020 Crypto - Twinning</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/Twinning/2020-06-14-Nahamcon-2020-twinning" rel="alternate" type="text/html" title="Nahamcon 2020 Crypto - Twinning" /><published>2020-06-14T00:00:00+05:30</published><updated>2020-06-14T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/Twinning/Nahamcon-2020-twinning</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/Twinning/2020-06-14-Nahamcon-2020-twinning"><![CDATA[<h1 id="twinning">Twinning</h1>

<p><img src="Capture.PNG" alt="" /></p>

<p>The name of the challenge is a subtle hint towards <a href="https://en.wikipedia.org/wiki/Twin_prime">Twin primes</a>, i.e. the RSA primes <code class="language-plaintext highlighter-rouge">p</code> and <code class="language-plaintext highlighter-rouge">q</code> being twin primes, at a difference of two.</p>

<p>How does that help?<br />
We can now easily factor <code class="language-plaintext highlighter-rouge">n</code> since we have another relation, namely</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>q = p + 2 and  
p*q = N  
q^2 - q*p = N
( q - 1 )^2 = N + 1
q = sqrt( N + 1 ) + 1
p = sqrt( N + 1 ) - 1  
</code></pre></div></div>

<p>One can easily solve a quadratic equation to find <code class="language-plaintext highlighter-rouge">p</code><br />
Once <code class="language-plaintext highlighter-rouge">p</code> and <code class="language-plaintext highlighter-rouge">q</code> are found, rest is a piece of cake</p>

<p>Although the time was not a concern, I still wrote a small script</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="n">remote</span>
<span class="kn">import</span> <span class="nn">gmpy2</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s">"jh2i.com"</span><span class="p">,</span> <span class="mi">50013</span>
<span class="n">REM</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">REM</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">'What is the PIN?'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">decode</span><span class="p">())</span>
<span class="n">e_n</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="sa">b</span><span class="s">'(\d+),(\d+)'</span><span class="p">,</span><span class="n">data</span><span class="p">)</span>
<span class="n">e</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">e_n</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">e_n</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="n">PIN</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="sa">b</span><span class="s">'is (\d+)'</span><span class="p">,</span><span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">factor</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">e</span><span class="p">):</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">gmpy2</span><span class="p">.</span><span class="n">iroot</span><span class="p">(</span><span class="n">n</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">gmpy2</span><span class="p">.</span><span class="n">invert</span><span class="p">(</span><span class="n">e</span><span class="p">,</span><span class="n">phi</span><span class="p">)</span> <span class="c1"># returns d
</span>
<span class="n">DECRYPTED_PIN</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">PIN</span><span class="p">,</span> <span class="n">factor</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="n">e</span><span class="p">),</span> <span class="n">n</span><span class="p">)</span>
<span class="n">REM</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">DECRYPTED_PIN</span><span class="p">).</span><span class="n">encode</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">REM</span><span class="p">.</span><span class="n">recvline</span><span class="p">().</span><span class="n">decode</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">REM</span><span class="p">.</span><span class="n">recvline</span><span class="p">().</span><span class="n">decode</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">REM</span><span class="p">.</span><span class="n">recvline</span><span class="p">().</span><span class="n">decode</span><span class="p">())</span>
</code></pre></div></div>

<h3 id="flagthats_the_twinning_pin_to_win">flag{thats_the_twinning_pin_to_win}</h3>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="nahamcon" /><category term="2020" /><category term="netcat" /><category term="twin_prime" /><category term="RSA" /><summary type="html"><![CDATA[Twinning The name of the challenge is a subtle hint towards Twin primes, i.e. the RSA primes p and q being twin primes, at a difference of two. How does that help? We can now easily factor n since we have another relation, namely q = p + 2 and p*q = N q^2 - q*p = N ( q - 1 )^2 = N + 1 q = sqrt( N + 1 ) + 1 p = sqrt( N + 1 ) - 1 One can easily solve a quadratic equation to find p Once p and q are found, rest is a piece of cake Although the time was not a concern, I still wrote a small script from pwn import remote import gmpy2 import re HOST, PORT = "jh2i.com", 50013 REM = remote(HOST, PORT) data = REM.recvuntil(b'What is the PIN?') print(data.decode()) e_n = re.search(b'(\d+),(\d+)',data) e = int(e_n[1]) n = int(e_n[2]) PIN = int(re.search(b'is (\d+)',data)[1]) def factor(n,e): a = gmpy2.iroot(n+1,2)[0] phi = (a-2)*(a) return gmpy2.invert(e,phi) # returns d DECRYPTED_PIN = pow(PIN, factor(n,e), n) REM.sendline(str(DECRYPTED_PIN).encode()) print(REM.recvline().decode()) print(REM.recvline().decode()) print(REM.recvline().decode()) flag{thats_the_twinning_pin_to_win}]]></summary></entry><entry><title type="html">Nahamcon 2020 Crypto - Unvreakable Vase</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/Unvreakable%20Vase/2020-06-14-Nahamcon-2020-Unvreakable-Vase" rel="alternate" type="text/html" title="Nahamcon 2020 Crypto - Unvreakable Vase" /><published>2020-06-14T00:00:00+05:30</published><updated>2020-06-14T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/Unvreakable%20Vase/Nahamcon-2020-Unvreakable-Vase</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/Unvreakable%20Vase/2020-06-14-Nahamcon-2020-Unvreakable-Vase"><![CDATA[<h1 id="unvreakable-vase">Unvreakable Vase</h1>

<p><img src="Capture.PNG" alt="" /></p>

<p>We are provided with <a href="prompt.txt">prompt.txt</a>, which reads</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>zmxhz3tkb2vzx3roaxnfzxzlbl9jb3vudf9hc19jcnlwdg9vb30=
</code></pre></div></div>
<p>This seems to be base64 encoded but I think all the letters are converted to lowercase as hinted by <code class="language-plaintext highlighter-rouge">squished and flat</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">base64</span>
<span class="n">data</span> <span class="o">=</span> <span class="s">'zmxhz3tkb2vzx3roaxnfzxzlbl9jb3vudf9hc19jcnlwdg9vb30='</span>
<span class="n">m1</span> <span class="o">=</span> <span class="n">base64</span><span class="p">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>

<span class="c1">#b'\xcela\xcf{dok\xf3\xc7z\xe8k\x19\xdf\xcf\x1c\xe5n_co{\xeeu\xffas_crypv\x0foo}'
</span></code></pre></div></div>
<p>Lets try captilizing the first â€˜zâ€™</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">base64</span>
<span class="n">data</span> <span class="o">=</span> <span class="s">'zmxhz3tkb2vzx3roaxnfzxzlbl9jb3vudf9hc19jcnlwdg9vb30='</span>
<span class="n">m1</span> <span class="o">=</span> <span class="n">base64</span><span class="p">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span>

<span class="c1">#b'fla\xcf{dok\xf3\xc7z\xe8k\x19\xdf\xcf\x1c\xe5n_co{\xeeu\xffas_crypv\x0foo}'
</span></code></pre></div></div>
<p>Seems to be it, now our flag begins with <code class="language-plaintext highlighter-rouge">fla</code>.<br />
All we need to do is keep capitalizing the letters of <code class="language-plaintext highlighter-rouge">data</code> such that base64 decoding results in a ASCII string which is readable.</p>

<p>One can do this by hand. NOT ME :stuck_out_tongue:</p>

<p>To automate this shit, lets take a look at how base64 actually works.<br />
In base64, we have 64 possible characters, which means each base64 letter can hold 6 bits.<br />
Which in turn means 4 base64 characters = 24 bits = 3 bytes<br />
So instead of taking all 52 characters of <code class="language-plaintext highlighter-rouge">prompt</code> together and then checking <code class="language-plaintext highlighter-rouge">2**52</code> possibilities, we can simply take 4 characters at a time, and thenn checking <code class="language-plaintext highlighter-rouge">2**4</code> possibilites for output in the desired character set.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">base64</span> <span class="kn">import</span> <span class="n">b64decode</span> <span class="k">as</span> <span class="n">decode</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>

<span class="n">data</span> <span class="o">=</span> <span class="s">'zmxhz3tkb2vzx3roaxnfzxzlbl9jb3vudf9hc19jcnlwdg9vb30='</span>
<span class="n">CHARSET</span> <span class="o">=</span> <span class="s">'abcdefghijklmnopqrstuvwxyz_{}'</span>


<span class="k">def</span> <span class="nf">case_variations</span><span class="p">(</span><span class="n">string</span><span class="p">):</span>
    <span class="n">possibilities</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">string</span><span class="p">:</span>
        <span class="n">possibilities</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">char</span><span class="p">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">char</span><span class="p">.</span><span class="n">upper</span><span class="p">()])</span>
    <span class="k">return</span> <span class="p">[</span><span class="s">""</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">perm</span><span class="p">)</span> <span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">possibilities</span><span class="p">)]</span>


<span class="n">flag</span> <span class="o">=</span> <span class="sa">b</span><span class="s">""</span>
<span class="n">real_data</span> <span class="o">=</span> <span class="s">""</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">4</span><span class="p">):</span>
    <span class="n">crib</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">case_variation</span> <span class="ow">in</span> <span class="n">case_variations</span><span class="p">(</span><span class="n">crib</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">char</span><span class="p">)</span> <span class="ow">in</span> <span class="n">CHARSET</span> <span class="k">for</span> <span class="n">char</span> <span class="ow">in</span> <span class="n">decode</span><span class="p">(</span><span class="n">case_variation</span><span class="p">)):</span>
            <span class="n">real_data</span> <span class="o">+=</span> <span class="n">case_variation</span>
            <span class="n">flag</span> <span class="o">+=</span> <span class="n">decode</span><span class="p">(</span><span class="n">case_variation</span><span class="p">)</span>
            <span class="k">print</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
            <span class="k">break</span>

<span class="k">print</span><span class="p">(</span><span class="n">real_data</span><span class="p">)</span>
</code></pre></div></div>
<p>Which prints out stuff</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sa">b</span><span class="s">'fla'</span>
<span class="sa">b</span><span class="s">'flag{d'</span>
<span class="sa">b</span><span class="s">'flag{does'</span>
<span class="sa">b</span><span class="s">'flag{does_th'</span>
<span class="sa">b</span><span class="s">'flag{does_this_'</span>
<span class="sa">b</span><span class="s">'flag{does_this_eve'</span>
<span class="sa">b</span><span class="s">'flag{does_this_even_c'</span>
<span class="sa">b</span><span class="s">'flag{does_this_even_coun'</span>
<span class="sa">b</span><span class="s">'flag{does_this_even_count_a'</span>
<span class="sa">b</span><span class="s">'flag{does_this_even_count_as_c'</span>
<span class="sa">b</span><span class="s">'flag{does_this_even_count_as_cryp'</span>
<span class="sa">b</span><span class="s">'flag{does_this_even_count_as_cryptoo'</span>
<span class="sa">b</span><span class="s">'flag{does_this_even_count_as_cryptooo}'</span>
<span class="n">ZmxhZ3tkb2VzX3RoaXNfZXZlbl9jb3VudF9hc19jcnlwdG9vb30</span><span class="o">=</span>
</code></pre></div></div>

<p>And our original base64 encoded string was <code class="language-plaintext highlighter-rouge">'ZmxhZ3tkb2VzX3RoaXNfZXZlbl9jb3VudF9hc19jcnlwdG9vb30='</code></p>
<h3 id="flagdoes_this_even_count_as_cryptooo">flag{does_this_even_count_as_cryptooo}</h3>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="nahamcon" /><category term="2020" /><category term="cryptography" /><category term="base64" /><summary type="html"><![CDATA[Unvreakable Vase We are provided with prompt.txt, which reads zmxhz3tkb2vzx3roaxnfzxzlbl9jb3vudf9hc19jcnlwdg9vb30= This seems to be base64 encoded but I think all the letters are converted to lowercase as hinted by squished and flat import base64 data = 'zmxhz3tkb2vzx3roaxnfzxzlbl9jb3vudf9hc19jcnlwdg9vb30=' m1 = base64.b64decode(data) print(m1) #b'\xcela\xcf{dok\xf3\xc7z\xe8k\x19\xdf\xcf\x1c\xe5n_co{\xeeu\xffas_crypv\x0foo}' Lets try captilizing the first â€˜zâ€™ import base64 data = 'zmxhz3tkb2vzx3roaxnfzxzlbl9jb3vudf9hc19jcnlwdg9vb30=' m1 = base64.b64decode(data) print(m1) #b'fla\xcf{dok\xf3\xc7z\xe8k\x19\xdf\xcf\x1c\xe5n_co{\xeeu\xffas_crypv\x0foo}' Seems to be it, now our flag begins with fla. All we need to do is keep capitalizing the letters of data such that base64 decoding results in a ASCII string which is readable. One can do this by hand. NOT ME :stuck_out_tongue: To automate this shit, lets take a look at how base64 actually works. In base64, we have 64 possible characters, which means each base64 letter can hold 6 bits. Which in turn means 4 base64 characters = 24 bits = 3 bytes So instead of taking all 52 characters of prompt together and then checking 2**52 possibilities, we can simply take 4 characters at a time, and thenn checking 2**4 possibilites for output in the desired character set. from base64 import b64decode as decode from itertools import product data = 'zmxhz3tkb2vzx3roaxnfzxzlbl9jb3vudf9hc19jcnlwdg9vb30=' CHARSET = 'abcdefghijklmnopqrstuvwxyz_{}' def case_variations(string): possibilities = [] for char in string: possibilities.append([char.lower(), char.upper()]) return ["".join(perm) for perm in product(*possibilities)] flag = b"" real_data = "" for i in range(0, len(data), 4): crib = data[i:i + 4] for case_variation in case_variations(crib): if all(chr(char) in CHARSET for char in decode(case_variation)): real_data += case_variation flag += decode(case_variation) print(flag) break print(real_data) Which prints out stuff b'fla' b'flag{d' b'flag{does' b'flag{does_th' b'flag{does_this_' b'flag{does_this_eve' b'flag{does_this_even_c' b'flag{does_this_even_coun' b'flag{does_this_even_count_a' b'flag{does_this_even_count_as_c' b'flag{does_this_even_count_as_cryp' b'flag{does_this_even_count_as_cryptoo' b'flag{does_this_even_count_as_cryptooo}' ZmxhZ3tkb2VzX3RoaXNfZXZlbl9jb3VudF9hc19jcnlwdG9vb30= And our original base64 encoded string was 'ZmxhZ3tkb2VzX3RoaXNfZXZlbl9jb3VudF9hc19jcnlwdG9vb30=' flag{does_this_even_count_as_cryptooo}]]></summary></entry><entry><title type="html">Nahamcon 2020 Crypto - elsa4</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/elsa4/2020-06-14-Nahamcon-2020-elsa4" rel="alternate" type="text/html" title="Nahamcon 2020 Crypto - elsa4" /><published>2020-06-14T00:00:00+05:30</published><updated>2020-06-14T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/elsa4/Nahamcon-2020-elsa4</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/elsa4/2020-06-14-Nahamcon-2020-elsa4"><![CDATA[<h1 id="elsa4">Elsa4</h1>

<p><img src="Capture.PNG" alt="" /></p>

<p>Apparently, its an instance of <a href="https://github.com/dstein64/LC4/blob/master/documentation.md">LC4</a> cipher.<br />
We are provided with a subtle hint <code class="language-plaintext highlighter-rouge">Frozen in time</code> which could mean <code class="language-plaintext highlighter-rouge">random</code> is seeded with the present time, confirmed by the fact that time is provided at the start of the challenge.</p>

<p>Now, all we need to figure out is the length of nonce, however it is implemented.</p>

<p>I also wrote <code class="language-plaintext highlighter-rouge">encrypt</code>, <code class="language-plaintext highlighter-rouge">decryption_challenge</code>, <code class="language-plaintext highlighter-rouge">send_decryption</code> utilities, which would encrypt a given message from server, ask for a decryption challenge and send the decryption of given decryption challenge respectively to the server.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="n">remote</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">lc4</span>
<span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s">"jh2i.com"</span><span class="p">,</span> <span class="mi">50014</span>

<span class="n">REM</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>
<span class="n">initial_data</span> <span class="o">=</span> <span class="n">REM</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">'&gt;'</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">initial_data</span><span class="p">.</span><span class="n">decode</span><span class="p">())</span>


<span class="k">def</span> <span class="nf">get_timestamp</span><span class="p">():</span>
    <span class="n">hms</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="sa">rb</span><span class="s">'(\d{2}):(\d{2}):(\d{2})'</span><span class="p">,</span> <span class="n">initial_data</span><span class="p">)</span>
    <span class="n">ymd</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="sa">rb</span><span class="s">'(\d{4})\/(\d{2})\/(\d{2})'</span><span class="p">,</span> <span class="n">initial_data</span><span class="p">)</span>
    <span class="n">h</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">hms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">hms</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">hms</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">y</span><span class="p">,</span> <span class="n">mn</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ymd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ymd</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">ymd</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">((</span><span class="n">y</span><span class="p">,</span> <span class="n">mn</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">s</span><span class="p">)))</span>


<span class="n">timestamp</span> <span class="o">=</span> <span class="n">datetime</span><span class="p">.</span><span class="n">datetime</span><span class="p">(</span><span class="o">*</span><span class="n">get_timestamp</span><span class="p">()).</span><span class="n">timestamp</span><span class="p">()</span>
<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">timestamp</span><span class="p">))</span>

<span class="n">nonce_length</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># some big number
</span><span class="n">alphabet</span> <span class="o">=</span> <span class="s">"#_23456789abcdefghijklmnopqrstuvwxyz"</span>
<span class="n">nonce_chars</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nonce_length</span><span class="p">):</span>
    <span class="n">nonce_chars</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">sample</span><span class="p">(</span><span class="n">alphabet</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">plaintext</span><span class="p">):</span>
    <span class="n">REM</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="sa">b</span><span class="s">'1'</span><span class="p">)</span>
    <span class="n">REM</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">plaintext</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">REM</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">'&gt;'</span><span class="p">)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span>
        <span class="sa">b</span><span class="s">'Key = ([#_23456789abcdefghijklmnopqrstuvwxyz]+)'</span><span class="p">,</span>
        <span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">encrypted</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span>
        <span class="sa">b</span><span class="s">'Encrypted = ([#_23456789abcdefghijklmnopqrstuvwxyz]+)'</span><span class="p">,</span>
        <span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="n">encrypted</span>


<span class="k">def</span> <span class="nf">decryption_challenge</span><span class="p">():</span>
    <span class="n">REM</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="sa">b</span><span class="s">'2'</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">REM</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">'Decrypted ='</span><span class="p">)</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span>
        <span class="sa">b</span><span class="s">'Key = ([#_23456789abcdefghijklmnopqrstuvwxyz]+)'</span><span class="p">,</span>
        <span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">encrypted</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span>
        <span class="sa">b</span><span class="s">'Encrypted = ([#_23456789abcdefghijklmnopqrstuvwxyz]+)'</span><span class="p">,</span>
        <span class="n">data</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">key</span><span class="p">,</span> <span class="n">encrypted</span>


<span class="k">def</span> <span class="nf">send_decryption</span><span class="p">(</span><span class="n">dec</span><span class="p">):</span>
    <span class="n">REM</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="n">dec</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">REM</span><span class="p">.</span><span class="n">recvuntil</span><span class="p">(</span><span class="sa">b</span><span class="s">'&gt;'</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">decode</span><span class="p">())</span>
</code></pre></div></div>

<p>The only concern I am left with is <strong>HOW IS THE NONCE USED!!?</strong><br />
To be honest, I am fed up of all the <a href="https://en.wikipedia.org/wiki/Snake_oil_(cryptography)">snake oil</a> in ctf challenges.<br />
Take the challenge, give out the source, make it challenging :smile:</p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="nahamcon" /><category term="2020" /><category term="cryptography" /><category term="netcat" /><category term="LC4" /><summary type="html"><![CDATA[Elsa4 Apparently, its an instance of LC4 cipher. We are provided with a subtle hint Frozen in time which could mean random is seeded with the present time, confirmed by the fact that time is provided at the start of the challenge. Now, all we need to figure out is the length of nonce, however it is implemented. I also wrote encrypt, decryption_challenge, send_decryption utilities, which would encrypt a given message from server, ask for a decryption challenge and send the decryption of given decryption challenge respectively to the server. from pwn import remote import re import datetime import random import lc4 HOST, PORT = "jh2i.com", 50014 REM = remote(HOST, PORT) initial_data = REM.recvuntil(b'&gt;') print(initial_data.decode()) def get_timestamp(): hms = re.search(rb'(\d{2}):(\d{2}):(\d{2})', initial_data) ymd = re.search(rb'(\d{4})\/(\d{2})\/(\d{2})', initial_data) h, m, s = hms[1], hms[2], hms[3] y, mn, d = ymd[1], ymd[2], ymd[3] return map(int, tuple((y, mn, d, h, m, s))) timestamp = datetime.datetime(*get_timestamp()).timestamp() random.seed(int(timestamp)) nonce_length = 100 # some big number alphabet = "#_23456789abcdefghijklmnopqrstuvwxyz" nonce_chars = [] for _ in range(nonce_length): nonce_chars.extend(random.sample(alphabet, 1)) def encrypt(plaintext): REM.sendline(b'1') REM.sendline(plaintext) data = REM.recvuntil(b'&gt;') key = re.search( b'Key = ([#_23456789abcdefghijklmnopqrstuvwxyz]+)', data)[1] encrypted = re.search( b'Encrypted = ([#_23456789abcdefghijklmnopqrstuvwxyz]+)', data)[1] return key, encrypted def decryption_challenge(): REM.sendline(b'2') data = REM.recvuntil(b'Decrypted =') key = re.search( b'Key = ([#_23456789abcdefghijklmnopqrstuvwxyz]+)', data)[1] encrypted = re.search( b'Encrypted = ([#_23456789abcdefghijklmnopqrstuvwxyz]+)', data)[1] return key, encrypted def send_decryption(dec): REM.sendline(dec) data = REM.recvuntil(b'&gt;') print(data.decode()) The only concern I am left with is HOW IS THE NONCE USED!!? To be honest, I am fed up of all the snake oil in ctf challenges. Take the challenge, give out the source, make it challenging :smile:]]></summary></entry><entry><title type="html">BATPWN 2020 Crypto - Cryptographer</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/batpwn/crypto/Cryptographer/2020-06-08-BATPWN-2020-Cryptographer" rel="alternate" type="text/html" title="BATPWN 2020 Crypto - Cryptographer" /><published>2020-06-08T00:00:00+05:30</published><updated>2020-06-08T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/batpwn/crypto/Cryptographer/BATPWN-2020-Cryptographer</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/batpwn/crypto/Cryptographer/2020-06-08-BATPWN-2020-Cryptographer"><![CDATA[<h1 id="cryptographer">Cryptographer</h1>

<p><img src="Capture.PNG" alt="" /></p>

<p>We are provided with <a href="noob.txt">noob.txt</a> which has it contents:-</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>U1FEQEdeS1JDSEBEXlZDUEFYSG5ZQ29TVVBFRFlXRFxvUUJFTA==
</code></pre></div></div>
<p>and <a href="noob.py">noob.py</a> which contents read</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python2
# I AM NOOB :)
</span><span class="kn">import</span> <span class="nn">string</span>
<span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">md5</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">izip</span><span class="p">,</span> <span class="n">cycle</span>
<span class="kn">import</span> <span class="nn">base64</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">xor</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="nb">bytearray</span><span class="p">,</span> <span class="p">[</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="p">])))</span>

<span class="n">flag</span><span class="o">=</span><span class="s">""</span>

<span class="n">timestamp</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">print</span> <span class="nb">int</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>
<span class="n">key</span> <span class="o">=</span> <span class="n">md5</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">timestamp</span><span class="p">))).</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="n">my_hexdata</span> <span class="o">=</span> <span class="n">key</span>

<span class="n">scale</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">num_of_bits</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">noobda</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">my_hexdata</span><span class="p">,</span> <span class="n">scale</span><span class="p">))[</span><span class="mi">2</span><span class="p">:].</span><span class="n">zfill</span><span class="p">(</span><span class="n">num_of_bits</span><span class="p">)</span>
<span class="k">print</span> <span class="n">noobda</span>
<span class="n">xorer</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span><span class="n">noobda</span><span class="p">)</span>
<span class="n">noobie</span> <span class="o">=</span> <span class="n">base64</span><span class="p">.</span><span class="n">encodestring</span><span class="p">(</span><span class="n">xorer</span><span class="p">).</span><span class="n">strip</span><span class="p">()</span>
<span class="k">print</span> <span class="n">noobie</span>
</code></pre></div></div>
<p>Hmm, python2 :disappointed: and quite a wierd script.</p>

<p>Without using much of my small brain, I churned up a script quickly
thinking I can bruteforce starting from current time backwards.</p>

<p>But it was actually xoring the flag with two values <code class="language-plaintext highlighter-rouge">b'0' or b'1'</code>, So there are a very little number of possiblities to try.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">base64</span>
<span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">md5</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">xor</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="nb">bytearray</span><span class="p">,</span> <span class="p">[</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="p">])))</span>

<span class="n">timestamp_initial</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">())</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'noob.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">ct_file</span><span class="p">:</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="n">ct_file</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">strip</span><span class="p">()</span>

<span class="n">ct</span> <span class="o">=</span> <span class="n">base64</span><span class="p">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">):</span>
    <span class="n">timestamp</span> <span class="o">=</span> <span class="n">timestamp_initial</span> <span class="o">-</span> <span class="n">i</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">md5</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">timestamp</span><span class="p">))).</span><span class="n">hexdigest</span><span class="p">()</span>
    <span class="n">my_hexdata</span> <span class="o">=</span> <span class="n">key</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="mi">16</span>
    <span class="n">num_of_bits</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">noobda</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">my_hexdata</span><span class="p">,</span> <span class="n">scale</span><span class="p">))[</span><span class="mi">2</span><span class="p">:].</span><span class="n">zfill</span><span class="p">(</span><span class="n">num_of_bits</span><span class="p">)</span>
    <span class="n">xorer</span> <span class="o">=</span> <span class="n">xor</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">noobda</span><span class="p">)</span>
    <span class="k">if</span> <span class="s">'batpwn{'</span> <span class="ow">in</span> <span class="n">xorer</span> <span class="ow">and</span> <span class="s">'}'</span> <span class="ow">in</span> <span class="n">xorer</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">xorer</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>batpwn{bsxptogr`qhy^is_cd`uuigtl^ast}
batpwn{crxpunfs`phx_ir^bd`uthgum_art}
batpwn{crypuogr`qhx^is_ceatuifum^aru}
batpwn{bsxquogs`phy^hr^ceauthgul_asu}
batpwn{csypungrapix_hs_cd`tuigtl^asu}
batpwn{csxqtnfr`qix^hs^bdauthgtl^`st}
batpwn{bsyqtnfs`qix^hr_bd`uthfum^ast}
batpwn{brxquogr`qiy_hs_ceatuigtm^`st}
batpwn{bsxqtogr`qhy_hs_cdatuhgtm^aru}
batpwn{csyqungsaphx_is_cdauuhftm^`rt}
batpwn{brxqungr`qix^hr_ceauthful_aru}
batpwn{csyqtngr`phy^is_cd`tuhfum_aru}
batpwn{brxquograqix_hs^bdautigtm_`rt}
batpwn{bsxqtofsaqiy^hr_ceauuhftl_`ru}
batpwn{csxqtofsaqhy^hs^beatuhgum_ast}
batpwn{brxqunfsaqhy_is_cd`uuifum^`rt}
batpwn{brxqunfsaphx_hr_be`ttiftl_asu}
batpwn{cryqunfsaqiy_hr^ceautiful^`rt}
batpwn{brxqtngr`pix^ir_ce`utigul_`ru}
batpwn{csyqunfsaqhx^is_cdauuiftm^ast}
batpwn{bryptnfsaqhx^hr_beautigtm_asu}
batpwn{crxpuofr`phx_hr_cdautigul_aru}
batpwn{crxqungs`qhy^hr_ce`tuiful_ast}
batpwn{bryqungs`qhx_is_cd`tuhgtl_aru}
batpwn{bryqtnfr`qiy_ir_bd`tuigtl_aru}
batpwn{csxptofr`qiy^is^bdatuhgtl^`st}
batpwn{bsypunfrapix_hr^bd`uthgum_`st}
batpwn{bryptngs`qhy^hr_cdauthgtm_aru}
batpwn{csypunfsaphx_is_be`uuhgul^ast}
batpwn{csyqtogr`qhx^hr^cd`utigtm_`st}
batpwn{bsxqtofr`qiy^hs^ce`uthfum^`rt}
batpwn{csyqtofsaqix_hs_be`uthftl_`st}
batpwn{crxpunfrapiy^hr^beauthgtm_ast}
batpwn{brxptogsapix^ir_be`uthgum^aru}
batpwn{bsxptngs`qix^hr_ceatuiftl_aru}
batpwn{bsyqtogsaqhy^ir_cd`uuhful_`st}
batpwn{csxqtngs`qhx^is_cdauthgum_aru}
batpwn{brxqtograpiy^ir_ce`ttiftm_`su}
batpwn{bryptofr`qix_ir^cdatthgum_`ru}
</code></pre></div></div>
<p>HAHAHA, without using much brain, one could tell that flag is 
<code class="language-plaintext highlighter-rouge">batpwn{cryptography_is_beautiful_art}</code></p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="2020" /><category term="BATPWN" /><category term="cryptography" /><category term="xor" /><category term="timeseed" /><category term="Bsides" /><summary type="html"><![CDATA[Cryptographer We are provided with noob.txt which has it contents:- U1FEQEdeS1JDSEBEXlZDUEFYSG5ZQ29TVVBFRFlXRFxvUUJFTA== and noob.py which contents read #!/usr/bin/env python2 # I AM NOOB :) import string from hashlib import md5 from itertools import izip, cycle import base64 import time def xor(data, key): return bytearray(a^b for a, b in zip(*map(bytearray, [data, key]))) flag="" timestamp = time.time() print int(timestamp) key = md5(str(int(timestamp))).hexdigest() my_hexdata = key scale = 16 num_of_bits = 8 noobda = bin(int(my_hexdata, scale))[2:].zfill(num_of_bits) print noobda xorer(flag,noobda) noobie = base64.encodestring(xorer).strip() print noobie Hmm, python2 :disappointed: and quite a wierd script. Without using much of my small brain, I churned up a script quickly thinking I can bruteforce starting from current time backwards. But it was actually xoring the flag with two values b'0' or b'1', So there are a very little number of possiblities to try. import base64 from hashlib import md5 import time def xor(data, key): return bytearray(a^b for a, b in zip(*map(bytearray, [data, key]))) timestamp_initial = int(time.time()) with open('noob.txt', 'r') as ct_file: ct = ct_file.read().strip() ct = base64.b64decode(ct) for i in range(1000000): timestamp = timestamp_initial - i key = md5(str(int(timestamp))).hexdigest() my_hexdata = key scale = 16 num_of_bits = 8 noobda = bin(int(my_hexdata, scale))[2:].zfill(num_of_bits) xorer = xor(ct, noobda) if 'batpwn{' in xorer and '}' in xorer: print(xorer) batpwn{bsxptogr`qhy^is_cd`uuigtl^ast} batpwn{crxpunfs`phx_ir^bd`uthgum_art} batpwn{crypuogr`qhx^is_ceatuifum^aru} batpwn{bsxquogs`phy^hr^ceauthgul_asu} batpwn{csypungrapix_hs_cd`tuigtl^asu} batpwn{csxqtnfr`qix^hs^bdauthgtl^`st} batpwn{bsyqtnfs`qix^hr_bd`uthfum^ast} batpwn{brxquogr`qiy_hs_ceatuigtm^`st} batpwn{bsxqtogr`qhy_hs_cdatuhgtm^aru} batpwn{csyqungsaphx_is_cdauuhftm^`rt} batpwn{brxqungr`qix^hr_ceauthful_aru} batpwn{csyqtngr`phy^is_cd`tuhfum_aru} batpwn{brxquograqix_hs^bdautigtm_`rt} batpwn{bsxqtofsaqiy^hr_ceauuhftl_`ru} batpwn{csxqtofsaqhy^hs^beatuhgum_ast} batpwn{brxqunfsaqhy_is_cd`uuifum^`rt} batpwn{brxqunfsaphx_hr_be`ttiftl_asu} batpwn{cryqunfsaqiy_hr^ceautiful^`rt} batpwn{brxqtngr`pix^ir_ce`utigul_`ru} batpwn{csyqunfsaqhx^is_cdauuiftm^ast} batpwn{bryptnfsaqhx^hr_beautigtm_asu} batpwn{crxpuofr`phx_hr_cdautigul_aru} batpwn{crxqungs`qhy^hr_ce`tuiful_ast} batpwn{bryqungs`qhx_is_cd`tuhgtl_aru} batpwn{bryqtnfr`qiy_ir_bd`tuigtl_aru} batpwn{csxptofr`qiy^is^bdatuhgtl^`st} batpwn{bsypunfrapix_hr^bd`uthgum_`st} batpwn{bryptngs`qhy^hr_cdauthgtm_aru} batpwn{csypunfsaphx_is_be`uuhgul^ast} batpwn{csyqtogr`qhx^hr^cd`utigtm_`st} batpwn{bsxqtofr`qiy^hs^ce`uthfum^`rt} batpwn{csyqtofsaqix_hs_be`uthftl_`st} batpwn{crxpunfrapiy^hr^beauthgtm_ast} batpwn{brxptogsapix^ir_be`uthgum^aru} batpwn{bsxptngs`qix^hr_ceatuiftl_aru} batpwn{bsyqtogsaqhy^ir_cd`uuhful_`st} batpwn{csxqtngs`qhx^is_cdauthgum_aru} batpwn{brxqtograpiy^ir_ce`ttiftm_`su} batpwn{bryptofr`qix_ir^cdatthgum_`ru} HAHAHA, without using much brain, one could tell that flag is batpwn{cryptography_is_beautiful_art}]]></summary></entry></feed>