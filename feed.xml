<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://deut-erium.github.io/WriteUps/WriteUps/feed.xml" rel="self" type="application/atom+xml" /><link href="https://deut-erium.github.io/WriteUps/WriteUps/" rel="alternate" type="text/html" hreflang="en" /><updated>2022-05-19T18:43:14+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/feed.xml</id><title type="html">CTF Writeups</title><subtitle></subtitle><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><entry><title type="html">SDCTF 2022 Crypto - Tasty Crypto Roll</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2022/sdctf/crypto/tasty_crypto_roll/2022-05-10-SDCTF-2022-Tasty-Crypto-Roll" rel="alternate" type="text/html" title="SDCTF 2022 Crypto - Tasty Crypto Roll" /><published>2022-05-10T00:00:00+05:30</published><updated>2022-05-10T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2022/sdctf/crypto/tasty_crypto_roll/SDCTF-2022-Tasty-Crypto-Roll</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2022/sdctf/crypto/tasty_crypto_roll/2022-05-10-SDCTF-2022-Tasty-Crypto-Roll"><![CDATA[<h1 id="tasty-crypto-roll">Tasty Crypto Roll</h1>
<h2 id="description">Description</h2>
<p>CRYPTO - Hard <br />
Tasty Crypto Roll<br />
Bob, the genius intern at our company, invented AES-improved. It is based on AES but with layers after layers of proprietary encryption techniques on top of it.</p>

<p>The end result is an encryption scheme that achieves both confusion and diffusion. The more layers of crypto you add, the better the security, right?</p>

<p>Encrypter<br />
<a href="encrypt.py">encrypt.py</a><br />
Encrypted file<br />
<a href="enc.bin">enc.bin</a><br />
Note<br />
The intended solution requires very little brute force and runs under 5 seconds on our machine.<br />
By k3v1n</p>

<h2 id="source">Source</h2>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">secrets</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">Crypto.Cipher</span> <span class="kn">import</span> <span class="n">AES</span>

<span class="n">ENCODING</span> <span class="o">=</span> <span class="s">'utf-8'</span>

<span class="k">def</span> <span class="nf">generate_key</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">secrets</span><span class="p">.</span><span class="n">token_bytes</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">to_binary</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">'{:08b}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">from_binary</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">8</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">8</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="n">cipher</span> <span class="o">=</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cipher</span><span class="p">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="n">key1</span><span class="p">,</span> <span class="n">key2</span> <span class="o">=</span> <span class="n">generate_key</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Using Key:</span><span class="se">\n</span><span class="si">{</span><span class="n">key1</span><span class="si">}</span><span class="s">:</span><span class="si">{</span><span class="n">key2</span><span class="p">.</span><span class="nb">hex</span><span class="p">()</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_flag</span><span class="p">():</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">'Enter the flag to encrypt: '</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'sdctf{'</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">'}'</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">.</span><span class="n">isascii</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">flag</span><span class="si">}</span><span class="s"> is not a valid flag for this challenge'</span><span class="p">)</span>
        <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flag</span>

<span class="n">plaintext</span> <span class="o">=</span> <span class="n">get_flag</span><span class="p">()[</span><span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">plaintext</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">ENCODING</span><span class="p">)</span>

<span class="n">codes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0x1b0</span><span class="p">)))</span>
<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sboxes</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Bad key, try again"</span><span class="p">)</span>
    <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">sboxes</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">data</span><span class="p">).</span><span class="n">encode</span><span class="p">(</span><span class="n">ENCODING</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key2</span><span class="p">,</span> <span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">).</span><span class="n">encode</span><span class="p">(</span><span class="n">ENCODING</span><span class="p">))</span>

<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>

<span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits</span><span class="p">))</span>

<span class="n">ciphertext</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Encrypted: </span><span class="si">{</span><span class="n">ciphertext</span><span class="p">.</span><span class="nb">hex</span><span class="p">()</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'enc.bin2'</span><span class="p">,</span> <span class="s">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">ef</span><span class="p">:</span>
    <span class="n">ef</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="analysis">Analysis</h2>
<p>Here we can see mainly two parts</p>
<ol>
  <li>There are two keys
    <ul>
      <li><code class="language-plaintext highlighter-rouge">key1</code>: pid of current process</li>
      <li><code class="language-plaintext highlighter-rouge">key2</code>: secure random key of 16 bytes</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">key1</code> is used as seed at a lot of places and is bruteforcable (&lt; 2^15)
<code class="language-plaintext highlighter-rouge">key_final</code> and <code class="language-plaintext highlighter-rouge">sboxes</code> are derived from <code class="language-plaintext highlighter-rouge">key1</code>, shuffling is done using <code class="language-plaintext highlighter-rouge">key1</code></li>
</ol>

<h3 id="steps-to-crack">Steps to crack</h3>
<ol>
  <li>decrypt using <code class="language-plaintext highlighter-rouge">key_final</code></li>
  <li>convert the intermediate ciphertext <code class="language-plaintext highlighter-rouge">to_binary</code></li>
  <li>de-shuffle the bits</li>
  <li>generate <code class="language-plaintext highlighter-rouge">from_binary</code> intermediate ciphertext of the deshuffled bits</li>
  <li>decrypt using <code class="language-plaintext highlighter-rouge">key2</code>???</li>
</ol>

<h3 id="how-to-find-key1">How to find <code class="language-plaintext highlighter-rouge">key1</code>?</h3>
<p>Assume you have the correct <code class="language-plaintext highlighter-rouge">key1</code>, reverse for the key, validate the results <br />
using some validator/logical assumption.</p>

<p><code class="language-plaintext highlighter-rouge">codes</code> is a list of <code class="language-plaintext highlighter-rouge">2*(0x1b0-0xb0)</code> = <code class="language-plaintext highlighter-rouge">512</code> characters, utf-8 encoding of
which is 2-bytes each <br />
<code class="language-plaintext highlighter-rouge">sboxes</code> will have 4char strings, which encode to 8 bytes each on utf-8 (i.e
        after substitution)<br />
<code class="language-plaintext highlighter-rouge">data</code> is now <code class="language-plaintext highlighter-rouge">4*2 = 8</code> times each byte of the original plaintext<br />
<code class="language-plaintext highlighter-rouge">data</code> is converted <code class="language-plaintext highlighter-rouge">to_binary</code> before encryption hence each byte is converted<br />
to 8 <code class="language-plaintext highlighter-rouge">b"0"</code> or <code class="language-plaintext highlighter-rouge">b"1"</code> byte. Hence each character is substituted to some<br />
<code class="language-plaintext highlighter-rouge">8*8 = 64</code> byte string before encryption.<br />
Hence len of flag = <code class="language-plaintext highlighter-rouge">len(ciphertext)//64</code> = <code class="language-plaintext highlighter-rouge">3520//64 = 55</code> bytes</p>

<h4 id="assumption-1">Assumption 1</h4>
<p>Since length of flag is 55 characters, would it be reasonable to assume that<br />
there would be repeatitions of characters. And since each flag character is<br />
substituted to fixed 64-byte strings before encryption which is a multiple<br />
of AES block size of 16, AES also acts like simple substitution of the flag<br />
but we do not know the mapping.<br />
Hence if we reverse till step 4 above, we can simply check if there are any<br />
repeating 64-byte blocks, as incorrect shuffling of bits will result in each 
block to be distinct with almost 1 probability.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'enc.bin'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">ciphertext</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">to_binary</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">'{:08b}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">from_binary</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">8</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">8</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">encrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">decrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">unshuffle</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">):</span>
        <span class="n">res</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">def</span> <span class="nf">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">data_bits_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data_bits_uns</span> <span class="o">=</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">,</span> <span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits_uns</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">data</span>
</code></pre></div></div>

<p>Lets add a few validation too</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">key_final_enc</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_unshuffle</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="mi">1337</span><span class="p">))</span>
    <span class="n">random_text_shuffled</span> <span class="o">=</span> <span class="n">random_text</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">shuffle_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">random_text</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1337</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1337</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">)</span> <span class="o">==</span> <span class="n">random_text</span>

<span class="k">def</span> <span class="nf">test_key_final_dec</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="mi">1337</span><span class="p">,</span> <span class="n">key_final_enc</span><span class="p">(</span><span class="mi">1337</span><span class="p">,</span> <span class="n">random_text</span><span class="p">))</span> <span class="o">==</span> <span class="n">random_text</span>

<span class="n">test_unshuffle</span><span class="p">()</span>
<span class="n">test_key_final_dec</span><span class="p">()</span>
</code></pre></div></div>
<p>Looks like all the decryption functions are correct, lets proceed with<br />
bruteforcing for <code class="language-plaintext highlighter-rouge">key1</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">),</span><span class="n">desc</span><span class="o">=</span><span class="s">'solving for key1'</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">substitutions</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">64</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">64</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substitutions</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">64</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"pid ="</span><span class="p">,</span><span class="n">key1</span><span class="p">)</span>
        <span class="k">break</span>
</code></pre></div></div>
<p>After waiting for an eternity, and exhausting the search space of possible pid’s<br />
yet not getting any <code class="language-plaintext highlighter-rouge">key1</code> got me confused. I checked my script locally for a <br />
test flag it seemed to work fine. There could only be one possibility <br />
<strong>the flag contains 55 distinct characters</strong><br />
But how would I find <code class="language-plaintext highlighter-rouge">key1</code> now?</p>

<h4 id="missed-catch">Missed Catch</h4>
<p>@Utaha#6878 pointed out, that since there are only 256 distinct values in
<code class="language-plaintext highlighter-rouge">codes</code> each repeated twice, and each character encoded to some <code class="language-plaintext highlighter-rouge">b"0"</code> or <code class="language-plaintext highlighter-rouge">b"1"</code><br />
byte strings of length 16, It must be encrypted to the same block always.<br />
Since the flag is <code class="language-plaintext highlighter-rouge">55*4 = 220</code> such 16-byte codes and each code is used twice<br />
for most of the characters, there will be repating 16-byte blocks even with <br />
distinct flag characters.</p>

<h4 id="assumption-2">Assumption 2</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">),</span><span class="n">desc</span><span class="o">=</span><span class="s">'solving for key1'</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">substitutions</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">16</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">16</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substitutions</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">16</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"pid ="</span><span class="p">,</span><span class="n">key1</span><span class="p">)</span>
        <span class="k">break</span>
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">pid = 83</code></p>
</blockquote>

<p>And we found our <code class="language-plaintext highlighter-rouge">key1</code>!<br />
And we can confirm that the flag is indeed 55 distinct characters.</p>

<p>Wait, if the flag is 55 distinct characters, how will we solve for the subs?<br />
We have no statistical advantage and hence bye bye Mr 
<a href="https://quipqiup.com/">quipquip</a></p>

<h3 id="how-do-we-find-mapping-for-substitution">How do we find mapping for substitution?</h3>
<p>Each <code class="language-plaintext highlighter-rouge">sbox</code> entry is composed of 4 2-byte strings, which can be one of 256<br />
possible values. Moreover, their order is fixed, which is determined by <code class="language-plaintext highlighter-rouge">key1</code>.</p>

<p>If we try to solve for all valid mappings for <code class="language-plaintext highlighter-rouge">AES(binary(sbox(char)))</code> we will
probably end up on the correct mapping and get our flag.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+---------------+---------------+------------------------+---------------+
|flag0          |    flag1      |                        |   flag55      |
+---------------+---------------+         ....           +---------------+
|  sbox         |   sbox        |                        |    sbox       |
+---+---+---+---+---+---+---+---+------------------------+---------------+
|c1 |c2 |c3 |c4 |c5 |c6 |c7 |c8 |                        |               |
|   |   |   |   |   |   |   |   |                        |               |
+---+---+---+---+---+---+---+---+         ....           +---------------+
|   AES         |    AES        |                        |               |
+---+---+-------+---------------+------------------------+---------------+
|   |   +------+                                                          
|   +--+       |                                                          
+------+-------+-------+------+                                           
|E(c1) | E(c2) | E(c3) | E(c4)|                                             
+------+-------+-------+------+   
</code></pre></div></div>

<h3 id="enter-z3">Enter Z3</h3>
<p>We can assume our flag to be a list of <code class="language-plaintext highlighter-rouge">BitVec</code> of 7 bits each<br />
And let the sboxes be a mapping from 7 bits to 64 bits each (16x4)<br />
This can be achieved by assuming sbox to be an array which is indexed<br />
by <code class="language-plaintext highlighter-rouge">BitVec(7)</code> and contains elements of <code class="language-plaintext highlighter-rouge">BitVec(64)</code><br />
And we assume AES to be some function form <code class="language-plaintext highlighter-rouge">BitVec(16)</code> to <code class="language-plaintext highlighter-rouge">BitVec(128)</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">flag</span> <span class="o">=</span> <span class="p">[</span><span class="n">BitVec</span><span class="p">(</span><span class="s">'flag_'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="mi">7</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">64</span><span class="p">)]</span>
<span class="n">sboxmap</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s">'sbox'</span><span class="p">,</span><span class="n">BitVecSort</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
<span class="n">aes_encryption</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">'AES'</span><span class="p">,</span><span class="n">BitVecSort</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">codes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0x1b0</span><span class="p">)))</span>
<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="c1"># keeping sboxes utf encoded already
</span><span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">]).</span><span class="n">encode</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>

<span class="n">sbytes</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">sboxes</span><span class="p">)</span>
<span class="n">sboxints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">'big'</span><span class="p">),</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">sbytes</span><span class="p">),</span><span class="mi">2</span><span class="p">))))</span>
<span class="c1"># integer values for 2-byte codes from sbox, will be explained shortly
</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="s">'big'</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxes</span><span class="p">]</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
<span class="c1"># converting intermediate decryption to 128 bit ints
</span><span class="n">data_int</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">16</span><span class="p">):</span>
    <span class="n">data_int</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">16</span><span class="p">],</span><span class="s">'big'</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># we know the sbox already
</span><span class="n">constraints</span> <span class="o">=</span> <span class="p">[</span><span class="n">sboxmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">sboxes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">64</span><span class="p">):</span>
    <span class="n">four_code</span> <span class="o">=</span> <span class="n">sboxmap</span><span class="p">[</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="c1"># splitting 64 bit quantity to 16 bit individual sbox codes
</span>    <span class="n">four_code_parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Extract</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="o">*</span><span class="n">i</span><span class="p">,</span><span class="n">four_code</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="c1"># for each code, matching aes_encryption with the observed value
</span>    <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data_int</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">:</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span> <span class="n">four_code_parts</span><span class="p">):</span>
        <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">==</span><span class="n">a</span><span class="p">)</span>
    <span class="c1"># last but not least, aes_encryption(i) is unique for each plaintext
</span>    <span class="c1"># how would z3 know? Distinct function encodes them appropriately to
</span>    <span class="c1"># be distinct
</span>    <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Distinct</span><span class="p">([</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxints</span><span class="p">]))</span>

<span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">solver</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">all_smt</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
    <span class="c1"># lets check for all satisfying flags (in case there are more than one
</span>    <span class="c1"># possible mappings and we will rule out invalid ones in that scenario?
</span>    <span class="n">flag_bytes</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]).</span><span class="n">as_long</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flag</span><span class="p">))])</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">64</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">64</span><span class="p">)))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">)</span> 
</code></pre></div></div>

<h2 id="flag">Flag</h2>
<p>After running the script, we finally get our flag!</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">b'r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU'</code></p>
</blockquote>

<p>And it turns out to be the only satisfying assignment.<br />
Turns out if there were repeated characters in the flag, we will get multiple<br />
possible satisfying values. So the admins have not been so cheeky afterall</p>

<h2 id="full-script">Full <a href="solve.py">script</a></h2>
<p>Note that it takes a couple of seconds to find the z3 model</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">Crypto.Cipher</span> <span class="kn">import</span> <span class="n">AES</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">z3</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="k">def</span> <span class="nf">all_smt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">initial_terms</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">block_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">fix_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">all_smt_rec</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sat</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">check</span><span class="p">():</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">model</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">m</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)):</span>
                <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">()</span>
                <span class="n">block_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">terms</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">fix_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">terms</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">yield</span> <span class="k">from</span> <span class="n">all_smt_rec</span><span class="p">(</span><span class="n">terms</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
                <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">yield</span> <span class="k">from</span> <span class="n">all_smt_rec</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">initial_terms</span><span class="p">))</span>


<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'enc.bin'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">ciphertext</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">to_binary</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">'{:08b}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">from_binary</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">8</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">encrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">decrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">key_final_enc</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">unshuffle</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">):</span>
        <span class="n">res</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">test_unshuffle</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span>
    <span class="n">random_text_shuffled</span> <span class="o">=</span> <span class="n">random_text</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">shuffle_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">random_text</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">)</span> <span class="o">==</span> <span class="n">random_text</span>


<span class="n">test_unshuffle</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">data_bits_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data_bits_uns</span> <span class="o">=</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">,</span> <span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits_uns</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">test_key_final_dec</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">key_final_enc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_text</span><span class="p">))</span> <span class="o">==</span> <span class="n">random_text</span>


<span class="n">test_key_final_dec</span><span class="p">()</span>

<span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s">'solving for key1'</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">substitutions</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">16</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substitutions</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="mi">16</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"pid ="</span><span class="p">,</span> <span class="n">key1</span><span class="p">)</span>
        <span class="k">break</span>

<span class="n">codes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0x1b0</span><span class="p">)))</span>
<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">]).</span><span class="n">encode</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>
<span class="n">sbytes</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">sboxes</span><span class="p">)</span>
<span class="n">sboxints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">'big'</span><span class="p">),</span> <span class="nb">set</span><span class="p">(</span>
    <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sbytes</span><span class="p">),</span> <span class="mi">2</span><span class="p">))))</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">'big'</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxes</span><span class="p">]</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
<span class="n">data_int</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">16</span><span class="p">):</span>
    <span class="n">data_int</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="s">'big'</span><span class="p">))</span>

<span class="n">flag</span> <span class="o">=</span> <span class="p">[</span><span class="n">BitVec</span><span class="p">(</span><span class="s">'flag_'</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">7</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="mi">64</span><span class="p">)]</span>
<span class="n">sboxmap</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s">'sbox'</span><span class="p">,</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
<span class="n">aes_encryption</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">'AES'</span><span class="p">,</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span>

<span class="n">constraints</span> <span class="o">=</span> <span class="p">[</span><span class="n">sboxmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">sboxes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="mi">64</span><span class="p">):</span>
    <span class="n">four_code</span> <span class="o">=</span> <span class="n">sboxmap</span><span class="p">[</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="n">four_code_parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Extract</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="n">four_code</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data_int</span><span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span><span class="p">:</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">],</span> <span class="n">four_code_parts</span><span class="p">):</span>
        <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Distinct</span><span class="p">([</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxints</span><span class="p">]))</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">solver</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
<span class="c1"># if solver.check() == sat:
# m = solver.model()
</span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">all_smt</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
    <span class="n">flag_bytes</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]).</span><span class="n">as_long</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flag</span><span class="p">))])</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
        <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">64</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">64</span><span class="p">)))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"failed to solve"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="alternate-solution-by-teammate-utaha6878">Alternate Solution by teammate (Utaha#6878)</h3>

<p>All due regards to him for solving the challenge while I was stuck over finding<br />
<code class="language-plaintext highlighter-rouge">key1</code> XD</p>

<p>All parts will be almost same except the substitution solving part, which he<br />
did by manual bruteforcing i.e. recursively enumerating all mappings and
backtracking on contradictions</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">codes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">)],</span> <span class="n">start</span><span class="o">=</span><span class="p">[])</span> 
<span class="c1"># notice that the range is changed from [0xb0, 0x1b0) to [0, 256). 
# It's just for relabeling.
</span><span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
	<span class="s">"""
	equate two objects elementwise ignoring if the entry is -1
	"""</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>

<span class="n">answers</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">getFlag</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">):</span> 
<span class="c1"># get the flag based on current mapping, unknown char will be shown as '?'
</span>    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cip</span><span class="p">:</span>
        <span class="n">afterMap</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span>
        <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sboxes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">afterMap</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s">'?'</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">brute</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">):</span>
    <span class="s">"""
    cip and sboxes remain unchanged throughout the recursive call, 
    but I feel bad using global varaibles.
    """</span>
    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">getFlag</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">))</span>

    <span class="c1"># check is finished
</span>    <span class="n">isFinished</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cip</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">mp</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">isFinished</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="n">isFinished</span><span class="p">:</span>
        <span class="n">answers</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">getFlag</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Found an answer!!!!!!!"</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># try matching
</span>    <span class="n">isContradiction</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Find the one with least possible matches.
</span>    <span class="n">min_pos</span> <span class="o">=</span> <span class="mi">256</span>
    <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cip</span><span class="p">):</span>
        <span class="n">afterMap</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span>
        <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">afterMap</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sboxes</span> <span class="k">if</span> <span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">afterMap</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">isContradiction</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">min_pos</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="n">min_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">isContradiction</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># now bruteforce all possibilities
</span>    <span class="k">assert</span> <span class="n">index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">afterMap</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cip</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sboxes</span> <span class="k">if</span> <span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">afterMap</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cip</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">mp</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">brute</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">)</span>

<span class="c1"># This is based on the repetition
</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">132</span><span class="p">,</span> <span class="mi">197</span><span class="p">]:</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="p">{</span><span class="mi">35</span><span class="p">:</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">109</span><span class="p">:</span> <span class="mi">144</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="n">_</span><span class="p">}</span>
    <span class="n">brute</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Answers:"</span><span class="p">)</span>
<span class="n">answers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">answers</span><span class="p">))</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">answers</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">b</span><span class="s">"sdctf{"</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"}"</span><span class="p">)</span>

<span class="c1"># The fourth one is the actual answer
</span></code></pre></div></div>

<blockquote>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ciphertext repetition:
[4, 5, 4, 6]
[34, 35, 36, 35]
[109, 60, 110, 109]
Sbox repetition:
[132, 93, 132, 211]
[197, 32, 197, 248]
[144, 86, 67, 144]
[165, 224, 27, 224]
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Answers:
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}'
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}'
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}'
</code></pre></div>  </div>
</blockquote>

<p>full script in <a href="./solve2.py">solve2.py</a></p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="SDCTF" /><category term="2022" /><category term="cryptography" /><category term="AES" /><category term="z3" /><category term="substitution" /><category term="permutation" /><summary type="html"><![CDATA[Tasty Crypto Roll Description CRYPTO - Hard Tasty Crypto Roll Bob, the genius intern at our company, invented AES-improved. It is based on AES but with layers after layers of proprietary encryption techniques on top of it. The end result is an encryption scheme that achieves both confusion and diffusion. The more layers of crypto you add, the better the security, right? Encrypter encrypt.py Encrypted file enc.bin Note The intended solution requires very little brute force and runs under 5 seconds on our machine. By k3v1n Source import os import random import secrets import sys from Crypto.Cipher import AES ENCODING = 'utf-8' def generate_key(): return os.getpid(), secrets.token_bytes(16) def to_binary(b: bytes): return ''.join(['{:08b}'.format(c) for c in b]) def from_binary(s: str): return bytes(int(s[i:i+8], 2) for i in range(0, len(s), 8)) def encrypt(key: bytes, message: bytes): cipher = AES.new(key, AES.MODE_ECB) return cipher.encrypt(message) key1, key2 = generate_key() print(f'Using Key:\n{key1}:{key2.hex()}') def get_flag(): flag = input('Enter the flag to encrypt: ') if not flag.startswith('sdctf{') or not flag.endswith('}') or not flag.isascii(): print(f'{flag} is not a valid flag for this challenge') sys.exit(1) return flag plaintext = get_flag()[6:-1] data = plaintext.encode(ENCODING) codes = list(''.join(chr(i) * 2 for i in range(0xb0, 0x1b0))) random.seed(key1) random.shuffle(codes) sboxes = [''.join(codes[i*4:(i+1)*4]) for i in range(128)] if len(set(sboxes)) &lt; 128: print("Bad key, try again") sys.exit(1) data = ''.join(sboxes[c] for c in data).encode(ENCODING) data = encrypt(key2, to_binary(data).encode(ENCODING)) random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data_bits = list(to_binary(data)) random.shuffle(data_bits) data = from_binary(''.join(data_bits)) ciphertext = encrypt(key_final, data) print(f'Encrypted: {ciphertext.hex()}') with open('enc.bin2', 'wb') as ef: ef.write(ciphertext) Analysis Here we can see mainly two parts There are two keys key1: pid of current process key2: secure random key of 16 bytes key1 is used as seed at a lot of places and is bruteforcable (&lt; 2^15) key_final and sboxes are derived from key1, shuffling is done using key1 Steps to crack decrypt using key_final convert the intermediate ciphertext to_binary de-shuffle the bits generate from_binary intermediate ciphertext of the deshuffled bits decrypt using key2??? How to find key1? Assume you have the correct key1, reverse for the key, validate the results using some validator/logical assumption. codes is a list of 2*(0x1b0-0xb0) = 512 characters, utf-8 encoding of which is 2-bytes each sboxes will have 4char strings, which encode to 8 bytes each on utf-8 (i.e after substitution) data is now 4*2 = 8 times each byte of the original plaintext data is converted to_binary before encryption hence each byte is converted to 8 b"0" or b"1" byte. Hence each character is substituted to some 8*8 = 64 byte string before encryption. Hence len of flag = len(ciphertext)//64 = 3520//64 = 55 bytes Assumption 1 Since length of flag is 55 characters, would it be reasonable to assume that there would be repeatitions of characters. And since each flag character is substituted to fixed 64-byte strings before encryption which is a multiple of AES block size of 16, AES also acts like simple substitution of the flag but we do not know the mapping. Hence if we reverse till step 4 above, we can simply check if there are any repeating 64-byte blocks, as incorrect shuffling of bits will result in each block to be distinct with almost 1 probability. with open('enc.bin', 'rb') as f: ciphertext = f.read() def to_binary(b: bytes): return ''.join(['{:08b}'.format(c) for c in b]) def from_binary(s: str): return bytes(int(s[i:i+8], 2) for i in range(0, len(s), 8)) def encrypt(key, message): return AES.new(key, AES.MODE_ECB).encrypt(message) def decrypt(key: bytes, message: bytes): return AES.new(key, AES.MODE_ECB).decrypt(message) def unshuffle(data_list, shuffle_order): res = [None]*len(data_list) for i,v in enumerate(shuffle_order): res[v] = data_list[i] return res def key_final_dec(key1, ciphertext): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data = decrypt(key_final, ciphertext) data_bits = list(to_binary(data)) data_bits_order = list(range(len(data_bits))) random.shuffle(data_bits_order) data_bits_uns = unshuffle(data_bits, data_bits_order) data = from_binary(''.join(data_bits_uns)) return data Lets add a few validation too def key_final_enc(key1, data): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data_bits = list(to_binary(data)) random.shuffle(data_bits) data = from_binary(''.join(data_bits)) return encrypt(key_final, data) def test_unshuffle(): random_text = list(random.randbytes(16*1337)) random_text_shuffled = random_text.copy() shuffle_order = list(range(len(random_text))) random.seed(1337) random.shuffle(random_text_shuffled) random.seed(1337) random.shuffle(shuffle_order) assert unshuffle(random_text_shuffled, shuffle_order) == random_text def test_key_final_dec(): random_text = random.randbytes(16*100) assert key_final_dec(1337, key_final_enc(1337, random_text)) == random_text test_unshuffle() test_key_final_dec() Looks like all the decryption functions are correct, lets proceed with bruteforcing for key1 for key1 in tqdm(range(2**15),desc='solving for key1'): data = key_final_dec(key1, ciphertext) substitutions = Counter(data[i:i+64] for i in range(0,len(data),64)) if len(substitutions)!=len(data)//64: print("pid =",key1) break After waiting for an eternity, and exhausting the search space of possible pid’s yet not getting any key1 got me confused. I checked my script locally for a test flag it seemed to work fine. There could only be one possibility the flag contains 55 distinct characters But how would I find key1 now? Missed Catch @Utaha#6878 pointed out, that since there are only 256 distinct values in codes each repeated twice, and each character encoded to some b"0" or b"1" byte strings of length 16, It must be encrypted to the same block always. Since the flag is 55*4 = 220 such 16-byte codes and each code is used twice for most of the characters, there will be repating 16-byte blocks even with distinct flag characters. Assumption 2 for key1 in tqdm(range(2**15),desc='solving for key1'): data = key_final_dec(key1, ciphertext) substitutions = Counter(data[i:i+16] for i in range(0,len(data),16)) if len(substitutions)!=len(data)//16: print("pid =",key1) break pid = 83 And we found our key1! And we can confirm that the flag is indeed 55 distinct characters. Wait, if the flag is 55 distinct characters, how will we solve for the subs? We have no statistical advantage and hence bye bye Mr quipquip How do we find mapping for substitution? Each sbox entry is composed of 4 2-byte strings, which can be one of 256 possible values. Moreover, their order is fixed, which is determined by key1. If we try to solve for all valid mappings for AES(binary(sbox(char))) we will probably end up on the correct mapping and get our flag. +---------------+---------------+------------------------+---------------+ |flag0 | flag1 | | flag55 | +---------------+---------------+ .... +---------------+ | sbox | sbox | | sbox | +---+---+---+---+---+---+---+---+------------------------+---------------+ |c1 |c2 |c3 |c4 |c5 |c6 |c7 |c8 | | | | | | | | | | | | | | +---+---+---+---+---+---+---+---+ .... +---------------+ | AES | AES | | | +---+---+-------+---------------+------------------------+---------------+ | | +------+ | +--+ | +------+-------+-------+------+ |E(c1) | E(c2) | E(c3) | E(c4)| +------+-------+-------+------+ Enter Z3 We can assume our flag to be a list of BitVec of 7 bits each And let the sboxes be a mapping from 7 bits to 64 bits each (16x4) This can be achieved by assuming sbox to be an array which is indexed by BitVec(7) and contains elements of BitVec(64) And we assume AES to be some function form BitVec(16) to BitVec(128) flag = [BitVec('flag_'+str(i),7) for i in range(len(data)//64)] sboxmap = Array('sbox',BitVecSort(7), BitVecSort(64)) aes_encryption = Function('AES',BitVecSort(16), BitVecSort(128)) codes = list(''.join(chr(i) * 2 for i in range(0xb0, 0x1b0))) random.seed(key1) random.shuffle(codes) # keeping sboxes utf encoded already sboxes = [''.join(codes[i*4:(i+1)*4]).encode() for i in range(128)] sbytes = b''.join(sboxes) sboxints = list(map(lambda x:int.from_bytes(x,'big'), set(sbytes[i:i+2] for i in range(0,len(sbytes),2)))) # integer values for 2-byte codes from sbox, will be explained shortly sboxes = [int.from_bytes(i,'big') for i in sboxes] data = key_final_dec(key1, ciphertext) # converting intermediate decryption to 128 bit ints data_int = [] for i in range(0,len(data),16): data_int.append(int.from_bytes(data[i:i+16],'big')) # we know the sbox already constraints = [sboxmap[i]==sboxes[i] for i in range(128)] for i in range(len(data)//64): four_code = sboxmap[flag[i]] # splitting 64 bit quantity to 16 bit individual sbox codes four_code_parts = [Extract(16*i+15,16*i,four_code) for i in range(3,-1,-1)] # for each code, matching aes_encryption with the observed value for a,b in zip(data_int[4*i:4*i+4], four_code_parts): constraints.append(aes_encryption(b)==a) # last but not least, aes_encryption(i) is unique for each plaintext # how would z3 know? Distinct function encodes them appropriately to # be distinct constraints.append(Distinct([aes_encryption(i) for i in sboxints])) solver = Solver() solver.add(constraints) for m in all_smt(solver, flag): # lets check for all satisfying flags (in case there are more than one # possible mappings and we will rule out invalid ones in that scenario? flag_bytes = bytes([m.eval(flag[i]).as_long() for i in range(len(flag))]) assert len(set(flag_bytes)) == len(Counter(data[i:i+64] for i in range(0,len(data),64))) print(flag_bytes) Flag After running the script, we finally get our flag! b'r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU' And it turns out to be the only satisfying assignment. Turns out if there were repeated characters in the flag, we will get multiple possible satisfying values. So the admins have not been so cheeky afterall Full script Note that it takes a couple of seconds to find the z3 model import random from Crypto.Cipher import AES from collections import Counter from tqdm import tqdm from z3 import * import sys def all_smt(s, initial_terms): def block_term(s, m, t): s.add(t != m.eval(t)) def fix_term(s, m, t): s.add(t == m.eval(t)) def all_smt_rec(terms): if sat == s.check(): m = s.model() yield m for i in range(len(terms)): s.push() block_term(s, m, terms[i]) for j in range(i): fix_term(s, m, terms[j]) yield from all_smt_rec(terms[i:]) s.pop() yield from all_smt_rec(list(initial_terms)) with open('enc.bin', 'rb') as f: ciphertext = f.read() def to_binary(b: bytes): return ''.join(['{:08b}'.format(c) for c in b]) def from_binary(s: str): return bytes(int(s[i:i + 8], 2) for i in range(0, len(s), 8)) def encrypt(key, message): return AES.new(key, AES.MODE_ECB).encrypt(message) def decrypt(key: bytes, message: bytes): return AES.new(key, AES.MODE_ECB).decrypt(message) def key_final_enc(key1, data): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data_bits = list(to_binary(data)) random.shuffle(data_bits) data = from_binary(''.join(data_bits)) return encrypt(key_final, data) def unshuffle(data_list, shuffle_order): res = [None] * len(data_list) for i, v in enumerate(shuffle_order): res[v] = data_list[i] return res def test_unshuffle(): random_text = list(random.randbytes(16 * 100)) random_text_shuffled = random_text.copy() shuffle_order = list(range(len(random_text))) random.seed(10) random.shuffle(random_text_shuffled) random.seed(10) random.shuffle(shuffle_order) assert unshuffle(random_text_shuffled, shuffle_order) == random_text test_unshuffle() def key_final_dec(key1, ciphertext): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data = decrypt(key_final, ciphertext) data_bits = list(to_binary(data)) data_bits_order = list(range(len(data_bits))) random.shuffle(data_bits_order) data_bits_uns = unshuffle(data_bits, data_bits_order) data = from_binary(''.join(data_bits_uns)) return data def test_key_final_dec(): random_text = random.randbytes(16 * 100) assert key_final_dec(10, key_final_enc(10, random_text)) == random_text test_key_final_dec() for key1 in tqdm(range(2**15), desc='solving for key1'): data = key_final_dec(key1, ciphertext) substitutions = Counter(data[i:i + 16] for i in range(0, len(data), 16)) if len(substitutions) != len(data) // 16: print("pid =", key1) break codes = list(''.join(chr(i) * 2 for i in range(0xb0, 0x1b0))) random.seed(key1) random.shuffle(codes) sboxes = [''.join(codes[i * 4:(i + 1) * 4]).encode() for i in range(128)] sbytes = b''.join(sboxes) sboxints = list(map(lambda x: int.from_bytes(x, 'big'), set( sbytes[i:i + 2] for i in range(0, len(sbytes), 2)))) sboxes = [int.from_bytes(i, 'big') for i in sboxes] data = key_final_dec(key1, ciphertext) data_int = [] for i in range(0, len(data), 16): data_int.append(int.from_bytes(data[i:i + 16], 'big')) flag = [BitVec('flag_' + str(i), 7) for i in range(len(data) // 64)] sboxmap = Array('sbox', BitVecSort(7), BitVecSort(64)) aes_encryption = Function('AES', BitVecSort(16), BitVecSort(128)) constraints = [sboxmap[i] == sboxes[i] for i in range(128)] for i in range(len(data) // 64): four_code = sboxmap[flag[i]] four_code_parts = [Extract(16 * i + 15, 16 * i, four_code) for i in range(3, -1, -1)] for a, b in zip(data_int[4 * i:4 * i + 4], four_code_parts): constraints.append(aes_encryption(b) == a) constraints.append(Distinct([aes_encryption(i) for i in sboxints])) solver = Solver() solver.add(constraints) # if solver.check() == sat: # m = solver.model() for m in all_smt(solver, flag): flag_bytes = bytes([m.eval(flag[i]).as_long() for i in range(len(flag))]) assert len(set(flag_bytes)) == len( Counter(data[i:i + 64] for i in range(0, len(data), 64))) print(flag_bytes) else: print("failed to solve") Alternate Solution by teammate (Utaha#6878) All due regards to him for solving the challenge while I was stuck over finding key1 XD All parts will be almost same except the substitution solving part, which he did by manual bruteforcing i.e. recursively enumerating all mappings and backtracking on contradictions mp = dict() codes = sum([[i, i] for i in range(256)], start=[]) # notice that the range is changed from [0xb0, 0x1b0) to [0, 256). # It's just for relabeling. random.seed(key1) random.shuffle(codes) sboxes = [codes[i*4:(i+1)*4] for i in range(128)] def match(a, b): """ equate two objects elementwise ignoring if the entry is -1 """ for x, y in zip(a, b): if x == -1 or y == -1: continue if x != y: return False return True answers = [] def getFlag(cip, sboxes, mp): # get the flag based on current mapping, unknown char will be shown as '?' res = [] for c in cip: afterMap = [mp.get(x, -1) for x in c] found = False for i, s in enumerate(sboxes): if s == afterMap: res.append(i) found = True break if not found: res.append(ord('?')) return bytes(res) def brute(cip, sboxes, mp): """ cip and sboxes remain unchanged throughout the recursive call, but I feel bad using global varaibles. """ if DEBUG: print(getFlag(cip, sboxes, mp)) # check is finished isFinished = True for c in cip: if all(x in mp for x in c): pass else: isFinished = False if isFinished: answers.append(getFlag(cip, sboxes, mp)) print("Found an answer!!!!!!!") return # try matching isContradiction = False mp = mp.copy() # Find the one with least possible matches. min_pos = 256 index = -1 for idx, c in enumerate(cip): afterMap = [mp.get(x, -1) for x in c] if -1 not in afterMap: continue matches = [s for s in sboxes if match(s, afterMap)] if len(matches) == 0: isContradiction = True break if min_pos &gt; len(matches): index = idx min_pos = len(matches) if isContradiction: return # now bruteforce all possibilities assert index != -1 afterMap = [mp.get(x, -1) for x in cip[index]] matches = [s for s in sboxes if match(s, afterMap)] for m in matches: for x, y in zip(cip[index], m): mp[x] = y brute(cip, sboxes, mp) # This is based on the repetition for _ in [132, 197]: mp = {35: 224, 109: 144, 4: _} brute(cip, sboxes, mp) print("Answers:") answers = list(set(answers)) for x in answers: print(b"sdctf{" + x + b"}") # The fourth one is the actual answer Ciphertext repetition: [4, 5, 4, 6] [34, 35, 36, 35] [109, 60, 110, 109] Sbox repetition: [132, 93, 132, 211] [197, 32, 197, 248] [144, 86, 67, 144] [165, 224, 27, 224] Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Answers: b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}' b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}' b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}' full script in solve2.py]]></summary></entry><entry><title type="html">Redpwn 2020 Crypto - 12 Shades of Redpwn</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/12-shades-of-redpwn/2020-06-27-redpwn-2020-12-shades-of-redpwn" rel="alternate" type="text/html" title="Redpwn 2020 Crypto - 12 Shades of Redpwn" /><published>2020-06-27T00:00:00+05:30</published><updated>2020-06-27T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/12-shades-of-redpwn/redpwn-2020-12-shades-of-redpwn</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/12-shades-of-redpwn/2020-06-27-redpwn-2020-12-shades-of-redpwn"><![CDATA[<h1 id="12-shades-of-redpwn">12-shades-of-redpwn</h1>

<h2 id="description">Description</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Everyone's favorite guess god Tux just sent me a flag that he somehow encrypted with a color wheel!

I don't even know where to start, the wheel looks more like a clock than a cipher... can you help me crack the code?
</code></pre></div></div>

<h2 id="files">Files</h2>

<ul>
  <li><a href="color-wheel.jpg">color-wheel.jpg</a></li>
</ul>

<p><img src="color-wheel.jpg" alt="" /></p>

<ul>
  <li><a href="ciphertext.jpg">ciphertext.jpg</a> “Text” XD</li>
</ul>

<p><img src="ciphertext.jpg" alt="" /></p>

<p>Lets think like a clock, and start numbering colors from <code class="language-plaintext highlighter-rouge">0-11</code></p>

<p><img src="color-wheel2.gif" alt="" /></p>

<p>And if we map the corresponding numbers, we get</p>

<p><img src="ciphertext-extracted.jpg" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>86 90 81 87 a3 49 99 43 97 97 41 92 49 7b 41 97 7b 44 92 7b 44 96 98 a5
</code></pre></div></div>

<p>Now, we know that the flag begins with the prefix <code class="language-plaintext highlighter-rouge">flag{</code>, which helps us easily guess what it is, since <code class="language-plaintext highlighter-rouge">'f'</code> and <code class="language-plaintext highlighter-rouge">'l'</code> differ by <code class="language-plaintext highlighter-rouge">4</code>, here the ciphertext also differs by <code class="language-plaintext highlighter-rouge">4</code> i.e <code class="language-plaintext highlighter-rouge">90-86</code>. Also, <code class="language-plaintext highlighter-rouge">'l'</code> and <code class="language-plaintext highlighter-rouge">'a'</code> differ by 11, which confirms, that it is base 12 encoding.</p>

<p>Voila, here we go</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">EXTRACTED</span> <span class="o">=</span> <span class="s">'86 90 81 87 a3 49 99 43 97 97 41 92 49 7b 41 97 7b 44 92 7b 44 96 98 a5'</span>

<span class="n">flag</span> <span class="o">=</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="nb">chr</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="mi">12</span><span class="p">))</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">EXTRACTED</span><span class="p">.</span><span class="n">split</span><span class="p">()])</span>
<span class="k">print</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="flag--flag9u3ss1n9_1s_4n_4rt">flag = flag{9u3ss1n9_1s_4n_4rt}</h3>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="2020" /><category term="redpwn" /><category term="cryptography" /><category term="known_plaintext" /><category term="guess" /><category term="base12" /><summary type="html"><![CDATA[12-shades-of-redpwn Description Everyone's favorite guess god Tux just sent me a flag that he somehow encrypted with a color wheel! I don't even know where to start, the wheel looks more like a clock than a cipher... can you help me crack the code? Files color-wheel.jpg ciphertext.jpg “Text” XD Lets think like a clock, and start numbering colors from 0-11 And if we map the corresponding numbers, we get 86 90 81 87 a3 49 99 43 97 97 41 92 49 7b 41 97 7b 44 92 7b 44 96 98 a5 Now, we know that the flag begins with the prefix flag{, which helps us easily guess what it is, since 'f' and 'l' differ by 4, here the ciphertext also differs by 4 i.e 90-86. Also, 'l' and 'a' differ by 11, which confirms, that it is base 12 encoding. Voila, here we go EXTRACTED = '86 90 81 87 a3 49 99 43 97 97 41 92 49 7b 41 97 7b 44 92 7b 44 96 98 a5' flag = ''.join([chr(int(i,12)) for i in EXTRACTED.split()]) print(flag) flag = flag{9u3ss1n9_1s_4n_4rt}]]></summary></entry><entry><title type="html">Redpwn 2020 Crypto - 4k-rsa</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/4k-rsa/2020-06-27-redpwn-2020-4k-rsa" rel="alternate" type="text/html" title="Redpwn 2020 Crypto - 4k-rsa" /><published>2020-06-27T00:00:00+05:30</published><updated>2020-06-27T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/4k-rsa/redpwn-2020-4k-rsa</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/4k-rsa/2020-06-27-redpwn-2020-4k-rsa"><![CDATA[<h1 id="4k-rsa">4k-rsa</h1>

<h2 id="description">Description</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Only n00bz use 2048-bit RSA. True gamers use keys that are at least 4k bits long, no matter how many primes it takes...
</code></pre></div></div>

<h2 id="files">Files</h2>
<p><a href="4k-rsa-public-key.txt">4k-rsa-public-key.txt</a> which contains a <code class="language-plaintext highlighter-rouge">n, e, c</code> triple</p>

<p>Seems like there are a lot of primes in the factorization of <code class="language-plaintext highlighter-rouge">n</code>, since the factorization process is influenced directly by the size of prime factors and not the size of the number being factored itself, it should be fairly doable by <a href="alpetron.ar/ECM.HTM">alpetron.ar</a></p>

<p><img src="alpetron.PNG" alt="" /></p>

<p>It took about half an hour to factor, one may engage to other activities or alternatively try if the factors are available on <a href="http://factordb.com/">factordb</a>.<br />
Anyways, once finished factoring, alpetron produces both the <a href="factors">factors</a> and the Euler’s totient <code class="language-plaintext highlighter-rouge">phi</code> which will be used to compute <code class="language-plaintext highlighter-rouge">d</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>d = pow(e,-1,phi) # on python3.8
# or gmpy2.invert(e,phi) 
m = pow(c,d,n)
print(bytes.fromhex(hex(m)[2:]).decode())
</code></pre></div></div>
<p>And hurray, we have our flag</p>

<h3 id="flagt0000_m4nyyyy_pr1m355555">flag{t0000_m4nyyyy_pr1m355555}</h3>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="redpwn" /><category term="2020" /><category term="cryptography" /><category term="alpertron" /><category term="ECM" /><category term="RSA" /><summary type="html"><![CDATA[4k-rsa Description Only n00bz use 2048-bit RSA. True gamers use keys that are at least 4k bits long, no matter how many primes it takes... Files 4k-rsa-public-key.txt which contains a n, e, c triple Seems like there are a lot of primes in the factorization of n, since the factorization process is influenced directly by the size of prime factors and not the size of the number being factored itself, it should be fairly doable by alpetron.ar It took about half an hour to factor, one may engage to other activities or alternatively try if the factors are available on factordb. Anyways, once finished factoring, alpetron produces both the factors and the Euler’s totient phi which will be used to compute d d = pow(e,-1,phi) # on python3.8 # or gmpy2.invert(e,phi) m = pow(c,d,n) print(bytes.fromhex(hex(m)[2:]).decode()) And hurray, we have our flag flag{t0000_m4nyyyy_pr1m355555}]]></summary></entry><entry><title type="html">Redpwn 2020 Crypto - Alien Transmissions v2</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/alien-transmissions-v2/2020-06-27-redpwn-2020-alien-transmissions-v2" rel="alternate" type="text/html" title="Redpwn 2020 Crypto - Alien Transmissions v2" /><published>2020-06-27T00:00:00+05:30</published><updated>2020-06-27T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/alien-transmissions-v2/redpwn-2020-alien-transmissions-v2</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/alien-transmissions-v2/2020-06-27-redpwn-2020-alien-transmissions-v2"><![CDATA[<h1 id="alien-transmissions-v2">Alien-transmissions-v2</h1>

<h2 id="description">Description</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The aliens are at it again! We've discovered that their communications are in base 512 and have transcribed them in base 10. However, it seems like they used XOR encryption twice with two different keys! We do have some information:
  *  This alien language consists of words delimitated by the character represented as 481
  *  The two keys appear to be of length 21 and 19
  *  The value of each character in these keys does not exceed 255

Find these two keys for me; concatenate their ASCII encodings and wrap it in the flag format.
</code></pre></div></div>

<h2 id="files">Files</h2>
<ul>
  <li><a href="encrypted.txt">encrypted.txt</a>  (HUGE number of characters)</li>
</ul>

<h2 id="observations">Observations</h2>
<ul>
  <li>Hint 1, the delimitated character in plaintext is represented as 481. How does it help? Because in any language delimiter of words (space in our case) is the most frequent character (although we cant be sure about the aliens, what if they have really long words??), we can assume that the plaintext character 481 is the most frequent.</li>
  <li>Hint 2 states that it is XORed twice, once with the key of length 21 and again by length of key 19. If one ponders more, the two keys would act as a combined key of length of LCM of the two lengths 19 and 21, which is 21x19 = 399. And given the huge number of words (1100151), we can recover the key atleast pretty accurately.</li>
</ul>

<h2 id="combined-xor-key-recovery">Combined XOR key recovery</h2>
<p>The plaintexts at a difference of keylength are always encrypted by the same key letter, so splitting the ciphertext in keylength number of chunks, we can get a whole chunk, which has been encrypted by the same key byte. And since the character frequency of each chunk would resemble the character frequency distribution of the whole text owing to the huge size of ciphertext.</p>

<p>Just find the character with maximum frequency in each chunk, that would be 481 XOR key, XOR it with 481, to get the corresponding compound key character</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'encrypted.txt'</span><span class="p">,</span><span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">encrypted</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">encrypted</span><span class="p">.</span><span class="n">readlines</span><span class="p">()))</span>

<span class="n">key</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">()</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">21</span><span class="o">*</span><span class="mi">19</span><span class="p">):</span>
    <span class="n">data_slice</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">::</span><span class="mi">21</span><span class="o">*</span><span class="mi">19</span><span class="p">]</span>
    <span class="n">key_char_val</span> <span class="o">=</span> <span class="mi">481</span> <span class="o">^</span> <span class="nb">max</span><span class="p">(</span><span class="n">data_slice</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="n">data_slice</span><span class="p">.</span><span class="n">count</span><span class="p">)</span>
    <span class="n">key</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">key_char_val</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
</code></pre></div></div>
<p>It takes a couple of seconds to find the compound key</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">key</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="sa">b</span><span class="s">'7G</span><span class="se">\x1a\x00</span><span class="s">x</span><span class="se">\x00</span><span class="s">l</span><span class="se">\x17</span><span class="s">X];9</span><span class="se">\x00</span><span class="s">Gj</span><span class="se">\x00</span><span class="s">7Y</span><span class="se">\x01</span><span class="s">3</span><span class="se">\x12\x00\x00</span><span class="s">-</span><span class="se">\x06\x14</span><span class="s">Vo</span><span class="se">\x1a\x0c</span><span class="s">lnSn</span><span class="se">\x06</span><span class="s">]Ej7@</span><span class="se">\x04</span><span class="s">U7</span><span class="se">\x06</span><span class="s">AP</span><span class="se">\x17</span><span class="s">[;+Y</span><span class="se">\x06\x00\x12</span><span class="s">YC</span><span class="se">\x00</span><span class="s">++</span><span class="se">\x00\x07</span><span class="s">3S[PB]CjnA7G7W</span><span class="se">\x04</span><span class="s">-A</span><span class="se">\x1c</span><span class="s">l7</span><span class="se">\x01</span><span class="s">_</span><span class="se">\x05</span><span class="s">X]</span><span class="se">\x16</span><span class="s">l</span><span class="se">\x16\x00\x00\x00\x00\x02</span><span class="s">j9E</span><span class="se">\x1a\x06</span><span class="s">+j[W</span><span class="se">\\\x08\x0c</span><span class="s">lC</span><span class="se">\x06</span><span class="s">xA7E]l+</span><span class="se">\x0e\x02</span><span class="s">-</span><span class="se">\x00</span><span class="s">G&lt;XZ</span><span class="se">\x08</span><span class="s">9Y</span><span class="se">\x06</span><span class="s">-GO</span><span class="se">\x04</span><span class="s">j+</span><span class="se">\x1c</span><span class="s">[l9</span><span class="se">\x04</span><span class="s">AVD1</span><span class="se">\x0c</span><span class="s">k]S7G</span><span class="se">\x1a\x02\x12</span><span class="s">j+</span><span class="se">\x1c</span><span class="s">[ljURB[</span><span class="se">\x10\x00</span><span class="s">Y</span><span class="se">\x01</span><span class="s">3</span><span class="se">\x12\x00\x02</span><span class="s">GlS]l+]</span><span class="se">\x00</span><span class="s">&lt;V_</span><span class="se">\x16</span><span class="s">jEj7@</span><span class="se">\x04</span><span class="s">W]l</span><span class="se">\x06</span><span class="s">[</span><span class="se">\x14</span><span class="s">jjG</span><span class="se">\x0b\x03</span><span class="s">1</span><span class="se">\x02</span><span class="s">nC</span><span class="se">\x00</span><span class="s">++</span><span class="se">\x00\x05</span><span class="s">Y9</span><span class="se">\x1c</span><span class="s">[Al</span><span class="se">\x12\x06</span><span class="s">&lt;D</span><span class="se">\x06</span><span class="s">W</span><span class="se">\x00</span><span class="s">W</span><span class="se">\x04</span><span class="s">-A</span><span class="se">\x1c</span><span class="s">n]k</span><span class="se">\x18\x0e</span><span class="s">[lG</span><span class="se">\x00</span><span class="s">D</span><span class="se">\x05</span><span class="s">1</span><span class="se">\x10</span><span class="s">7</span><span class="se">\x02</span><span class="s">j9E</span><span class="se">\x1a\x04</span><span class="s">A</span><span class="se">\x00\x1c\\</span><span class="s">_9]</span><span class="se">\x00\x11\x03</span><span class="s">IQ</span><span class="se">\x00</span><span class="s">E]l+</span><span class="se">\x0e\x00</span><span class="s">Gj</span><span class="se">\x00</span><span class="s">7[kYU</span><span class="se">\x0b\x03\x1c</span><span class="s">Wx</span><span class="se">\x04</span><span class="s">j+</span><span class="se">\x1c</span><span class="s">[nSn</span><span class="se">\x06</span><span class="s">]G</span><span class="se">\x00</span><span class="s">]</span><span class="se">\x07\x0f</span><span class="s">V</span><span class="se">\x06</span><span class="s">W-</span><span class="se">\x02\x12</span><span class="s">j+</span><span class="se">\x1c</span><span class="s">Y</span><span class="se">\x06\x00\x12</span><span class="s">YAjAl</span><span class="se">\x0b\x04\x02\x02</span><span class="s">7</span><span class="se">\x02</span><span class="s">GlS]nA7G7UnG</span><span class="se">\x06\x17</span><span class="s">o</span><span class="se">\x06</span><span class="s">P3W]l</span><span class="se">\x06</span><span class="s">[</span><span class="se">\x16\x00\x00\x00\x00\x00\x00</span><span class="s">S</span><span class="se">\x02\x11\x05\x1a</span><span class="s">;7</span><span class="se">\x05</span><span class="s">Y9</span><span class="se">\x1c</span><span class="s">[C</span><span class="se">\x06</span><span class="s">xA7G7</span><span class="se">\x06</span><span class="s">l</span><span class="se">\x05\x01\x1c</span><span class="s">Q+n]k</span><span class="se">\x18\x0e</span><span class="s">Y</span><span class="se">\x06</span><span class="s">-GO</span><span class="se">\x06\x00</span><span class="s">A[Po</span><span class="se">\x08</span><span class="s">U-</span><span class="se">\x04</span><span class="s">A</span><span class="se">\x00\x1c\\</span><span class="s">]S'</span><span class="p">)</span>
</code></pre></div></div>

<p>Now, we have the XOR of key1 and key2, we need to recover key1 and key2 from it. We have all possible bytes, of key1 XORed with key2 and vice-versa.</p>

<p>First thought, <a href="https://github.com/Z3Prover/z3">Z3</a> go brrrrrr….</p>

<p>Although Z3 produces a feasible solution(model), a quick <a href="https://stackoverflow.com/questions/11867611/z3py-checking-all-solutions-for-equation">stackOverflow</a> post gave me the implementation of finding n models.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">z3</span> <span class="kn">import</span> <span class="o">*</span>
<span class="k">def</span> <span class="nf">get_models</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
    <span class="s">"""
    Returns a list of M models (if possible) from the list of constraints F
    """</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
    <span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">F</span><span class="p">)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">M</span> <span class="ow">and</span> <span class="n">s</span><span class="p">.</span><span class="n">check</span><span class="p">()</span> <span class="o">==</span> <span class="n">sat</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">model</span><span class="p">()</span>
        <span class="n">result</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="c1"># Create a new constraint the blocks the current model
</span>        <span class="n">block</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">m</span><span class="p">:</span>
            <span class="c1"># d is a declaration
</span>            <span class="k">if</span> <span class="n">d</span><span class="p">.</span><span class="n">arity</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s">"uninterpreted functions are not supported"</span><span class="p">)</span>
            <span class="c1"># create a constant from declaration
</span>            <span class="n">c</span> <span class="o">=</span> <span class="n">d</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">is_array</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">or</span> <span class="n">c</span><span class="p">.</span><span class="n">sort</span><span class="p">().</span><span class="n">kind</span><span class="p">()</span> <span class="o">==</span> <span class="n">Z3_UNINTERPRETED_SORT</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Z3Exception</span><span class="p">(</span><span class="s">"arrays and uninterpreted sorts are not supported"</span><span class="p">)</span>
            <span class="n">block</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span> <span class="o">!=</span> <span class="n">m</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
        <span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">Or</span><span class="p">(</span><span class="n">block</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">result</span>
</code></pre></div></div>

<p>All we need to do is to form constraints and checking if the generated model produces ASCII printable strings.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">key1</span> <span class="o">=</span> <span class="p">[</span><span class="n">z3</span><span class="p">.</span><span class="n">BitVec</span><span class="p">(</span><span class="s">"k1{}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="mi">8</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">21</span><span class="p">)]</span>
<span class="n">key2</span> <span class="o">=</span> <span class="p">[</span><span class="n">z3</span><span class="p">.</span><span class="n">BitVec</span><span class="p">(</span><span class="s">"k2{}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="mi">8</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">19</span><span class="p">)]</span>
<span class="n">F</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">19</span><span class="o">*</span><span class="mi">21</span><span class="p">):</span>
    <span class="n">F</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">key1</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="mi">21</span><span class="p">]</span><span class="o">^</span><span class="n">key2</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="mi">19</span><span class="p">]</span><span class="o">==</span><span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="c1"># Valid flag characters
</span><span class="n">VALID_CHARS</span> <span class="o">=</span> <span class="n">string</span><span class="p">.</span><span class="n">printable</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">62</span><span class="p">]</span><span class="o">+</span><span class="s">"_,.'?!@$&lt;&gt;*:-]*</span><span class="se">\\</span><span class="s">"</span>
<span class="k">for</span> <span class="n">model</span> <span class="ow">in</span> <span class="n">get_models</span><span class="p">(</span><span class="n">F</span><span class="p">,</span><span class="mi">256</span><span class="p">):</span>
    <span class="c1"># 256 models to get all possible relative strings
</span>    <span class="n">KEY1</span> <span class="o">=</span> <span class="s">""</span><span class="p">.</span><span class="n">join</span><span class="p">(</span> <span class="nb">chr</span><span class="p">(</span><span class="n">model</span><span class="p">[</span><span class="n">key1</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">as_long</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">21</span><span class="p">))</span>
    <span class="n">KEY2</span> <span class="o">=</span> <span class="s">""</span><span class="p">.</span><span class="n">join</span><span class="p">(</span> <span class="nb">chr</span><span class="p">(</span><span class="n">model</span><span class="p">[</span><span class="n">key2</span><span class="p">[</span><span class="n">i</span><span class="p">]].</span><span class="n">as_long</span><span class="p">())</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">19</span><span class="p">))</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="n">KEY1</span><span class="o">+</span><span class="n">KEY2</span>
    <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">i</span> <span class="ow">in</span> <span class="n">VALID_CHARS</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">flag</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
</code></pre></div></div>
<p>Turns out there was only one model with all characters printable and which is our flag</p>

<h3 id="flagh3r35_th3_f1r5t_h4lf_th3_53c0nd_15_th15">flag{h3r3’5_th3_f1r5t_h4lf_th3_53c0nd_15_th15}</h3>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="redpwn" /><category term="2020" /><category term="cryptography" /><category term="xor" /><category term="z3" /><summary type="html"><![CDATA[Alien-transmissions-v2 Description The aliens are at it again! We've discovered that their communications are in base 512 and have transcribed them in base 10. However, it seems like they used XOR encryption twice with two different keys! We do have some information: * This alien language consists of words delimitated by the character represented as 481 * The two keys appear to be of length 21 and 19 * The value of each character in these keys does not exceed 255 Find these two keys for me; concatenate their ASCII encodings and wrap it in the flag format. Files encrypted.txt (HUGE number of characters) Observations Hint 1, the delimitated character in plaintext is represented as 481. How does it help? Because in any language delimiter of words (space in our case) is the most frequent character (although we cant be sure about the aliens, what if they have really long words??), we can assume that the plaintext character 481 is the most frequent. Hint 2 states that it is XORed twice, once with the key of length 21 and again by length of key 19. If one ponders more, the two keys would act as a combined key of length of LCM of the two lengths 19 and 21, which is 21x19 = 399. And given the huge number of words (1100151), we can recover the key atleast pretty accurately. Combined XOR key recovery The plaintexts at a difference of keylength are always encrypted by the same key letter, so splitting the ciphertext in keylength number of chunks, we can get a whole chunk, which has been encrypted by the same key byte. And since the character frequency of each chunk would resemble the character frequency distribution of the whole text owing to the huge size of ciphertext. Just find the character with maximum frequency in each chunk, that would be 481 XOR key, XOR it with 481, to get the corresponding compound key character with open('encrypted.txt','r') as encrypted: data = list(map(int, encrypted.readlines())) key = bytearray() for i in range(21*19): data_slice = data[i::21*19] key_char_val = 481 ^ max(data_slice, key=data_slice.count) key.append(key_char_val) print(key) It takes a couple of seconds to find the compound key key = bytearray(b'7G\x1a\x00x\x00l\x17X];9\x00Gj\x007Y\x013\x12\x00\x00-\x06\x14Vo\x1a\x0clnSn\x06]Ej7@\x04U7\x06AP\x17[;+Y\x06\x00\x12YC\x00++\x00\x073S[PB]CjnA7G7W\x04-A\x1cl7\x01_\x05X]\x16l\x16\x00\x00\x00\x00\x02j9E\x1a\x06+j[W\\\x08\x0clC\x06xA7E]l+\x0e\x02-\x00G&lt;XZ\x089Y\x06-GO\x04j+\x1c[l9\x04AVD1\x0ck]S7G\x1a\x02\x12j+\x1c[ljURB[\x10\x00Y\x013\x12\x00\x02GlS]l+]\x00&lt;V_\x16jEj7@\x04W]l\x06[\x14jjG\x0b\x031\x02nC\x00++\x00\x05Y9\x1c[Al\x12\x06&lt;D\x06W\x00W\x04-A\x1cn]k\x18\x0e[lG\x00D\x051\x107\x02j9E\x1a\x04A\x00\x1c\\_9]\x00\x11\x03IQ\x00E]l+\x0e\x00Gj\x007[kYU\x0b\x03\x1cWx\x04j+\x1c[nSn\x06]G\x00]\x07\x0fV\x06W-\x02\x12j+\x1cY\x06\x00\x12YAjAl\x0b\x04\x02\x027\x02GlS]nA7G7UnG\x06\x17o\x06P3W]l\x06[\x16\x00\x00\x00\x00\x00\x00S\x02\x11\x05\x1a;7\x05Y9\x1c[C\x06xA7G7\x06l\x05\x01\x1cQ+n]k\x18\x0eY\x06-GO\x06\x00A[Po\x08U-\x04A\x00\x1c\\]S') Now, we have the XOR of key1 and key2, we need to recover key1 and key2 from it. We have all possible bytes, of key1 XORed with key2 and vice-versa. First thought, Z3 go brrrrrr…. Although Z3 produces a feasible solution(model), a quick stackOverflow post gave me the implementation of finding n models. from z3 import * def get_models(F, M): """ Returns a list of M models (if possible) from the list of constraints F """ result = [] s = Solver() s.add(F) while len(result) &lt; M and s.check() == sat: m = s.model() result.append(m) # Create a new constraint the blocks the current model block = [] for d in m: # d is a declaration if d.arity() &gt; 0: raise Z3Exception("uninterpreted functions are not supported") # create a constant from declaration c = d() if is_array(c) or c.sort().kind() == Z3_UNINTERPRETED_SORT: raise Z3Exception("arrays and uninterpreted sorts are not supported") block.append(c != m[d]) s.add(Or(block)) return result All we need to do is to form constraints and checking if the generated model produces ASCII printable strings. key1 = [z3.BitVec("k1{}".format(i),8) for i in range(21)] key2 = [z3.BitVec("k2{}".format(i),8) for i in range(19)] F = [] for i in range(19*21): F.append(key1[i%21]^key2[i%19]==key[i]) # Valid flag characters VALID_CHARS = string.printable[0:62]+"_,.'?!@$&lt;&gt;*:-]*\\" for model in get_models(F,256): # 256 models to get all possible relative strings KEY1 = "".join( chr(model[key1[i]].as_long()) for i in range(21)) KEY2 = "".join( chr(model[key2[i]].as_long()) for i in range(19)) flag = KEY1+KEY2 if all(i in VALID_CHARS for i in flag): print(flag) Turns out there was only one model with all characters printable and which is our flag flag{h3r3’5_th3_f1r5t_h4lf_th3_53c0nd_15_th15}]]></summary></entry><entry><title type="html">Redpwn 2020 Crypto - base646464</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/base646464/2020-06-27-redpwn-2020-base646464" rel="alternate" type="text/html" title="Redpwn 2020 Crypto - base646464" /><published>2020-06-27T00:00:00+05:30</published><updated>2020-06-27T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/base646464/redpwn-2020-base646464</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/base646464/2020-06-27-redpwn-2020-base646464"><![CDATA[<h1 id="base646464">base646464</h1>

<h2 id="description">Description</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Encoding something multiple times makes it exponentially more secure!
</code></pre></div></div>

<h2 id="files">Files</h2>
<ul>
  <li><a href="cipher.txt">cipher.txt</a></li>
  <li><a href="generate.js">generate.js</a></li>
</ul>

<p>Lets take a look at generate.js, which reads</p>
<div class="language-javascript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">btoa</span> <span class="o">=</span> <span class="nx">str</span> <span class="o">=&gt;</span> <span class="nx">Buffer</span><span class="p">.</span><span class="k">from</span><span class="p">(</span><span class="nx">str</span><span class="p">).</span><span class="nx">toString</span><span class="p">(</span><span class="dl">'</span><span class="s1">base64</span><span class="dl">'</span><span class="p">);</span>

<span class="kd">const</span> <span class="nx">fs</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="dl">"</span><span class="s2">fs</span><span class="dl">"</span><span class="p">);</span>
<span class="kd">const</span> <span class="nx">flag</span> <span class="o">=</span> <span class="nx">fs</span><span class="p">.</span><span class="nx">readFileSync</span><span class="p">(</span><span class="dl">"</span><span class="s2">flag.txt</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">utf8</span><span class="dl">"</span><span class="p">).</span><span class="nx">trim</span><span class="p">();</span>

<span class="kd">let</span> <span class="nx">ret</span> <span class="o">=</span> <span class="nx">flag</span><span class="p">;</span>
<span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;</span> <span class="mi">25</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span><span class="p">)</span> <span class="nx">ret</span> <span class="o">=</span> <span class="nx">btoa</span><span class="p">(</span><span class="nx">ret</span><span class="p">);</span>

<span class="nx">fs</span><span class="p">.</span><span class="nx">writeFileSync</span><span class="p">(</span><span class="dl">"</span><span class="s2">cipher.txt</span><span class="dl">"</span><span class="p">,</span> <span class="nx">ret</span><span class="p">);</span>
</code></pre></div></div>

<p>The function <code class="language-plaintext highlighter-rouge">btoa</code> is basically string to its base64 encoding.<br />
The flag is encoded repetitively 25 times in a for loop.<br />
We just need to base64 decode it 25 times and we will get the flag.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">base64</span> <span class="kn">import</span> <span class="n">b64decode</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'cipher.txt'</span><span class="p">,</span><span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">cipher_file</span><span class="p">:</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">cipher_file</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">25</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">b64decode</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</code></pre></div></div>
<p>A cool sarcasm on bad crypto challenges in CTFs :)</p>
<h3 id="flagl00ks_l1ke_a_l0t_of_64s">flag{l00ks_l1ke_a_l0t_of_64s}</h3>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="redpwn" /><category term="2020" /><category term="cryptography" /><category term="javascript" /><category term="base64" /><summary type="html"><![CDATA[base646464 Description Encoding something multiple times makes it exponentially more secure! Files cipher.txt generate.js Lets take a look at generate.js, which reads const btoa = str =&gt; Buffer.from(str).toString('base64'); const fs = require("fs"); const flag = fs.readFileSync("flag.txt", "utf8").trim(); let ret = flag; for(let i = 0; i &lt; 25; i++) ret = btoa(ret); fs.writeFileSync("cipher.txt", ret); The function btoa is basically string to its base64 encoding. The flag is encoded repetitively 25 times in a for loop. We just need to base64 decode it 25 times and we will get the flag. from base64 import b64decode with open('cipher.txt','r') as cipher_file: data = cipher_file.read() for i in range(25): data = b64decode(data) print(data) A cool sarcasm on bad crypto challenges in CTFs :) flag{l00ks_l1ke_a_l0t_of_64s}]]></summary></entry><entry><title type="html">Redpwn 2020 Crypto - Itsy Bitsy</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/itsy-bitsy/2020-06-27-redpwn-2020-Itsy-Bitsy" rel="alternate" type="text/html" title="Redpwn 2020 Crypto - Itsy Bitsy" /><published>2020-06-27T00:00:00+05:30</published><updated>2020-06-27T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/itsy-bitsy/redpwn-2020-Itsy-Bitsy</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/itsy-bitsy/2020-06-27-redpwn-2020-Itsy-Bitsy"><![CDATA[<h1 id="itsy-bitsy">itsy-bitsy</h1>

<h2 id="description">Description</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>The itsy-bitsy spider climbed up the water spout...

nc 2020.redpwnc.tf 31284
</code></pre></div></div>
<h2 id="files">Files</h2>
<ul>
  <li><a href="itsy-bitsy.py">itsy-bitsy.py</a></li>
</ul>

<p>Lets quickly take a look at now the connection works</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>nc 2020.redpwnc.tf 31284
Enter an integer i such that i <span class="o">&gt;</span> 0: 1
Enter an integer j such that j <span class="o">&gt;</span> i <span class="o">&gt;</span> 0: 2
Ciphertext: 0010001001011101111000001100000010000011000111100100111100011000100001001001100111110011100100000001101101010101001100001100010010000001111000000010100001001100100001000000010101000101010101011010011011100110100000010001110000101000011011001001010110010101000000100001011110000100010100010010110100000

</code></pre></div></div>
<p>Let us quickly go through the required functions of the source</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
</span>
<span class="kn">from</span> <span class="nn">Crypto.Random.random</span> <span class="kn">import</span> <span class="n">randint</span>

<span class="k">def</span> <span class="nf">str_to_bits</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="n">bit_str</span> <span class="o">=</span> <span class="s">''</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">s</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">bit_str</span> <span class="o">+=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">i</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">bit_str</span>

<span class="k">def</span> <span class="nf">recv_input</span><span class="p">():</span>
    <span class="n">i</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">'Enter an integer i such that i &gt; 0: '</span><span class="p">)</span>
    <span class="n">j</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">'Enter an integer j such that j &gt; i &gt; 0: '</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span><span class="p">:</span>
            <span class="k">raise</span> <span class="nb">Exception</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">'Error! You must adhere to the restrictions!'</span><span class="p">)</span>
        <span class="nb">exit</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span>

<span class="k">def</span> <span class="nf">generate_random_bits</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">number_of_bits</span><span class="p">):</span>
    <span class="n">bit_str</span> <span class="o">=</span> <span class="s">''</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">bit_str</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">number_of_bits</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">)</span>
        <span class="n">bit_str</span> <span class="o">+=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">r</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">bit_str</span><span class="p">[:</span><span class="n">number_of_bits</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">bit_str_xor</span><span class="p">(</span><span class="n">bit_str_1</span><span class="p">,</span> <span class="n">bit_str_2</span><span class="p">):</span>
    <span class="n">xor_res</span> <span class="o">=</span> <span class="s">''</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bit_str_1</span><span class="p">)):</span>
        <span class="n">bit_1</span> <span class="o">=</span> <span class="n">bit_str_1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">bit_2</span> <span class="o">=</span> <span class="n">bit_str_2</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">xor_res</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">bit_1</span><span class="p">)</span> <span class="o">^</span> <span class="nb">int</span><span class="p">(</span><span class="n">bit_2</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">xor_res</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'flag.txt'</span><span class="p">,</span><span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">flag</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">ord</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">6</span><span class="p">,</span><span class="mi">2</span><span class="o">**</span><span class="mi">7</span><span class="p">)</span>
    <span class="n">flag_bits</span> <span class="o">=</span> <span class="n">str_to_bits</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
    <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="o">=</span> <span class="n">recv_input</span><span class="p">()</span>
    <span class="n">lb</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">i</span>
    <span class="n">ub</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flag_bits</span><span class="p">)</span>
    <span class="n">random_bits</span> <span class="o">=</span> <span class="n">generate_random_bits</span><span class="p">(</span><span class="n">lb</span><span class="p">,</span><span class="n">ub</span><span class="p">,</span><span class="n">n</span><span class="p">)</span>
    <span class="n">encrypted_bits</span> <span class="o">=</span> <span class="n">bit_str_xor</span><span class="p">(</span><span class="n">flag_bits</span><span class="p">,</span><span class="n">random_bits</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Ciphertext: </span><span class="si">{</span><span class="n">encrypted_bits</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">generate_random_bits</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">number_of_bits</span><span class="p">):</span>
    <span class="n">bit_str</span> <span class="o">=</span> <span class="s">''</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">bit_str</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">number_of_bits</span><span class="p">:</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">randint</span><span class="p">(</span><span class="n">lower_bound</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">)</span>
        <span class="n">bit_str</span> <span class="o">+=</span> <span class="nb">bin</span><span class="p">(</span><span class="n">r</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span>
    <span class="k">return</span> <span class="n">bit_str</span><span class="p">[:</span><span class="n">number_of_bits</span><span class="p">]</span>
</code></pre></div></div>
<p>It will generate a random bitstring of length <code class="language-plaintext highlighter-rouge">number_of_bits</code> from <code class="language-plaintext highlighter-rouge">lower_bound</code> to <code class="language-plaintext highlighter-rouge">upper_bound</code> and if the <code class="language-plaintext highlighter-rouge">lower_bound</code> itself is greater than the requirement, it will truncate it.</p>

<p>We are asked for input for <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> which are converted to lower and upper bounds as <code class="language-plaintext highlighter-rouge">2**i</code> to <code class="language-plaintext highlighter-rouge">2**j - 1</code>.<br />
The generated bitstream is xored (bit-wise) with the flag and returned</p>

<h2 id="observation">Observation</h2>
<p>If one sets <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">j</code> to <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">i+1</code>, the bounds are <code class="language-plaintext highlighter-rouge">2**i</code> and <code class="language-plaintext highlighter-rouge">2**(i+1) - 1</code>, which are both <code class="language-plaintext highlighter-rouge">i</code> bits in length.<br />
The pecularity being the first bit would always be <code class="language-plaintext highlighter-rouge">1</code> because of <code class="language-plaintext highlighter-rouge">2**i</code> and all the bits at positions multiples of <code class="language-plaintext highlighter-rouge">i</code> would be <code class="language-plaintext highlighter-rouge">1</code></p>

<h4 id="example">Example</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">generate_random_bits</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="o">**</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">80</span><span class="p">)</span>
<span class="s">'10101111111010111010111110111010101010101111101111111010101010111111111011111011'</span>
</code></pre></div></div>
<p>Notice the 0th, 2nd, 4th index and so on is always <code class="language-plaintext highlighter-rouge">1</code>
My unoptimized script <a href="solve.py">solve.py</a> which just concerns about knowing the bit at position <code class="language-plaintext highlighter-rouge">i</code> by sending the index <code class="language-plaintext highlighter-rouge">i-1</code> and <code class="language-plaintext highlighter-rouge">i</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="n">remote</span>

<span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span> <span class="o">=</span> <span class="s">"2020.redpwnc.tf"</span><span class="p">,</span> <span class="mi">31284</span>

<span class="k">def</span> <span class="nf">get_ct</span><span class="p">(</span><span class="n">num_bits</span><span class="p">):</span>
    <span class="n">REM</span> <span class="o">=</span> <span class="n">remote</span><span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span>
    <span class="n">REM</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">num_bits</span> <span class="o">-</span><span class="mi">1</span><span class="p">).</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">REM</span><span class="p">.</span><span class="n">sendline</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">num_bits</span><span class="p">).</span><span class="n">encode</span><span class="p">())</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">REM</span><span class="p">.</span><span class="n">recvline</span><span class="p">()</span>
    <span class="n">ciphertext</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="sa">b</span><span class="s">':'</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">strip</span><span class="p">()</span>
    <span class="c1">#print(data)
</span>    <span class="n">REM</span><span class="p">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">ciphertext</span>

<span class="n">flag_bits</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="mi">301</span><span class="p">)</span>  <span class="c1">#flag size known 
</span><span class="n">flag_bits</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">49</span>  <span class="c1"># ord('1') known from the first character 'f' of flag
</span><span class="n">flag_bits</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">49</span>  <span class="c1"># ord('1') 
</span><span class="k">for</span> <span class="n">num_bits</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">301</span><span class="p">):</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="n">get_ct</span><span class="p">(</span><span class="n">num_bits</span><span class="p">)</span>
    <span class="n">flag_bits</span><span class="p">[</span><span class="n">num_bits</span><span class="p">]</span> <span class="o">=</span> <span class="mi">48</span> <span class="k">if</span> <span class="n">ct</span><span class="p">[</span><span class="n">num_bits</span><span class="p">]</span> <span class="o">==</span> <span class="mi">49</span> <span class="k">else</span> <span class="mi">49</span>

<span class="k">print</span><span class="p">(</span><span class="n">bits_to_str</span><span class="p">(</span><span class="n">flag_bits</span><span class="p">))</span>
</code></pre></div></div>

<p>This can be improved just by noting the fact we knew most of the bits <code class="language-plaintext highlighter-rouge">i</code> before reaching the index <code class="language-plaintext highlighter-rouge">i</code>, we will only make a request if bit <code class="language-plaintext highlighter-rouge">i</code> is not known</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">num_bits</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">301</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">flag_bits</span><span class="p">[</span><span class="n">num_bits</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="n">get_ct</span><span class="p">(</span><span class="n">num_bits</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_bits</span><span class="p">,</span> <span class="mi">301</span><span class="p">,</span> <span class="n">num_bits</span><span class="p">):</span>
            <span class="n">flag_bits</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">48</span> <span class="k">if</span> <span class="n">ct</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">49</span> <span class="k">else</span> <span class="mi">49</span>
<span class="k">print</span><span class="p">(</span><span class="n">bits_to_str</span><span class="p">(</span><span class="n">flag_bits</span><span class="p">))</span>
</code></pre></div></div>
<p>Which takes 62 requests instead of 300 as in original</p>

<h3 id="flagbits_leaking_out_down_the_water_spout">flag{bits_leaking_out_down_the_water_spout}</h3>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="redpwn" /><category term="2020" /><category term="cryptography" /><category term="leakage" /><category term="xor" /><summary type="html"><![CDATA[itsy-bitsy Description The itsy-bitsy spider climbed up the water spout... nc 2020.redpwnc.tf 31284 Files itsy-bitsy.py Lets quickly take a look at now the connection works nc 2020.redpwnc.tf 31284 Enter an integer i such that i &gt; 0: 1 Enter an integer j such that j &gt; i &gt; 0: 2 Ciphertext: 0010001001011101111000001100000010000011000111100100111100011000100001001001100111110011100100000001101101010101001100001100010010000001111000000010100001001100100001000000010101000101010101011010011011100110100000010001110000101000011011001001010110010101000000100001011110000100010100010010110100000 Let us quickly go through the required functions of the source #!/usr/bin/env python3 from Crypto.Random.random import randint def str_to_bits(s): bit_str = '' for c in s: i = ord(c) bit_str += bin(i)[2:] return bit_str def recv_input(): i = input('Enter an integer i such that i &gt; 0: ') j = input('Enter an integer j such that j &gt; i &gt; 0: ') try: i = int(i) j = int(j) if i &lt;= 0 or j &lt;= i: raise Exception except: print('Error! You must adhere to the restrictions!') exit() return i,j def generate_random_bits(lower_bound, upper_bound, number_of_bits): bit_str = '' while len(bit_str) &lt; number_of_bits: r = randint(lower_bound, upper_bound) bit_str += bin(r)[2:] return bit_str[:number_of_bits] def bit_str_xor(bit_str_1, bit_str_2): xor_res = '' for i in range(len(bit_str_1)): bit_1 = bit_str_1[i] bit_2 = bit_str_2[i] xor_res += str(int(bit_1) ^ int(bit_2)) return xor_res def main(): with open('flag.txt','r') as f: flag = f.read() for c in flag: i = ord(c) assert i in range(2**6,2**7) flag_bits = str_to_bits(flag) i,j = recv_input() lb = 2**i ub = 2**j - 1 n = len(flag_bits) random_bits = generate_random_bits(lb,ub,n) encrypted_bits = bit_str_xor(flag_bits,random_bits) print(f'Ciphertext: {encrypted_bits}') if __name__ == '__main__': main() def generate_random_bits(lower_bound, upper_bound, number_of_bits): bit_str = '' while len(bit_str) &lt; number_of_bits: r = randint(lower_bound, upper_bound) bit_str += bin(r)[2:] return bit_str[:number_of_bits] It will generate a random bitstring of length number_of_bits from lower_bound to upper_bound and if the lower_bound itself is greater than the requirement, it will truncate it. We are asked for input for i and j which are converted to lower and upper bounds as 2**i to 2**j - 1. The generated bitstream is xored (bit-wise) with the flag and returned Observation If one sets i and j to i and i+1, the bounds are 2**i and 2**(i+1) - 1, which are both i bits in length. The pecularity being the first bit would always be 1 because of 2**i and all the bits at positions multiples of i would be 1 Example generate_random_bits(2**1,2**(1+1)-1,80) '10101111111010111010111110111010101010101111101111111010101010111111111011111011' Notice the 0th, 2nd, 4th index and so on is always 1 My unoptimized script solve.py which just concerns about knowing the bit at position i by sending the index i-1 and i. from pwn import remote HOST, PORT = "2020.redpwnc.tf", 31284 def get_ct(num_bits): REM = remote(HOST, PORT) REM.sendline(str(num_bits -1).encode()) REM.sendline(str(num_bits).encode()) data = REM.recvline() ciphertext = data.split(b':')[-1].strip() #print(data) REM.close() return ciphertext flag_bits = bytearray(301) #flag size known flag_bits[0] = 49 # ord('1') known from the first character 'f' of flag flag_bits[1] = 49 # ord('1') for num_bits in range(2,301): ct = get_ct(num_bits) flag_bits[num_bits] = 48 if ct[num_bits] == 49 else 49 print(bits_to_str(flag_bits)) This can be improved just by noting the fact we knew most of the bits i before reaching the index i, we will only make a request if bit i is not known for num_bits in range(2,301): if flag_bits[num_bits] == 0: ct = get_ct(num_bits) for i in range(num_bits, 301, num_bits): flag_bits[i] = 48 if ct[i] == 49 else 49 print(bits_to_str(flag_bits)) Which takes 62 requests instead of 300 as in original flag{bits_leaking_out_down_the_water_spout}]]></summary></entry><entry><title type="html">Redpwn 2020 Crypto - primimity</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/primimity/2020-06-27-redpwn-2020-primimity" rel="alternate" type="text/html" title="Redpwn 2020 Crypto - primimity" /><published>2020-06-27T00:00:00+05:30</published><updated>2020-06-27T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/primimity/redpwn-2020-primimity</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/primimity/2020-06-27-redpwn-2020-primimity"><![CDATA[<h1 id="primitity">Primitity</h1>

<h2 id="description">Description</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>People claim that RSA with two 1024-bit primes is secure. But I trust no one. That's why I use three 1024-bit primes.

I even created my own prime generator to be extra cautious!
</code></pre></div></div>

<h2 id="files">Files</h2>
<ul>
  <li><a href="primimity.py">primimity.py</a></li>
  <li><a href="primimity-public-key.txt">primimity-public-key.txt</a></li>
</ul>

<p>Lets take a look at source <a href="primimity.py">primimity.py</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
</span>
<span class="kn">from</span> <span class="nn">Crypto.Util.number</span> <span class="kn">import</span> <span class="n">getRandomNBitInteger</span><span class="p">,</span> <span class="n">isPrime</span>

<span class="k">def</span> <span class="nf">find_next_prime</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">2</span>
    <span class="k">elif</span> <span class="n">n</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">3</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="n">isPrime</span><span class="p">(</span><span class="n">n</span><span class="p">):</span>
            <span class="n">n</span> <span class="o">+=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">n</span>

<span class="k">def</span> <span class="nf">prime_gen</span><span class="p">():</span>
    <span class="n">i</span> <span class="o">=</span> <span class="n">getRandomNBitInteger</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">getRandomNBitInteger</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">find_next_prime</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">find_next_prime</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">getRandomNBitInteger</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">find_next_prime</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">find_next_prime</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">d</span> <span class="o">=</span> <span class="n">getRandomNBitInteger</span><span class="p">(</span><span class="mi">8</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">find_next_prime</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">find_next_prime</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">r</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="p">(</span><span class="n">p</span><span class="p">,</span><span class="n">q</span><span class="p">,</span><span class="n">r</span><span class="p">)</span> <span class="o">=</span> <span class="n">prime_gen</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">q</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">'__main__'</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</code></pre></div></div>

<p>As one could observe, its yet another RSA with 3 primes instead of two.<br />
The twist with the prime generation <code class="language-plaintext highlighter-rouge">prime_gen</code> is that it doesnt generate three independent random primes, but it generates a random prime p, then <del>generates</del> picks two random primes <code class="language-plaintext highlighter-rouge">q</code> and <code class="language-plaintext highlighter-rouge">r</code> randomly within the <strong>proximity</strong> (next 256 primes max) of <code class="language-plaintext highlighter-rouge">p</code>.</p>

<p>How does this information help?<br />
Cuberoot of n would serve as an approximation for <code class="language-plaintext highlighter-rouge">r</code>, from which we can traverse back (previous primes), till we get the prime factors of <code class="language-plaintext highlighter-rouge">n</code></p>

<p>Instead of implementing <code class="language-plaintext highlighter-rouge">previous_prime</code> (lazy me), one could easily subtract some number so that the initial estimate is smaller than <code class="language-plaintext highlighter-rouge">p</code> and we could easily use <code class="language-plaintext highlighter-rouge">gmpy2.next_prime</code> :p</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">gmpy2</span>
<span class="n">n</span> <span class="o">=</span> <span class="mi">2739699434633097765008468371124644741923408864896396205946954196101304653772173210372608955799251139999322976228678445908704975780068946332615022064030241384638601426716056067126300711933438732265846838735860353259574129074615298010047322960704972157930663061480726566962254887144927753449042590678730779046154516549667611603792754880414526688217305247008627664864637891883902537649625488225238118503996674292057904635593729208703096877231276911845233833770015093213639131244386867600956112884383105437861665666273910566732634878464610789895607273567372933766243229798663389032807187003756226177111720510187664096691560511459141773632683383938152396711991246874813205614169161561906148974478519987935950318569760474249427787310865749167740917232799538099494710964837536211535351200520324575676987080484141561336505103872809932354748531675934527453231255132361489570816639925234935907741385330442961877410196615649696508210921</span>
<span class="n">e</span> <span class="o">=</span> <span class="mi">65537</span>
<span class="n">c</span> <span class="o">=</span> <span class="mi">2082926013138674164997791605512226759362824531322433048281306983526001801581956788909408046338065370689701410862433705395338736589120086871506362760060657440410056869674907314204346790554619655855805666327905912762300412323371126871463045993946331927129882715778396764969311565407104426500284824495461252591576672989633930916837016411523983491364869137945678029616541477271287052575817523864089061675401543733151180624855361245733039022140321494471318934716652758163593956711915212195328671373739342124211743835858897895276513396783328942978903764790088495033176253777832808572717335076829539988337505582696026111326821783912902713222712310343791755341823415393931813610365987465739339849380173805882522026704474308541271732478035913770922189429089852921985416202844838873352090355685075965831663443962706473737852392107876993485163981653038588544562512597409585410384189546449890975409183661424334789750460016306977673969147</span>

<span class="n">estimate</span> <span class="o">=</span> <span class="n">gmpy2</span><span class="p">.</span><span class="n">iroot</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="mi">3</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">10000</span> <span class="c1"># rough guess for the smallest prime
</span><span class="n">prime</span> <span class="o">=</span> <span class="n">gmpy2</span><span class="p">.</span><span class="n">next_prime</span><span class="p">(</span><span class="n">estimate</span><span class="p">)</span>

<span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">512</span><span class="p">):</span>
    <span class="n">prime</span> <span class="o">=</span> <span class="n">gmpy2</span><span class="p">.</span><span class="n">next_prime</span><span class="p">(</span><span class="n">prime</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">n</span><span class="o">%</span><span class="n">prime</span> <span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">prime</span><span class="p">)</span>

<span class="n">p</span> <span class="o">=</span> <span class="mi">139926822890670655977195962770726941986198973494425759476822219188316377933161673759394901805855617939978281385708941597117531007973713846772205166659227214187622925135931456526921198848312215276630974951050306344412865900075089120689559331322162952820292429725303619113876104177529039691490258588465409397803</span>
<span class="n">q</span> <span class="o">=</span> <span class="mi">139926822890670655977195962770726941986198973494425759476822219188316377933161673759394901805855617939978281385708941597117531007973713846772205166659227214187622925135931456526921198848312215276630974951050306344412865900075089120689559331322162952820292429725303619113876104177529039691490258588465409494847</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">n</span><span class="o">//</span><span class="p">(</span><span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="n">phi</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">d</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">m</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]).</span><span class="n">decode</span><span class="p">())</span>
</code></pre></div></div>

<h3 id="flagpr1m3_pr0x1m1ty_c4n_b3_v3ry_d4ng3r0u5">flag{pr1m3_pr0x1m1ty_c4n_b3_v3ry_d4ng3r0u5}</h3>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="redpwn" /><category term="2020" /><category term="cryptography" /><category term="rsa" /><category term="close_primes" /><summary type="html"><![CDATA[Primitity Description People claim that RSA with two 1024-bit primes is secure. But I trust no one. That's why I use three 1024-bit primes. I even created my own prime generator to be extra cautious! Files primimity.py primimity-public-key.txt Lets take a look at source primimity.py #!/usr/bin/env python3 from Crypto.Util.number import getRandomNBitInteger, isPrime def find_next_prime(n): if n &lt;= 1: return 2 elif n == 2: return 3 else: if n % 2 == 0: n += 1 else: n += 2 while not isPrime(n): n += 2 return n def prime_gen(): i = getRandomNBitInteger(1024) d = getRandomNBitInteger(8) for _ in range(d): i = find_next_prime(i) p = find_next_prime(i) d = getRandomNBitInteger(8) for _ in range(d): i = find_next_prime(i) q = find_next_prime(i) d = getRandomNBitInteger(8) for _ in range(d): i = find_next_prime(i) r = find_next_prime(i) return (p,q,r) def main(): (p,q,r) = prime_gen() print(p) print(q) print(r) if __name__ == '__main__': main() As one could observe, its yet another RSA with 3 primes instead of two. The twist with the prime generation prime_gen is that it doesnt generate three independent random primes, but it generates a random prime p, then generates picks two random primes q and r randomly within the proximity (next 256 primes max) of p. How does this information help? Cuberoot of n would serve as an approximation for r, from which we can traverse back (previous primes), till we get the prime factors of n Instead of implementing previous_prime (lazy me), one could easily subtract some number so that the initial estimate is smaller than p and we could easily use gmpy2.next_prime :p import gmpy2 n = 2739699434633097765008468371124644741923408864896396205946954196101304653772173210372608955799251139999322976228678445908704975780068946332615022064030241384638601426716056067126300711933438732265846838735860353259574129074615298010047322960704972157930663061480726566962254887144927753449042590678730779046154516549667611603792754880414526688217305247008627664864637891883902537649625488225238118503996674292057904635593729208703096877231276911845233833770015093213639131244386867600956112884383105437861665666273910566732634878464610789895607273567372933766243229798663389032807187003756226177111720510187664096691560511459141773632683383938152396711991246874813205614169161561906148974478519987935950318569760474249427787310865749167740917232799538099494710964837536211535351200520324575676987080484141561336505103872809932354748531675934527453231255132361489570816639925234935907741385330442961877410196615649696508210921 e = 65537 c = 2082926013138674164997791605512226759362824531322433048281306983526001801581956788909408046338065370689701410862433705395338736589120086871506362760060657440410056869674907314204346790554619655855805666327905912762300412323371126871463045993946331927129882715778396764969311565407104426500284824495461252591576672989633930916837016411523983491364869137945678029616541477271287052575817523864089061675401543733151180624855361245733039022140321494471318934716652758163593956711915212195328671373739342124211743835858897895276513396783328942978903764790088495033176253777832808572717335076829539988337505582696026111326821783912902713222712310343791755341823415393931813610365987465739339849380173805882522026704474308541271732478035913770922189429089852921985416202844838873352090355685075965831663443962706473737852392107876993485163981653038588544562512597409585410384189546449890975409183661424334789750460016306977673969147 estimate = gmpy2.iroot(n,3)[0] - 10000 # rough guess for the smallest prime prime = gmpy2.next_prime(estimate) for _ in range(512): prime = gmpy2.next_prime(prime) if n%prime ==0: print(prime) p = 139926822890670655977195962770726941986198973494425759476822219188316377933161673759394901805855617939978281385708941597117531007973713846772205166659227214187622925135931456526921198848312215276630974951050306344412865900075089120689559331322162952820292429725303619113876104177529039691490258588465409397803 q = 139926822890670655977195962770726941986198973494425759476822219188316377933161673759394901805855617939978281385708941597117531007973713846772205166659227214187622925135931456526921198848312215276630974951050306344412865900075089120689559331322162952820292429725303619113876104177529039691490258588465409494847 r = n//(p*q) phi = (p-1)*(q-1)*(r-1) d = pow(e, -1, phi) m = pow(c, d, n) print(bytes.fromhex(hex(m)[2:]).decode()) flag{pr1m3_pr0x1m1ty_c4n_b3_v3ry_d4ng3r0u5}]]></summary></entry><entry><title type="html">Redpwn 2020 Crypto - Pseudo-key</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/pseudo-key/2020-06-27-redpwn-2020-pseudo-key" rel="alternate" type="text/html" title="Redpwn 2020 Crypto - Pseudo-key" /><published>2020-06-27T00:00:00+05:30</published><updated>2020-06-27T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/pseudo-key/redpwn-2020-pseudo-key</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/pseudo-key/2020-06-27-redpwn-2020-pseudo-key"><![CDATA[<h1 id="pseudo-key">Pseudo key</h1>

<h2 id="description">Description</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Keys are not always as they seem...
Note: Make sure to wrap the plaintext with flag{} before you submit!
</code></pre></div></div>

<h2 id="files">Files</h2>
<ul>
  <li><a href="pseudo-key-output.txt">pseudo-key-output.txt</a></li>
  <li><a href="pseudo-key.py">pseudo-key.py</a></li>
</ul>

<p>Lets take a quick look at the contents of <a href="pseudo-key.py">pseudo-key.py</a></p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python3
</span>
<span class="kn">from</span> <span class="nn">string</span> <span class="kn">import</span> <span class="n">ascii_lowercase</span>

<span class="n">chr_to_num</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ascii_lowercase</span><span class="p">)}</span>
<span class="n">num_to_chr</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">c</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ascii_lowercase</span><span class="p">)}</span>

<span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">ptxt</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="n">ptxt</span> <span class="o">=</span> <span class="n">ptxt</span><span class="p">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">key</span> <span class="o">=</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">i</span> <span class="o">%</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ptxt</span><span class="p">))).</span><span class="n">lower</span><span class="p">()</span>
    <span class="n">ctxt</span> <span class="o">=</span> <span class="s">''</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ptxt</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">ptxt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s">'_'</span><span class="p">:</span>
            <span class="n">ctxt</span> <span class="o">+=</span> <span class="s">'_'</span>
            <span class="k">continue</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">chr_to_num</span><span class="p">[</span><span class="n">ptxt</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">chr_to_num</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
        <span class="n">ctxt</span> <span class="o">+=</span> <span class="n">num_to_chr</span><span class="p">[(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span> <span class="o">%</span> <span class="mi">26</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">ctxt</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'flag.txt'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">,</span> <span class="nb">open</span><span class="p">(</span><span class="s">'key.txt'</span><span class="p">)</span> <span class="k">as</span> <span class="n">k</span><span class="p">:</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">k</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">ptxt</span> <span class="o">=</span> <span class="n">flag</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="n">ctxt</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">ptxt</span><span class="p">,</span><span class="n">key</span><span class="p">)</span>
<span class="n">pseudo_key</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key</span><span class="p">,</span><span class="n">key</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">'Ciphertext:'</span><span class="p">,</span><span class="n">ctxt</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">'Pseudo-key:'</span><span class="p">,</span><span class="n">pseudo_key</span><span class="p">)</span>
</code></pre></div></div>

<p>Encryption is just vignere cipher over ASCII-lower with a given key.</p>
<blockquote>
  <p>NOTE: underscores are skipped and added as such</p>
</blockquote>

<p>But whats the challenge here?<br />
The key is encrypted with the key itself and we are provided the encrypted key (called Pseudo-key) <code class="language-plaintext highlighter-rouge">iigesssaemk</code></p>

<p>Treating the alphabets as numbers from <code class="language-plaintext highlighter-rouge">0-26</code></p>

\[ciphertext_i = plaintext_i + key_i \mod 26\]

<p>Where \(key_i\) essentially suggests that \(key\) is duplicated again and again to match the $plaintext$ length<br />
And hence, if we encrypt the $key$ with \(key\) itself, we get,</p>

\[pseudoKey_i = key_i + key_i \mod 26\]

\[pseudoKey_i = 2key_i \mod 26\]

\[key_i = pseudoKey_i/2 \ {\text{or}}\  pseudoKey_i/2 + 13\]

<p>Since the length of \(pseudoKey\) is 11, we have \(2^{11} = 2048\) possibilities, which we could simply go through and check if we get a valid flag</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="n">ct</span> <span class="o">=</span> <span class="s">"z_jjaoo_rljlhr_gauf_twv_shaqzb_ljtyut"</span>
<span class="n">pseudo_key</span> <span class="o">=</span> <span class="s">"iigesssaemk"</span>

<span class="n">pseudo_key_to_num</span> <span class="o">=</span> <span class="p">[</span><span class="nb">ord</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-</span><span class="mi">97</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pseudo_key</span><span class="p">]</span>
<span class="n">possible_keys</span> <span class="o">=</span> <span class="p">[</span> <span class="p">(</span><span class="n">i</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">//</span><span class="mi">2</span><span class="o">+</span><span class="mi">13</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">pseudo_key_to_num</span> <span class="p">]</span>

<span class="n">ct_to_num</span> <span class="o">=</span> <span class="p">[</span><span class="nb">ord</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">-</span><span class="mi">97</span> <span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">97</span> <span class="k">else</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">ct</span> <span class="p">]</span>

<span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span><span class="n">key</span><span class="p">):</span>
    <span class="n">keylen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">return</span> <span class="s">""</span><span class="p">.</span><span class="n">join</span><span class="p">(</span> <span class="n">ct</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">ct</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">==</span><span class="s">'_'</span> <span class="k">else</span> <span class="nb">chr</span><span class="p">((</span><span class="n">ct</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="o">%</span><span class="n">keylen</span><span class="p">]</span> <span class="o">+</span><span class="mi">26</span><span class="p">)</span><span class="o">%</span><span class="mi">26</span> <span class="o">+</span><span class="mi">97</span> <span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ct</span><span class="p">))</span> <span class="p">)</span>


<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">possible_keys</span><span class="p">):</span>
    <span class="n">decrypted</span> <span class="o">=</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">ct_to_num</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">decrypted</span><span class="p">,</span> <span class="s">""</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">97</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">key</span> <span class="p">))</span>
</code></pre></div></div>

<p>Scrolling over the produced ciphertext, one could easily identify the correct flag</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...
i_guess_pfrudo_keyf_nee_pseudb_frcure redpwwwacgs
i_guess_pseudo_keyf_are_pseudb_secure redpwwwactf
i_guess_psrudo_keyf_aee_pseudb_srcure redpwwwacts
i_guess_cfeudo_keyf_nre_pseudb_fecure redpwwwapgf
i_guess_cfrudo_keyf_nee_pseudb_frcure redpwwwapgs
i_guess_cseudo_keyf_are_pseudb_secure redpwwwaptf
i_guess_csrudo_keyf_aee_pseudb_srcure redpwwwapts
i_guess_pfeudo_keys_nre_pseudo_fecure redpwwwncgf
i_guess_pfrudo_keys_nee_pseudo_frcure redpwwwncgs
i_guess_pseudo_keys_are_pseudo_secure redpwwwnctf
i_guess_psrudo_keys_aee_pseudo_srcure redpwwwncts
i_guess_cfeudo_keys_nre_pseudo_fecure redpwwwnpgf
i_guess_cfrudo_keys_nee_pseudo_frcure redpwwwnpgs
i_guess_cseudo_keys_are_pseudo_secure redpwwwnptf
i_guess_csrudo_keys_aee_pseudo_srcure redpwwwnpts
...
</code></pre></div></div>
<p>The key appears to be <code class="language-plaintext highlighter-rouge">redpwwwnctf</code></p>

<h3 id="flagi_guess_pseudo_keys_are_pseudo_secure">flag{i_guess_pseudo_keys_are_pseudo_secure}</h3>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="redpwn" /><category term="2020" /><category term="cryptography" /><category term="vignere" /><summary type="html"><![CDATA[Pseudo key Description Keys are not always as they seem... Note: Make sure to wrap the plaintext with flag{} before you submit! Files pseudo-key-output.txt pseudo-key.py Lets take a quick look at the contents of pseudo-key.py #!/usr/bin/env python3 from string import ascii_lowercase chr_to_num = {c: i for i, c in enumerate(ascii_lowercase)} num_to_chr = {i: c for i, c in enumerate(ascii_lowercase)} def encrypt(ptxt, key): ptxt = ptxt.lower() key = ''.join(key[i % len(key)] for i in range(len(ptxt))).lower() ctxt = '' for i in range(len(ptxt)): if ptxt[i] == '_': ctxt += '_' continue x = chr_to_num[ptxt[i]] y = chr_to_num[key[i]] ctxt += num_to_chr[(x + y) % 26] return ctxt with open('flag.txt') as f, open('key.txt') as k: flag = f.read() key = k.read() ptxt = flag[5:-1] ctxt = encrypt(ptxt,key) pseudo_key = encrypt(key,key) print('Ciphertext:',ctxt) print('Pseudo-key:',pseudo_key) Encryption is just vignere cipher over ASCII-lower with a given key. NOTE: underscores are skipped and added as such But whats the challenge here? The key is encrypted with the key itself and we are provided the encrypted key (called Pseudo-key) iigesssaemk Treating the alphabets as numbers from 0-26 \[ciphertext_i = plaintext_i + key_i \mod 26\] Where \(key_i\) essentially suggests that \(key\) is duplicated again and again to match the $plaintext$ length And hence, if we encrypt the $key$ with \(key\) itself, we get, \[pseudoKey_i = key_i + key_i \mod 26\] \[pseudoKey_i = 2key_i \mod 26\] \[key_i = pseudoKey_i/2 \ {\text{or}}\ pseudoKey_i/2 + 13\] Since the length of \(pseudoKey\) is 11, we have \(2^{11} = 2048\) possibilities, which we could simply go through and check if we get a valid flag from itertools import product ct = "z_jjaoo_rljlhr_gauf_twv_shaqzb_ljtyut" pseudo_key = "iigesssaemk" pseudo_key_to_num = [ord(i)-97 for i in pseudo_key] possible_keys = [ (i//2, i//2+13) for i in pseudo_key_to_num ] ct_to_num = [ord(i)-97 if ord(i) &gt;= 97 else i for i in ct ] def decrypt(ct,key): keylen = len(key) return "".join( ct[i] if str(ct[i])=='_' else chr((ct[i] - key[i%keylen] +26)%26 +97 ) for i in range(len(ct)) ) for key in product(*possible_keys): decrypted = decrypt(ct_to_num, key) print(decrypted, "".join(chr(i+97) for i in key )) Scrolling over the produced ciphertext, one could easily identify the correct flag ... i_guess_pfrudo_keyf_nee_pseudb_frcure redpwwwacgs i_guess_pseudo_keyf_are_pseudb_secure redpwwwactf i_guess_psrudo_keyf_aee_pseudb_srcure redpwwwacts i_guess_cfeudo_keyf_nre_pseudb_fecure redpwwwapgf i_guess_cfrudo_keyf_nee_pseudb_frcure redpwwwapgs i_guess_cseudo_keyf_are_pseudb_secure redpwwwaptf i_guess_csrudo_keyf_aee_pseudb_srcure redpwwwapts i_guess_pfeudo_keys_nre_pseudo_fecure redpwwwncgf i_guess_pfrudo_keys_nee_pseudo_frcure redpwwwncgs i_guess_pseudo_keys_are_pseudo_secure redpwwwnctf i_guess_psrudo_keys_aee_pseudo_srcure redpwwwncts i_guess_cfeudo_keys_nre_pseudo_fecure redpwwwnpgf i_guess_cfrudo_keys_nee_pseudo_frcure redpwwwnpgs i_guess_cseudo_keys_are_pseudo_secure redpwwwnptf i_guess_csrudo_keys_aee_pseudo_srcure redpwwwnpts ... The key appears to be redpwwwnctf flag{i_guess_pseudo_keys_are_pseudo_secure}]]></summary></entry><entry><title type="html">Redpwn 2020 Crypto - worst_pw_manager</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/worst-pw-manager/2020-06-27-redpwn-2020-worst-pw-manager" rel="alternate" type="text/html" title="Redpwn 2020 Crypto - worst_pw_manager" /><published>2020-06-27T00:00:00+05:30</published><updated>2020-06-27T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/worst-pw-manager/redpwn-2020-worst-pw-manager</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/redpwn/crypto/worst-pw-manager/2020-06-27-redpwn-2020-worst-pw-manager"><![CDATA[<h1 id="worst-pw-manager">worst-pw-manager</h1>

<h2 id="description">Description</h2>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>I found this in-progress password manager on a dead company's website. Seems neat.
</code></pre></div></div>

<h2 id="files">Files</h2>
<ul>
  <li><a href="worst-pw-manager.zip">worst-pw-manager.zip</a>
    <ul>
      <li><a href="worst-pw-manager/worst_pw_manager.py">worst-pw-manager/worst-pw-manager.py</a></li>
      <li><a href="worst-pw-manager/passwords">worst-pw-manager/passwords/</a>
        <ul>
          <li><a href="worst-pw-manager/passwords/0_135791.enc">worst-pw-manager/passwords/0_135791.enc</a></li>
          <li>…</li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h2 id="worst-pw-managerpy-workings">worst-pw-manager.py workings</h2>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">main</span><span class="p">(</span><span class="n">args</span><span class="p">):</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"usage: python {} [import|export|microwave_hdd]"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">return</span>

    <span class="k">if</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s">"import"</span><span class="p">:</span>
        <span class="n">pathlib</span><span class="p">.</span><span class="n">Path</span><span class="p">(</span><span class="s">"./passwords"</span><span class="p">).</span><span class="n">mkdir</span><span class="p">(</span><span class="n">exist_ok</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Importing from passwords.txt. Please wait..."</span><span class="p">)</span>
        <span class="n">passwords</span> <span class="o">=</span> <span class="nb">open</span><span class="p">(</span><span class="s">"passwords.txt"</span><span class="p">).</span><span class="n">read</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">pw_idx</span><span class="p">,</span> <span class="n">password</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">passwords</span><span class="p">.</span><span class="n">splitlines</span><span class="p">()):</span>
            <span class="c1"># 100% completely secure file name generation method
</span>            <span class="n">masked_file_name</span> <span class="o">=</span> <span class="s">""</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="nb">chr</span><span class="p">((((</span><span class="n">c</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"0"</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">10</span><span class="p">)</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"0"</span><span class="p">))</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">string</span><span class="p">.</span><span class="n">ascii_lowercase</span><span class="p">)</span> <span class="o">+</span> <span class="p">(((</span><span class="n">c</span> <span class="o">-</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">%</span> <span class="mi">26</span><span class="p">)</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">))</span> <span class="o">*</span> <span class="nb">int</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="ow">in</span> <span class="n">string</span><span class="p">.</span><span class="n">ascii_lowercase</span><span class="p">))</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="nb">ord</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">password</span><span class="p">],</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0xffff</span><span class="p">))])</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">"passwords/"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">pw_idx</span><span class="p">)</span> <span class="o">+</span> <span class="s">"_"</span> <span class="o">+</span> <span class="n">masked_file_name</span> <span class="o">+</span> <span class="s">".enc"</span><span class="p">,</span> <span class="s">"wb"</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">f</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">rc4</span><span class="p">(</span><span class="n">password</span><span class="p">,</span> <span class="n">generate_key</span><span class="p">()))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Import complete! Passwords securely stored on disk with your private key in flag.txt! You may now safely delete flag.txt."</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"This feature is not implemented. Check back in a later update."</span><span class="p">)</span>
</code></pre></div></div>

<p>Only import functionality is implemented, which is broken in the sense that the encrypted password is stored in the file whose name is just a cipher of the password XD<br />
The complicating looking <code class="language-plaintext highlighter-rouge">masked_file_name</code> is nothing just a shift cipher by shift <code class="language-plaintext highlighter-rouge">i</code> at <code class="language-plaintext highlighter-rouge">i</code>th index.<br />
if the character at index <code class="language-plaintext highlighter-rouge">i</code> is a digit, <code class="language-plaintext highlighter-rouge">i</code> is added to it modulo 10<br />
else if the character is a alphabet, it is shifted by <code class="language-plaintext highlighter-rouge">i</code> modulo 26</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">decode_filename</span><span class="p">(</span><span class="n">file_name</span><span class="p">):</span>
    <span class="n">num</span><span class="p">,</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">file_name</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'_'</span><span class="p">)</span>
    <span class="n">file_mask</span> <span class="o">=</span> <span class="n">mask</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'.enc'</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">password</span> <span class="o">=</span> <span class="s">""</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">file_mask</span><span class="p">)):</span>
        <span class="n">char</span> <span class="o">=</span> <span class="n">file_mask</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">char</span><span class="p">.</span><span class="n">isdigit</span><span class="p">():</span>
            <span class="n">password</span><span class="o">+=</span><span class="nb">chr</span><span class="p">(</span> <span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">char</span><span class="p">)</span><span class="o">-</span><span class="nb">ord</span><span class="p">(</span><span class="s">"0"</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">10</span><span class="p">)</span><span class="o">%</span><span class="mi">10</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="s">'0'</span><span class="p">)</span>  <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">password</span><span class="o">+=</span><span class="nb">chr</span><span class="p">(</span> <span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">char</span><span class="p">)</span><span class="o">-</span><span class="nb">ord</span><span class="p">(</span><span class="s">"a"</span><span class="p">)</span><span class="o">-</span><span class="n">i</span><span class="o">+</span><span class="mi">26</span><span class="p">)</span><span class="o">%</span><span class="mi">26</span> <span class="o">+</span> <span class="nb">ord</span><span class="p">(</span><span class="s">'a'</span><span class="p">)</span>  <span class="p">)</span>
    <span class="k">return</span> <span class="n">password</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">num</span><span class="p">)</span>
</code></pre></div></div>
<p>Lets just get all the password, and encrypted password pairs</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_passwords</span><span class="p">():</span>
    <span class="n">p_ct_list</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">file_name</span> <span class="ow">in</span> <span class="n">os</span><span class="p">.</span><span class="n">listdir</span><span class="p">(</span><span class="s">'worst-pw-manager/passwords'</span><span class="p">):</span>
        <span class="n">password</span><span class="p">,</span> <span class="n">num</span> <span class="o">=</span> <span class="n">decode_filename</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'worst-pw-manager/passwords/'</span><span class="o">+</span><span class="n">file_name</span><span class="p">,</span><span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">enc_file</span><span class="p">:</span>
            <span class="n">encrypted</span> <span class="o">=</span> <span class="n">enc_file</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">p_ct_list</span><span class="p">.</span><span class="n">append</span><span class="p">([</span><span class="n">num</span><span class="p">,</span><span class="n">password</span><span class="p">,</span><span class="n">encrypted</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">p_ct_list</span>
</code></pre></div></div>

<p>Now the real challenge is to recover the key from plaintext/ciphertext pairs.<br />
The key is <code class="language-plaintext highlighter-rouge">cycle(flag_characters)</code> which means 8 characters of the flag are taken at a time, looping again to start once the flag ends.</p>

<p>This got me into rabbit holes searching for known plaintext key recovery attacks on rc4. After googling a bit, I tried bruteforce on the key since the key is only 8 bytes and the key used to encrypt first block would contain the prefix <code class="language-plaintext highlighter-rouge">flag{</code>, which makes it only 3 bytes to bruteforce. One could extend this stratergy to get key bytes over and over once since somewhere the next 5 characters would be prefix to some 8 byte key block.</p>

<p>Later did I notice that the key generation was buggy</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">generate_key</span><span class="p">():</span>
    <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">KeyByteHolder</span><span class="p">(</span><span class="mi">0</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">8</span> <span class="c1"># TODO: increase key length for more security?
</span>    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">take</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="mi">8</span><span class="p">)):</span> <span class="c1"># use top secret master password to encrypt all passwords
</span>        <span class="n">key</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">num</span> <span class="o">=</span> <span class="n">c</span>
    <span class="k">return</span> <span class="n">key</span>
</code></pre></div></div>
<p><code class="language-plaintext highlighter-rouge">[KeyByteHolder(0)] * </code> just simply creates an instance <code class="language-plaintext highlighter-rouge">KeyByteHolder(0)</code> and generates 8 references to it. The correct way would have been <code class="language-plaintext highlighter-rouge">[KeyByteHolder(0) for _ in range(8)]</code>.<br />
Given this fact, all the key bytes are actually the last byte repeated 8 times (because of the last assignment)</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bruteforce_keylast</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span><span class="n">ct</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">):</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">)])</span>
        <span class="k">if</span> <span class="n">rc4</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">ct</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">i</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">get_passwords</span><span class="p">()</span>
<span class="n">data</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">eighth_chars</span> <span class="o">=</span> <span class="p">[(</span><span class="n">ind</span><span class="p">,</span><span class="n">bruteforce_keylast</span><span class="p">(</span><span class="n">pt</span><span class="p">,</span><span class="n">ct</span><span class="p">))</span> <span class="k">for</span> <span class="n">ind</span><span class="p">,</span><span class="n">pt</span><span class="p">,</span><span class="n">ct</span> <span class="ow">in</span> <span class="n">data</span> <span class="p">]</span>
</code></pre></div></div>
<p>And we get a list somehwhat</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>['y', 's', 'n', 'n', 'l', 't', 'u', '_', 'i', 'd', 'r', '_', 'a', 'o', 'u', 'g', '_', 'i', 'y', '_', 'f', 'p', 't', 'd', '_', 'i', 'c', 's', '_', 'h', 't', 'a', 'o', 'p', 'i', 'd', 'r', '_', 'a', 'o', 'u', 'g', '_', 'i', 'y', '_', 'f', 'p', 't', 'd', '_', 'i', 'c', 's', '_', 'h', 't', 'a', 'o', 'p', 'p', 's', '}', 'y', 's', 'n', 'n', 'p', '{', 'i', 'd', 't', 's', 'l', 't', 'u', '_', 'i', 'd', 'r', '_', 'a', 'o', 'u', 'g', '_', 'i', 'y', '_', 'f', 'p', 't', 'd', '_', 'i', 'c', 's', '_', 'h', 't', 'a', 'o', 'p', 'p', 's', '}', 'y', 's', 'n', 'n', 'p', '{', 'i', 'd', 't', 's', 'l', 't', 'u', '_', 'i', 'd', 'r', '_', 'a', 'o', 'u', 'g', '_', 'i', 'y', '_', 'f', 'p', 't', 'd', '_', 'i', 'c', 's', '_', 'h', 't', 'a', 'o', 'p', 'p', 's', '}', 'y', 's', 'n', 'n', 'p', '{', 'i', 'd', 't', 's', 'l', 't', 'u', '_', 'i', 'd', 'r', '_', 'a', 'o', 'u', 'g', '_', 'i', 'y', '_', 'f', 'p', 't', 'd', '_', 'i', 'c', 's', '_', 'h', 't', 'a', 'o', 'p', 'p', 's', '}', 'y', 's', 'n', 'n', 'p', '{', 'i', 'd', 't', 's', 'l', 't', 'u', '_', 'i', 'd', 'r', '_', 'a', 'o', 'u', 'g', '_', 'i', 'y', '_', 'f', 'p', 't', 'd', '_', 'i', 'c', 's', '_', 'h', 't', 'a', 'o', 'p', 'p', 's', '}', 'y', 's', 'n', 'n', 'p', '{', 'i', 'd', 't', 's', 'l', 't', 'u', '_', 'i', 'd', 'r', '_', 'a', 'o', 'u', 'g', '_', 'i', 'y', '_', 'f', 'p', 't', 'd', '_', 'i', 'c', 's', '_', 'h', 't', 'a', 'o', 'p', 'p', 's', '}', 'y', 's', 'n', 'n', 'p', '{', 'i', 'd', 't', 's', 'l', 't', 'u', '_', 'i', 'd', 'r', '_', 'a', 'o', 'u', 'g', '_', 'i', 'y', '_', 'f', 'p', 't', 'd', '_', 'i', 'c', 's', '_', 'h', 't', 'a', 'o', 'p', 'p', 's', '}', 'y', 's', 'n', 'n', 'p', '{', 'i', 'd', 't', 's', 'l', 't', 'u', '_', 'i', 'd', 'r', '_', 'a', 'o', 'u', 'g']
</code></pre></div></div>
<p>Which is the list over eighth characters modulo the flag length, which is yet unknown.<br />
All we need to do is loop over the possible flag lengths and check if it contains <code class="language-plaintext highlighter-rouge">flag</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">flag_len</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span><span class="mi">50</span><span class="p">):</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">flag_len</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ind</span><span class="p">,</span><span class="n">key_char</span> <span class="ow">in</span> <span class="n">eighth_chars</span><span class="p">:</span> <span class="c1">#index number specified by the index of password file
</span>        <span class="n">starting_ind</span> <span class="o">=</span> <span class="p">(</span><span class="n">ind</span><span class="o">*</span><span class="mi">8</span><span class="p">)</span><span class="o">%</span><span class="n">flag_len</span> <span class="c1">#starting index of password string
</span>        <span class="n">flag</span><span class="p">[(</span><span class="n">starting_ind</span><span class="o">+</span><span class="mi">8</span><span class="p">)</span><span class="o">%</span><span class="n">flag_len</span><span class="p">]</span> <span class="o">=</span> <span class="n">key_char</span> <span class="c1">#found password
</span>    <span class="k">if</span> <span class="sa">b</span><span class="s">'flag'</span> <span class="ow">in</span> <span class="n">flag</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">flag</span><span class="p">.</span><span class="n">decode</span><span class="p">())</span>
        <span class="k">break</span>
</code></pre></div></div>

<h3 id="flagcrypto_is_stupid_and_python_is_stupid">flag{crypto_is_stupid_and_python_is_stupid}</h3>

<p>Yet another fun challenge! Good job redpwn guys!</p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="redpwn" /><category term="2020" /><category term="cryptography" /><category term="xor" /><category term="rc4" /><summary type="html"><![CDATA[worst-pw-manager Description I found this in-progress password manager on a dead company's website. Seems neat. Files worst-pw-manager.zip worst-pw-manager/worst-pw-manager.py worst-pw-manager/passwords/ worst-pw-manager/passwords/0_135791.enc … worst-pw-manager.py workings def main(args): if len(args) != 2: print("usage: python {} [import|export|microwave_hdd]".format(args[0])) return if args[1] == "import": pathlib.Path("./passwords").mkdir(exist_ok=True) print("Importing from passwords.txt. Please wait...") passwords = open("passwords.txt").read() for pw_idx, password in enumerate(passwords.splitlines()): # 100% completely secure file name generation method masked_file_name = "".join([chr((((c - ord("0") + i) % 10) + ord("0")) * int(chr(c) not in string.ascii_lowercase) + (((c - ord("a") + i) % 26) + ord("a")) * int(chr(c) in string.ascii_lowercase)) for c, i in zip([ord(a) for a in password], range(0xffff))]) with open("passwords/" + str(pw_idx) + "_" + masked_file_name + ".enc", "wb") as f: f.write(rc4(password, generate_key())) print("Import complete! Passwords securely stored on disk with your private key in flag.txt! You may now safely delete flag.txt.") else: print("This feature is not implemented. Check back in a later update.") Only import functionality is implemented, which is broken in the sense that the encrypted password is stored in the file whose name is just a cipher of the password XD The complicating looking masked_file_name is nothing just a shift cipher by shift i at ith index. if the character at index i is a digit, i is added to it modulo 10 else if the character is a alphabet, it is shifted by i modulo 26 def decode_filename(file_name): num, mask = file_name.split('_') file_mask = mask.split('.enc')[0] password = "" for i in range(len(file_mask)): char = file_mask[i] if char.isdigit(): password+=chr( (ord(char)-ord("0")-i+10)%10 + ord('0') ) else: password+=chr( (ord(char)-ord("a")-i+26)%26 + ord('a') ) return password,int(num) Lets just get all the password, and encrypted password pairs def get_passwords(): p_ct_list = [] for file_name in os.listdir('worst-pw-manager/passwords'): password, num = decode_filename(file_name) with open('worst-pw-manager/passwords/'+file_name,'rb') as enc_file: encrypted = enc_file.read() p_ct_list.append([num,password,encrypted]) return p_ct_list Now the real challenge is to recover the key from plaintext/ciphertext pairs. The key is cycle(flag_characters) which means 8 characters of the flag are taken at a time, looping again to start once the flag ends. This got me into rabbit holes searching for known plaintext key recovery attacks on rc4. After googling a bit, I tried bruteforce on the key since the key is only 8 bytes and the key used to encrypt first block would contain the prefix flag{, which makes it only 3 bytes to bruteforce. One could extend this stratergy to get key bytes over and over once since somewhere the next 5 characters would be prefix to some 8 byte key block. Later did I notice that the key generation was buggy def generate_key(): key = [KeyByteHolder(0)] * 8 # TODO: increase key length for more security? for i, c in enumerate(take(flag, 8)): # use top secret master password to encrypt all passwords key[i].num = c return key [KeyByteHolder(0)] * just simply creates an instance KeyByteHolder(0) and generates 8 references to it. The correct way would have been [KeyByteHolder(0) for _ in range(8)]. Given this fact, all the key bytes are actually the last byte repeated 8 times (because of the last assignment) def bruteforce_keylast(pt,ct): for i in range(256): key = bytearray([i for _ in range(8)]) if rc4(pt,key) == ct: return i data = get_passwords() data = sorted(data, key = lambda x:x[0]) eighth_chars = [(ind,bruteforce_keylast(pt,ct)) for ind,pt,ct in data ] And we get a list somehwhat ['y', 's', 'n', 'n', 'l', 't', 'u', '_', 'i', 'd', 'r', '_', 'a', 'o', 'u', 'g', '_', 'i', 'y', '_', 'f', 'p', 't', 'd', '_', 'i', 'c', 's', '_', 'h', 't', 'a', 'o', 'p', 'i', 'd', 'r', '_', 'a', 'o', 'u', 'g', '_', 'i', 'y', '_', 'f', 'p', 't', 'd', '_', 'i', 'c', 's', '_', 'h', 't', 'a', 'o', 'p', 'p', 's', '}', 'y', 's', 'n', 'n', 'p', '{', 'i', 'd', 't', 's', 'l', 't', 'u', '_', 'i', 'd', 'r', '_', 'a', 'o', 'u', 'g', '_', 'i', 'y', '_', 'f', 'p', 't', 'd', '_', 'i', 'c', 's', '_', 'h', 't', 'a', 'o', 'p', 'p', 's', '}', 'y', 's', 'n', 'n', 'p', '{', 'i', 'd', 't', 's', 'l', 't', 'u', '_', 'i', 'd', 'r', '_', 'a', 'o', 'u', 'g', '_', 'i', 'y', '_', 'f', 'p', 't', 'd', '_', 'i', 'c', 's', '_', 'h', 't', 'a', 'o', 'p', 'p', 's', '}', 'y', 's', 'n', 'n', 'p', '{', 'i', 'd', 't', 's', 'l', 't', 'u', '_', 'i', 'd', 'r', '_', 'a', 'o', 'u', 'g', '_', 'i', 'y', '_', 'f', 'p', 't', 'd', '_', 'i', 'c', 's', '_', 'h', 't', 'a', 'o', 'p', 'p', 's', '}', 'y', 's', 'n', 'n', 'p', '{', 'i', 'd', 't', 's', 'l', 't', 'u', '_', 'i', 'd', 'r', '_', 'a', 'o', 'u', 'g', '_', 'i', 'y', '_', 'f', 'p', 't', 'd', '_', 'i', 'c', 's', '_', 'h', 't', 'a', 'o', 'p', 'p', 's', '}', 'y', 's', 'n', 'n', 'p', '{', 'i', 'd', 't', 's', 'l', 't', 'u', '_', 'i', 'd', 'r', '_', 'a', 'o', 'u', 'g', '_', 'i', 'y', '_', 'f', 'p', 't', 'd', '_', 'i', 'c', 's', '_', 'h', 't', 'a', 'o', 'p', 'p', 's', '}', 'y', 's', 'n', 'n', 'p', '{', 'i', 'd', 't', 's', 'l', 't', 'u', '_', 'i', 'd', 'r', '_', 'a', 'o', 'u', 'g', '_', 'i', 'y', '_', 'f', 'p', 't', 'd', '_', 'i', 'c', 's', '_', 'h', 't', 'a', 'o', 'p', 'p', 's', '}', 'y', 's', 'n', 'n', 'p', '{', 'i', 'd', 't', 's', 'l', 't', 'u', '_', 'i', 'd', 'r', '_', 'a', 'o', 'u', 'g'] Which is the list over eighth characters modulo the flag length, which is yet unknown. All we need to do is loop over the possible flag lengths and check if it contains flag for flag_len in range(9,50): flag = bytearray(flag_len) for ind,key_char in eighth_chars: #index number specified by the index of password file starting_ind = (ind*8)%flag_len #starting index of password string flag[(starting_ind+8)%flag_len] = key_char #found password if b'flag' in flag: print(flag.decode()) break flag{crypto_is_stupid_and_python_is_stupid} Yet another fun challenge! Good job redpwn guys!]]></summary></entry><entry><title type="html">Nahamcon 2020 Crypto - December</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/December/2020-06-14-Nahamcon-2020-December" rel="alternate" type="text/html" title="Nahamcon 2020 Crypto - December" /><published>2020-06-14T00:00:00+05:30</published><updated>2020-06-14T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/December/Nahamcon-2020-December</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/nahamconCTF/crypto/December/2020-06-14-Nahamcon-2020-December"><![CDATA[<h1 id="december">December</h1>

<p><img src="Capture.PNG" alt="" /></p>

<p>We are provided with <a href="source.py">source.py</a>, which reads</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python
</span>
<span class="kn">from</span> <span class="nn">Crypto.Cipher</span> <span class="kn">import</span> <span class="n">DES</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'flag.txt'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="n">handle</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">padding_size</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">8</span> <span class="o">-</span> <span class="p">(</span> <span class="nb">len</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span> <span class="o">%</span> <span class="mi">8</span> <span class="p">))</span>
<span class="n">flag</span> <span class="o">=</span> <span class="n">flag</span><span class="p">.</span><span class="n">ljust</span><span class="p">(</span><span class="n">padding_size</span><span class="p">,</span> <span class="sa">b</span><span class="s">'</span><span class="se">\x00</span><span class="s">'</span><span class="p">)</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'key'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">handle</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">strip</span><span class="p">()</span>

<span class="n">iv</span> <span class="o">=</span> <span class="s">"13371337"</span>
<span class="n">des</span> <span class="o">=</span> <span class="n">DES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">DES</span><span class="p">.</span><span class="n">MODE_OFB</span><span class="p">,</span> <span class="n">iv</span><span class="p">)</span>
<span class="n">ct</span> <span class="o">=</span> <span class="n">des</span><span class="p">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'ciphertext'</span><span class="p">,</span><span class="s">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">handle</span><span class="p">:</span>
        <span class="n">handle</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>
</code></pre></div></div>

<p>And a binary <a href="ciphertext">ciphertext</a></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>00000000: d6a2 6fe5 c75c 22e0 5413 5e4e 1140 5d58  ..o..\".T.^N.@]X
00000010: f5ea 69f9 d419 31f7 5513 5745 5452 5e44  ..i...1.U.WETR^D
00000020: 889e 62ff d15c 2ae1 115e 5617 4141 5643  ..b..\*..^V.AAVC
00000030: e7a4 6eff cc1b 49f4 5d52 544c 455b 5a44  ..n...I.]RTLE[ZD
00000040: dda3 79c9 c310 2fcd 586c 5d52 5457 4e37  ..y.../.Xl]RTWN7
</code></pre></div></div>
<p>Which is quite unusual in the sense that most of it is readable in unusual sizes of <code class="language-plaintext highlighter-rouge">8</code>.<br />
This could be another instance of <a href="https://en.wikipedia.org/wiki/Weak_key#Weak_keys_in_DES">Weak keys</a><br />
Lets quickly run through the 4 weak keys</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">m</span> <span class="n">Crypto</span><span class="p">.</span><span class="n">Cipher</span> <span class="kn">import</span> <span class="nn">DES</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'ciphertext'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">ct_file</span><span class="p">:</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="n">ct_file</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

<span class="n">weak_keys</span> <span class="o">=</span> <span class="p">[</span>
    <span class="sa">b</span><span class="s">'</span><span class="se">\x01\x01\x01\x01\x01\x01\x01\x01</span><span class="s">'</span><span class="p">,</span>
    <span class="sa">b</span><span class="s">'</span><span class="se">\xFE\xFE\xFE\xFE\xFE\xFE\xFE\xFE</span><span class="s">'</span><span class="p">,</span>
    <span class="sa">b</span><span class="s">'</span><span class="se">\xE0\xE0\xE0\xE0\xF1\xF1\xF1\xF1</span><span class="s">'</span><span class="p">,</span>
    <span class="sa">b</span><span class="s">'</span><span class="se">\x1F\x1F\x1F\x1F\x0E\x0E\x0E\x0E</span><span class="s">'</span>
<span class="p">]</span>

<span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">weak_keys</span><span class="p">:</span>
    <span class="n">iv</span> <span class="o">=</span> <span class="sa">b</span><span class="s">"13371337"</span>
    <span class="n">des</span> <span class="o">=</span> <span class="n">DES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">DES</span><span class="p">.</span><span class="n">MODE_OFB</span><span class="p">,</span> <span class="n">iv</span><span class="p">)</span>
    <span class="n">pt</span> <span class="o">=</span> <span class="n">des</span><span class="p">.</span><span class="n">decrypt</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
</code></pre></div></div>

<p>Which produces the plaintexts</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="sa">b</span><span class="s">'</span><span class="se">\xaf\xe0\xda\x8c</span><span class="s">=</span><span class="se">\xed</span><span class="s">G</span><span class="se">\xe4</span><span class="s">e my sno</span><span class="se">\x8c\xa8\xdc\x90</span><span class="s">.</span><span class="se">\xa8</span><span class="s">T</span><span class="se">\xf3</span><span class="s">d dreams</span><span class="se">\xf1\xdc\xd7\x96</span><span class="s">+</span><span class="se">\xed</span><span class="s">O</span><span class="se">\xe5</span><span class="s"> me pret</span><span class="se">\x9e\xe6\xdb\x96</span><span class="s">6</span><span class="se">\xaa</span><span class="s">,</span><span class="se">\xf0</span><span class="s">lag{this</span><span class="se">\xa4\xe1\xcc\xa0</span><span class="s">9</span><span class="se">\xa1</span><span class="s">J</span><span class="se">\xc9</span><span class="s">i_need}</span><span class="se">\x00</span><span class="s">'</span>
<span class="sa">b</span><span class="s">'</span><span class="se">\xb8</span><span class="s">(</span><span class="se">\xff\x82\xb0</span><span class="s">)</span><span class="se">\x06</span><span class="s">$e my sno</span><span class="se">\x9b</span><span class="s">`</span><span class="se">\xf9\x9e\xa3</span><span class="s">l</span><span class="se">\x15</span><span class="s">3d dreams</span><span class="se">\xe6\x14\xf2\x98\xa6</span><span class="s">)</span><span class="se">\x0e</span><span class="s">% me pret</span><span class="se">\x89</span><span class="s">.</span><span class="se">\xfe\x98\xbb</span><span class="s">nm0lag{this</span><span class="se">\xb3</span><span class="s">)</span><span class="se">\xe9\xae\xb4</span><span class="s">e</span><span class="se">\x0b\t</span><span class="s">i_need}</span><span class="se">\x00</span><span class="s">'</span>
<span class="sa">b</span><span class="s">'c</span><span class="se">\xad\xc7\x9d</span><span class="s">VR$</span><span class="se">\xb2</span><span class="s">e my sno@</span><span class="se">\xe5\xc1\x81</span><span class="s">E</span><span class="se">\x17</span><span class="s">7</span><span class="se">\xa5</span><span class="s">d dreams=</span><span class="se">\x91\xca\x87</span><span class="s">@R,</span><span class="se">\xb3</span><span class="s"> me pretR</span><span class="se">\xab\xc6\x87</span><span class="s">]</span><span class="se">\x15</span><span class="s">O</span><span class="se">\xa6</span><span class="s">lag{thish</span><span class="se">\xac\xd1\xb1</span><span class="s">R</span><span class="se">\x1e</span><span class="s">)</span><span class="se">\x9f</span><span class="s">i_need}</span><span class="se">\x00</span><span class="s">'</span>
<span class="sa">b</span><span class="s">'These are my snow covered dreams</span><span class="se">\n</span><span class="s">This is me pretending</span><span class="se">\n</span><span class="s">flag{this_is_all_i_need}</span><span class="se">\x00</span><span class="s">'</span>
</code></pre></div></div>

<h3 id="flagthis_is_all_i_need">flag{this_is_all_i_need}</h3>

<h2 id="how-to-solve-the-challenge-if-not-aware-of-weak-keys">How to solve the challenge if not aware of weak keys?</h2>

<p><img src="ctftime1.PNG" alt="" /></p>

<p><img src="ctftime2.PNG" alt="" /></p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="nahamcon" /><category term="2020" /><category term="cryptography" /><category term="DES" /><category term="weak_keys" /><summary type="html"><![CDATA[December We are provided with source.py, which reads #!/usr/bin/env python from Crypto.Cipher import DES with open('flag.txt', 'rb') as handle: flag = handle.read() padding_size = len(flag) + (8 - ( len(flag) % 8 )) flag = flag.ljust(padding_size, b'\x00') with open('key', 'rb') as handle: key = handle.read().strip() iv = "13371337" des = DES.new(key, DES.MODE_OFB, iv) ct = des.encrypt(flag) with open('ciphertext','wb') as handle: handle.write(ct) And a binary ciphertext 00000000: d6a2 6fe5 c75c 22e0 5413 5e4e 1140 5d58 ..o..\".T.^N.@]X 00000010: f5ea 69f9 d419 31f7 5513 5745 5452 5e44 ..i...1.U.WETR^D 00000020: 889e 62ff d15c 2ae1 115e 5617 4141 5643 ..b..\*..^V.AAVC 00000030: e7a4 6eff cc1b 49f4 5d52 544c 455b 5a44 ..n...I.]RTLE[ZD 00000040: dda3 79c9 c310 2fcd 586c 5d52 5457 4e37 ..y.../.Xl]RTWN7 Which is quite unusual in the sense that most of it is readable in unusual sizes of 8. This could be another instance of Weak keys Lets quickly run through the 4 weak keys m Crypto.Cipher import DES with open('ciphertext', 'rb') as ct_file: ct = ct_file.read() weak_keys = [ b'\x01\x01\x01\x01\x01\x01\x01\x01', b'\xFE\xFE\xFE\xFE\xFE\xFE\xFE\xFE', b'\xE0\xE0\xE0\xE0\xF1\xF1\xF1\xF1', b'\x1F\x1F\x1F\x1F\x0E\x0E\x0E\x0E' ] for key in weak_keys: iv = b"13371337" des = DES.new(key, DES.MODE_OFB, iv) pt = des.decrypt(ct) print(pt) Which produces the plaintexts b'\xaf\xe0\xda\x8c=\xedG\xe4e my sno\x8c\xa8\xdc\x90.\xa8T\xf3d dreams\xf1\xdc\xd7\x96+\xedO\xe5 me pret\x9e\xe6\xdb\x966\xaa,\xf0lag{this\xa4\xe1\xcc\xa09\xa1J\xc9i_need}\x00' b'\xb8(\xff\x82\xb0)\x06$e my sno\x9b`\xf9\x9e\xa3l\x153d dreams\xe6\x14\xf2\x98\xa6)\x0e% me pret\x89.\xfe\x98\xbbnm0lag{this\xb3)\xe9\xae\xb4e\x0b\ti_need}\x00' b'c\xad\xc7\x9dVR$\xb2e my sno@\xe5\xc1\x81E\x177\xa5d dreams=\x91\xca\x87@R,\xb3 me pretR\xab\xc6\x87]\x15O\xa6lag{thish\xac\xd1\xb1R\x1e)\x9fi_need}\x00' b'These are my snow covered dreams\nThis is me pretending\nflag{this_is_all_i_need}\x00' flag{this_is_all_i_need} How to solve the challenge if not aware of weak keys?]]></summary></entry></feed>