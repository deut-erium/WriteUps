<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://deut-erium.github.io/WriteUps/WriteUps/feed.xml" rel="self" type="application/atom+xml" /><link href="https://deut-erium.github.io/WriteUps/WriteUps/" rel="alternate" type="text/html" hreflang="en" /><updated>2022-05-19T17:29:15+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/feed.xml</id><title type="html">CTF Writeups</title><subtitle></subtitle><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><entry><title type="html">SDCTF 2022 Crypto - Tasty Crypto Roll</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2022/sdctf/crypto/tasty_crypto_roll/2022-05-10-SDCTF-2022-Tasty-Crypto-Roll" rel="alternate" type="text/html" title="SDCTF 2022 Crypto - Tasty Crypto Roll" /><published>2022-05-10T00:00:00+05:30</published><updated>2022-05-10T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2022/sdctf/crypto/tasty_crypto_roll/SDCTF-2022-Tasty-Crypto-Roll</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2022/sdctf/crypto/tasty_crypto_roll/2022-05-10-SDCTF-2022-Tasty-Crypto-Roll"><![CDATA[<h1 id="tasty-crypto-roll">Tasty Crypto Roll</h1>
<h2 id="description">Description</h2>
<p>CRYPTO - Hard <br />
Tasty Crypto Roll<br />
Bob, the genius intern at our company, invented AES-improved. It is based on AES but with layers after layers of proprietary encryption techniques on top of it.</p>

<p>The end result is an encryption scheme that achieves both confusion and diffusion. The more layers of crypto you add, the better the security, right?</p>

<p>Encrypter<br />
<a href="encrypt.py">encrypt.py</a><br />
Encrypted file<br />
<a href="enc.bin">enc.bin</a><br />
Note<br />
The intended solution requires very little brute force and runs under 5 seconds on our machine.<br />
By k3v1n</p>

<h2 id="source">Source</h2>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">secrets</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">Crypto.Cipher</span> <span class="kn">import</span> <span class="n">AES</span>

<span class="n">ENCODING</span> <span class="o">=</span> <span class="s">'utf-8'</span>

<span class="k">def</span> <span class="nf">generate_key</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">secrets</span><span class="p">.</span><span class="n">token_bytes</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">to_binary</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">'{:08b}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">from_binary</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">8</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">8</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="n">cipher</span> <span class="o">=</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cipher</span><span class="p">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="n">key1</span><span class="p">,</span> <span class="n">key2</span> <span class="o">=</span> <span class="n">generate_key</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Using Key:</span><span class="se">\n</span><span class="si">{</span><span class="n">key1</span><span class="si">}</span><span class="s">:</span><span class="si">{</span><span class="n">key2</span><span class="p">.</span><span class="nb">hex</span><span class="p">()</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_flag</span><span class="p">():</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">'Enter the flag to encrypt: '</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'sdctf{'</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">'}'</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">.</span><span class="n">isascii</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">flag</span><span class="si">}</span><span class="s"> is not a valid flag for this challenge'</span><span class="p">)</span>
        <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flag</span>

<span class="n">plaintext</span> <span class="o">=</span> <span class="n">get_flag</span><span class="p">()[</span><span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">plaintext</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">ENCODING</span><span class="p">)</span>

<span class="n">codes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0x1b0</span><span class="p">)))</span>
<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sboxes</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Bad key, try again"</span><span class="p">)</span>
    <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">sboxes</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">data</span><span class="p">).</span><span class="n">encode</span><span class="p">(</span><span class="n">ENCODING</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key2</span><span class="p">,</span> <span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">).</span><span class="n">encode</span><span class="p">(</span><span class="n">ENCODING</span><span class="p">))</span>

<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>

<span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits</span><span class="p">))</span>

<span class="n">ciphertext</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Encrypted: </span><span class="si">{</span><span class="n">ciphertext</span><span class="p">.</span><span class="nb">hex</span><span class="p">()</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'enc.bin2'</span><span class="p">,</span> <span class="s">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">ef</span><span class="p">:</span>
    <span class="n">ef</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="analysis">Analysis</h2>
<p>Here we can see mainly two parts</p>
<ol>
  <li>There are two keys
    <ul>
      <li><code class="language-plaintext highlighter-rouge">key1</code>: pid of current process</li>
      <li><code class="language-plaintext highlighter-rouge">key2</code>: secure random key of 16 bytes</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">key1</code> is used as seed at a lot of places and is bruteforcable (&lt; 2^15)
<code class="language-plaintext highlighter-rouge">key_final</code> and <code class="language-plaintext highlighter-rouge">sboxes</code> are derived from <code class="language-plaintext highlighter-rouge">key1</code>, shuffling is done using <code class="language-plaintext highlighter-rouge">key1</code></li>
</ol>

<h3 id="steps-to-crack">Steps to crack</h3>
<ol>
  <li>decrypt using <code class="language-plaintext highlighter-rouge">key_final</code></li>
  <li>convert the intermediate ciphertext <code class="language-plaintext highlighter-rouge">to_binary</code></li>
  <li>de-shuffle the bits</li>
  <li>generate <code class="language-plaintext highlighter-rouge">from_binary</code> intermediate ciphertext of the deshuffled bits</li>
  <li>decrypt using <code class="language-plaintext highlighter-rouge">key2</code>???</li>
</ol>

<h3 id="how-to-find-key1">How to find <code class="language-plaintext highlighter-rouge">key1</code>?</h3>
<p>Assume you have the correct <code class="language-plaintext highlighter-rouge">key1</code>, reverse for the key, validate the results <br />
using some validator/logical assumption.</p>

<p><code class="language-plaintext highlighter-rouge">codes</code> is a list of <code class="language-plaintext highlighter-rouge">2*(0x1b0-0xb0)</code> = <code class="language-plaintext highlighter-rouge">512</code> characters, utf-8 encoding of
which is 2-bytes each <br />
<code class="language-plaintext highlighter-rouge">sboxes</code> will have 4char strings, which encode to 8 bytes each on utf-8 (i.e
        after substitution)<br />
<code class="language-plaintext highlighter-rouge">data</code> is now <code class="language-plaintext highlighter-rouge">4*2 = 8</code> times each byte of the original plaintext<br />
<code class="language-plaintext highlighter-rouge">data</code> is converted <code class="language-plaintext highlighter-rouge">to_binary</code> before encryption hence each byte is converted<br />
to 8 <code class="language-plaintext highlighter-rouge">b"0"</code> or <code class="language-plaintext highlighter-rouge">b"1"</code> byte. Hence each character is substituted to some<br />
<code class="language-plaintext highlighter-rouge">8*8 = 64</code> byte string before encryption.<br />
Hence len of flag = <code class="language-plaintext highlighter-rouge">len(ciphertext)//64</code> = <code class="language-plaintext highlighter-rouge">3520//64 = 55</code> bytes</p>

<h4 id="assumption-1">Assumption 1</h4>
<p>Since length of flag is 55 characters, would it be reasonable to assume that<br />
there would be repeatitions of characters. And since each flag character is<br />
substituted to fixed 64-byte strings before encryption which is a multiple<br />
of AES block size of 16, AES also acts like simple substitution of the flag<br />
but we do not know the mapping.<br />
Hence if we reverse till step 4 above, we can simply check if there are any<br />
repeating 64-byte blocks, as incorrect shuffling of bits will result in each 
block to be distinct with almost 1 probability.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'enc.bin'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">ciphertext</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">to_binary</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">'{:08b}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">from_binary</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">8</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">8</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">encrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">decrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">unshuffle</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">):</span>
        <span class="n">res</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">def</span> <span class="nf">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">data_bits_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data_bits_uns</span> <span class="o">=</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">,</span> <span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits_uns</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">data</span>
</code></pre></div></div>

<p>Lets add a few validation too</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">key_final_enc</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_unshuffle</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="mi">1337</span><span class="p">))</span>
    <span class="n">random_text_shuffled</span> <span class="o">=</span> <span class="n">random_text</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">shuffle_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">random_text</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1337</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1337</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">)</span> <span class="o">==</span> <span class="n">random_text</span>

<span class="k">def</span> <span class="nf">test_key_final_dec</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="mi">1337</span><span class="p">,</span> <span class="n">key_final_enc</span><span class="p">(</span><span class="mi">1337</span><span class="p">,</span> <span class="n">random_text</span><span class="p">))</span> <span class="o">==</span> <span class="n">random_text</span>

<span class="n">test_unshuffle</span><span class="p">()</span>
<span class="n">test_key_final_dec</span><span class="p">()</span>
</code></pre></div></div>
<p>Looks like all the decryption functions are correct, lets proceed with<br />
bruteforcing for <code class="language-plaintext highlighter-rouge">key1</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">),</span><span class="n">desc</span><span class="o">=</span><span class="s">'solving for key1'</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">substitutions</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">64</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">64</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substitutions</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">64</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"pid ="</span><span class="p">,</span><span class="n">key1</span><span class="p">)</span>
        <span class="k">break</span>
</code></pre></div></div>
<p>After waiting for an eternity, and exhausting the search space of possible pidâ€™s<br />
yet not getting any <code class="language-plaintext highlighter-rouge">key1</code> got me confused. I checked my script locally for a <br />
test flag it seemed to work fine. There could only be one possibility <br />
<strong>the flag contains 55 distinct characters</strong><br />
But how would I find <code class="language-plaintext highlighter-rouge">key1</code> now?</p>

<h4 id="missed-catch">Missed Catch</h4>
<p>@Utaha#6878 pointed out, that since there are only 256 distinct values in
<code class="language-plaintext highlighter-rouge">codes</code> each repeated twice, and each character encoded to some <code class="language-plaintext highlighter-rouge">b"0"</code> or <code class="language-plaintext highlighter-rouge">b"1"</code><br />
byte strings of length 16, It must be encrypted to the same block always.<br />
Since the flag is <code class="language-plaintext highlighter-rouge">55*4 = 220</code> such 16-byte codes and each code is used twice<br />
for most of the characters, there will be repating 16-byte blocks even with <br />
distinct flag characters.</p>

<h4 id="assumption-2">Assumption 2</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">),</span><span class="n">desc</span><span class="o">=</span><span class="s">'solving for key1'</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">substitutions</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">16</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">16</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substitutions</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">16</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"pid ="</span><span class="p">,</span><span class="n">key1</span><span class="p">)</span>
        <span class="k">break</span>
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">pid = 83</code></p>
</blockquote>

<p>And we found our <code class="language-plaintext highlighter-rouge">key1</code>!<br />
And we can confirm that the flag is indeed 55 distinct characters.</p>

<p>Wait, if the flag is 55 distinct characters, how will we solve for the subs?<br />
We have no statistical advantage and hence bye bye Mr 
<a href="https://quipqiup.com/">quipquip</a></p>

<h3 id="how-do-we-find-mapping-for-substitution">How do we find mapping for substitution?</h3>
<p>Each <code class="language-plaintext highlighter-rouge">sbox</code> entry is composed of 4 2-byte strings, which can be one of 256<br />
possible values. Moreover, their order is fixed, which is determined by <code class="language-plaintext highlighter-rouge">key1</code>.</p>

<p>If we try to solve for all valid mappings for <code class="language-plaintext highlighter-rouge">AES(binary(sbox(char)))</code> we will
probably end up on the correct mapping and get our flag.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+---------------+---------------+------------------------+---------------+
|flag0          |    flag1      |                        |   flag55      |
+---------------+---------------+         ....           +---------------+
|  sbox         |   sbox        |                        |    sbox       |
+---+---+---+---+---+---+---+---+------------------------+---------------+
|c1 |c2 |c3 |c4 |c5 |c6 |c7 |c8 |                        |               |
|   |   |   |   |   |   |   |   |                        |               |
+---+---+---+---+---+---+---+---+         ....           +---------------+
|   AES         |    AES        |                        |               |
+---+---+-------+---------------+------------------------+---------------+
|   |   +------+                                                          
|   +--+       |                                                          
+------+-------+-------+------+                                           
|E(c1) | E(c2) | E(c3) | E(c4)|                                             
+------+-------+-------+------+   
</code></pre></div></div>

<h3 id="enter-z3">Enter Z3</h3>
<p>We can assume our flag to be a list of <code class="language-plaintext highlighter-rouge">BitVec</code> of 7 bits each<br />
And let the sboxes be a mapping from 7 bits to 64 bits each (16x4)<br />
This can be achieved by assuming sbox to be an array which is indexed<br />
by <code class="language-plaintext highlighter-rouge">BitVec(7)</code> and contains elements of <code class="language-plaintext highlighter-rouge">BitVec(64)</code><br />
And we assume AES to be some function form <code class="language-plaintext highlighter-rouge">BitVec(16)</code> to <code class="language-plaintext highlighter-rouge">BitVec(128)</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">flag</span> <span class="o">=</span> <span class="p">[</span><span class="n">BitVec</span><span class="p">(</span><span class="s">'flag_'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="mi">7</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">64</span><span class="p">)]</span>
<span class="n">sboxmap</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s">'sbox'</span><span class="p">,</span><span class="n">BitVecSort</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
<span class="n">aes_encryption</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">'AES'</span><span class="p">,</span><span class="n">BitVecSort</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">codes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0x1b0</span><span class="p">)))</span>
<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="c1"># keeping sboxes utf encoded already
</span><span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">]).</span><span class="n">encode</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>

<span class="n">sbytes</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">sboxes</span><span class="p">)</span>
<span class="n">sboxints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">'big'</span><span class="p">),</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">sbytes</span><span class="p">),</span><span class="mi">2</span><span class="p">))))</span>
<span class="c1"># integer values for 2-byte codes from sbox, will be explained shortly
</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="s">'big'</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxes</span><span class="p">]</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
<span class="c1"># converting intermediate decryption to 128 bit ints
</span><span class="n">data_int</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">16</span><span class="p">):</span>
    <span class="n">data_int</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">16</span><span class="p">],</span><span class="s">'big'</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># we know the sbox already
</span><span class="n">constraints</span> <span class="o">=</span> <span class="p">[</span><span class="n">sboxmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">sboxes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">64</span><span class="p">):</span>
    <span class="n">four_code</span> <span class="o">=</span> <span class="n">sboxmap</span><span class="p">[</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="c1"># splitting 64 bit quantity to 16 bit individual sbox codes
</span>    <span class="n">four_code_parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Extract</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="o">*</span><span class="n">i</span><span class="p">,</span><span class="n">four_code</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="c1"># for each code, matching aes_encryption with the observed value
</span>    <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data_int</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">:</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span> <span class="n">four_code_parts</span><span class="p">):</span>
        <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">==</span><span class="n">a</span><span class="p">)</span>
    <span class="c1"># last but not least, aes_encryption(i) is unique for each plaintext
</span>    <span class="c1"># how would z3 know? Distinct function encodes them appropriately to
</span>    <span class="c1"># be distinct
</span>    <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Distinct</span><span class="p">([</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxints</span><span class="p">]))</span>

<span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">solver</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">all_smt</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
    <span class="c1"># lets check for all satisfying flags (in case there are more than one
</span>    <span class="c1"># possible mappings and we will rule out invalid ones in that scenario?
</span>    <span class="n">flag_bytes</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]).</span><span class="n">as_long</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flag</span><span class="p">))])</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">64</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">64</span><span class="p">)))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">)</span> 
</code></pre></div></div>

<h2 id="flag">Flag</h2>
<p>After running the script, we finally get our flag!</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">b'r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU'</code></p>
</blockquote>

<p>And it turns out to be the only satisfying assignment.<br />
Turns out if there were repeated characters in the flag, we will get multiple<br />
possible satisfying values. So the admins have not been so cheeky afterall</p>

<h2 id="full-script">Full <a href="solve.py">script</a></h2>
<p>Note that it takes a couple of seconds to find the z3 model</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">Crypto.Cipher</span> <span class="kn">import</span> <span class="n">AES</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">z3</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="k">def</span> <span class="nf">all_smt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">initial_terms</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">block_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">fix_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">all_smt_rec</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sat</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">check</span><span class="p">():</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">model</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">m</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)):</span>
                <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">()</span>
                <span class="n">block_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">terms</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">fix_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">terms</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">yield</span> <span class="k">from</span> <span class="n">all_smt_rec</span><span class="p">(</span><span class="n">terms</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
                <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">yield</span> <span class="k">from</span> <span class="n">all_smt_rec</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">initial_terms</span><span class="p">))</span>


<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'enc.bin'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">ciphertext</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">to_binary</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">'{:08b}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">from_binary</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">8</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">encrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">decrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">key_final_enc</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">unshuffle</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">):</span>
        <span class="n">res</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">test_unshuffle</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span>
    <span class="n">random_text_shuffled</span> <span class="o">=</span> <span class="n">random_text</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">shuffle_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">random_text</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">)</span> <span class="o">==</span> <span class="n">random_text</span>


<span class="n">test_unshuffle</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">data_bits_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data_bits_uns</span> <span class="o">=</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">,</span> <span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits_uns</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">test_key_final_dec</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">key_final_enc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_text</span><span class="p">))</span> <span class="o">==</span> <span class="n">random_text</span>


<span class="n">test_key_final_dec</span><span class="p">()</span>

<span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s">'solving for key1'</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">substitutions</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">16</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substitutions</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="mi">16</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"pid ="</span><span class="p">,</span> <span class="n">key1</span><span class="p">)</span>
        <span class="k">break</span>

<span class="n">codes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0x1b0</span><span class="p">)))</span>
<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">]).</span><span class="n">encode</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>
<span class="n">sbytes</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">sboxes</span><span class="p">)</span>
<span class="n">sboxints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">'big'</span><span class="p">),</span> <span class="nb">set</span><span class="p">(</span>
    <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sbytes</span><span class="p">),</span> <span class="mi">2</span><span class="p">))))</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">'big'</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxes</span><span class="p">]</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
<span class="n">data_int</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">16</span><span class="p">):</span>
    <span class="n">data_int</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="s">'big'</span><span class="p">))</span>

<span class="n">flag</span> <span class="o">=</span> <span class="p">[</span><span class="n">BitVec</span><span class="p">(</span><span class="s">'flag_'</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">7</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="mi">64</span><span class="p">)]</span>
<span class="n">sboxmap</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s">'sbox'</span><span class="p">,</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
<span class="n">aes_encryption</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">'AES'</span><span class="p">,</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span>

<span class="n">constraints</span> <span class="o">=</span> <span class="p">[</span><span class="n">sboxmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">sboxes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="mi">64</span><span class="p">):</span>
    <span class="n">four_code</span> <span class="o">=</span> <span class="n">sboxmap</span><span class="p">[</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="n">four_code_parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Extract</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="n">four_code</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data_int</span><span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span><span class="p">:</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">],</span> <span class="n">four_code_parts</span><span class="p">):</span>
        <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Distinct</span><span class="p">([</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxints</span><span class="p">]))</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">solver</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
<span class="c1"># if solver.check() == sat:
# m = solver.model()
</span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">all_smt</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
    <span class="n">flag_bytes</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]).</span><span class="n">as_long</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flag</span><span class="p">))])</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
        <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">64</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">64</span><span class="p">)))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"failed to solve"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="alternate-solution-by-teammate-utaha6878">Alternate Solution by teammate (Utaha#6878)</h3>

<p>All due regards to him for solving the challenge while I was stuck over finding<br />
<code class="language-plaintext highlighter-rouge">key1</code> XD</p>

<p>All parts will be almost same except the substitution solving part, which he<br />
did by manual bruteforcing i.e. recursively enumerating all mappings and
backtracking on contradictions</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">codes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">)],</span> <span class="n">start</span><span class="o">=</span><span class="p">[])</span> 
<span class="c1"># notice that the range is changed from [0xb0, 0x1b0) to [0, 256). 
# It's just for relabeling.
</span><span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
	<span class="s">"""
	equate two objects elementwise ignoring if the entry is -1
	"""</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>

<span class="n">answers</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">getFlag</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">):</span> 
<span class="c1"># get the flag based on current mapping, unknown char will be shown as '?'
</span>    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cip</span><span class="p">:</span>
        <span class="n">afterMap</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span>
        <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sboxes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">afterMap</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s">'?'</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">brute</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">):</span>
    <span class="s">"""
    cip and sboxes remain unchanged throughout the recursive call, 
    but I feel bad using global varaibles.
    """</span>
    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">getFlag</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">))</span>

    <span class="c1"># check is finished
</span>    <span class="n">isFinished</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cip</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">mp</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">isFinished</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="n">isFinished</span><span class="p">:</span>
        <span class="n">answers</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">getFlag</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Found an answer!!!!!!!"</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># try matching
</span>    <span class="n">isContradiction</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Find the one with least possible matches.
</span>    <span class="n">min_pos</span> <span class="o">=</span> <span class="mi">256</span>
    <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cip</span><span class="p">):</span>
        <span class="n">afterMap</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span>
        <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">afterMap</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sboxes</span> <span class="k">if</span> <span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">afterMap</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">isContradiction</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">min_pos</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="n">min_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">isContradiction</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># now bruteforce all possibilities
</span>    <span class="k">assert</span> <span class="n">index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">afterMap</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cip</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sboxes</span> <span class="k">if</span> <span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">afterMap</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cip</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">mp</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">brute</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">)</span>

<span class="c1"># This is based on the repetition
</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">132</span><span class="p">,</span> <span class="mi">197</span><span class="p">]:</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="p">{</span><span class="mi">35</span><span class="p">:</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">109</span><span class="p">:</span> <span class="mi">144</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="n">_</span><span class="p">}</span>
    <span class="n">brute</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Answers:"</span><span class="p">)</span>
<span class="n">answers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">answers</span><span class="p">))</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">answers</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">b</span><span class="s">"sdctf{"</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"}"</span><span class="p">)</span>

<span class="c1"># The fourth one is the actual answer
</span></code></pre></div></div>

<blockquote>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ciphertext repetition:
[4, 5, 4, 6]
[34, 35, 36, 35]
[109, 60, 110, 109]
Sbox repetition:
[132, 93, 132, 211]
[197, 32, 197, 248]
[144, 86, 67, 144]
[165, 224, 27, 224]
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Answers:
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}'
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}'
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}'
</code></pre></div>  </div>
</blockquote>

<p>full script in <a href="./solve2.py">solve2.py</a></p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="SDCTF" /><category term="2022" /><category term="cryptography" /><category term="AES" /><category term="z3" /><category term="substitution" /><category term="permutation" /><summary type="html"><![CDATA[Tasty Crypto Roll Description CRYPTO - Hard Tasty Crypto Roll Bob, the genius intern at our company, invented AES-improved. It is based on AES but with layers after layers of proprietary encryption techniques on top of it. The end result is an encryption scheme that achieves both confusion and diffusion. The more layers of crypto you add, the better the security, right? Encrypter encrypt.py Encrypted file enc.bin Note The intended solution requires very little brute force and runs under 5 seconds on our machine. By k3v1n Source import os import random import secrets import sys from Crypto.Cipher import AES ENCODING = 'utf-8' def generate_key(): return os.getpid(), secrets.token_bytes(16) def to_binary(b: bytes): return ''.join(['{:08b}'.format(c) for c in b]) def from_binary(s: str): return bytes(int(s[i:i+8], 2) for i in range(0, len(s), 8)) def encrypt(key: bytes, message: bytes): cipher = AES.new(key, AES.MODE_ECB) return cipher.encrypt(message) key1, key2 = generate_key() print(f'Using Key:\n{key1}:{key2.hex()}') def get_flag(): flag = input('Enter the flag to encrypt: ') if not flag.startswith('sdctf{') or not flag.endswith('}') or not flag.isascii(): print(f'{flag} is not a valid flag for this challenge') sys.exit(1) return flag plaintext = get_flag()[6:-1] data = plaintext.encode(ENCODING) codes = list(''.join(chr(i) * 2 for i in range(0xb0, 0x1b0))) random.seed(key1) random.shuffle(codes) sboxes = [''.join(codes[i*4:(i+1)*4]) for i in range(128)] if len(set(sboxes)) &lt; 128: print("Bad key, try again") sys.exit(1) data = ''.join(sboxes[c] for c in data).encode(ENCODING) data = encrypt(key2, to_binary(data).encode(ENCODING)) random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data_bits = list(to_binary(data)) random.shuffle(data_bits) data = from_binary(''.join(data_bits)) ciphertext = encrypt(key_final, data) print(f'Encrypted: {ciphertext.hex()}') with open('enc.bin2', 'wb') as ef: ef.write(ciphertext) Analysis Here we can see mainly two parts There are two keys key1: pid of current process key2: secure random key of 16 bytes key1 is used as seed at a lot of places and is bruteforcable (&lt; 2^15) key_final and sboxes are derived from key1, shuffling is done using key1 Steps to crack decrypt using key_final convert the intermediate ciphertext to_binary de-shuffle the bits generate from_binary intermediate ciphertext of the deshuffled bits decrypt using key2??? How to find key1? Assume you have the correct key1, reverse for the key, validate the results using some validator/logical assumption. codes is a list of 2*(0x1b0-0xb0) = 512 characters, utf-8 encoding of which is 2-bytes each sboxes will have 4char strings, which encode to 8 bytes each on utf-8 (i.e after substitution) data is now 4*2 = 8 times each byte of the original plaintext data is converted to_binary before encryption hence each byte is converted to 8 b"0" or b"1" byte. Hence each character is substituted to some 8*8 = 64 byte string before encryption. Hence len of flag = len(ciphertext)//64 = 3520//64 = 55 bytes Assumption 1 Since length of flag is 55 characters, would it be reasonable to assume that there would be repeatitions of characters. And since each flag character is substituted to fixed 64-byte strings before encryption which is a multiple of AES block size of 16, AES also acts like simple substitution of the flag but we do not know the mapping. Hence if we reverse till step 4 above, we can simply check if there are any repeating 64-byte blocks, as incorrect shuffling of bits will result in each block to be distinct with almost 1 probability. with open('enc.bin', 'rb') as f: ciphertext = f.read() def to_binary(b: bytes): return ''.join(['{:08b}'.format(c) for c in b]) def from_binary(s: str): return bytes(int(s[i:i+8], 2) for i in range(0, len(s), 8)) def encrypt(key, message): return AES.new(key, AES.MODE_ECB).encrypt(message) def decrypt(key: bytes, message: bytes): return AES.new(key, AES.MODE_ECB).decrypt(message) def unshuffle(data_list, shuffle_order): res = [None]*len(data_list) for i,v in enumerate(shuffle_order): res[v] = data_list[i] return res def key_final_dec(key1, ciphertext): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data = decrypt(key_final, ciphertext) data_bits = list(to_binary(data)) data_bits_order = list(range(len(data_bits))) random.shuffle(data_bits_order) data_bits_uns = unshuffle(data_bits, data_bits_order) data = from_binary(''.join(data_bits_uns)) return data Lets add a few validation too def key_final_enc(key1, data): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data_bits = list(to_binary(data)) random.shuffle(data_bits) data = from_binary(''.join(data_bits)) return encrypt(key_final, data) def test_unshuffle(): random_text = list(random.randbytes(16*1337)) random_text_shuffled = random_text.copy() shuffle_order = list(range(len(random_text))) random.seed(1337) random.shuffle(random_text_shuffled) random.seed(1337) random.shuffle(shuffle_order) assert unshuffle(random_text_shuffled, shuffle_order) == random_text def test_key_final_dec(): random_text = random.randbytes(16*100) assert key_final_dec(1337, key_final_enc(1337, random_text)) == random_text test_unshuffle() test_key_final_dec() Looks like all the decryption functions are correct, lets proceed with bruteforcing for key1 for key1 in tqdm(range(2**15),desc='solving for key1'): data = key_final_dec(key1, ciphertext) substitutions = Counter(data[i:i+64] for i in range(0,len(data),64)) if len(substitutions)!=len(data)//64: print("pid =",key1) break After waiting for an eternity, and exhausting the search space of possible pidâ€™s yet not getting any key1 got me confused. I checked my script locally for a test flag it seemed to work fine. There could only be one possibility the flag contains 55 distinct characters But how would I find key1 now? Missed Catch @Utaha#6878 pointed out, that since there are only 256 distinct values in codes each repeated twice, and each character encoded to some b"0" or b"1" byte strings of length 16, It must be encrypted to the same block always. Since the flag is 55*4 = 220 such 16-byte codes and each code is used twice for most of the characters, there will be repating 16-byte blocks even with distinct flag characters. Assumption 2 for key1 in tqdm(range(2**15),desc='solving for key1'): data = key_final_dec(key1, ciphertext) substitutions = Counter(data[i:i+16] for i in range(0,len(data),16)) if len(substitutions)!=len(data)//16: print("pid =",key1) break pid = 83 And we found our key1! And we can confirm that the flag is indeed 55 distinct characters. Wait, if the flag is 55 distinct characters, how will we solve for the subs? We have no statistical advantage and hence bye bye Mr quipquip How do we find mapping for substitution? Each sbox entry is composed of 4 2-byte strings, which can be one of 256 possible values. Moreover, their order is fixed, which is determined by key1. If we try to solve for all valid mappings for AES(binary(sbox(char))) we will probably end up on the correct mapping and get our flag. +---------------+---------------+------------------------+---------------+ |flag0 | flag1 | | flag55 | +---------------+---------------+ .... +---------------+ | sbox | sbox | | sbox | +---+---+---+---+---+---+---+---+------------------------+---------------+ |c1 |c2 |c3 |c4 |c5 |c6 |c7 |c8 | | | | | | | | | | | | | | +---+---+---+---+---+---+---+---+ .... +---------------+ | AES | AES | | | +---+---+-------+---------------+------------------------+---------------+ | | +------+ | +--+ | +------+-------+-------+------+ |E(c1) | E(c2) | E(c3) | E(c4)| +------+-------+-------+------+ Enter Z3 We can assume our flag to be a list of BitVec of 7 bits each And let the sboxes be a mapping from 7 bits to 64 bits each (16x4) This can be achieved by assuming sbox to be an array which is indexed by BitVec(7) and contains elements of BitVec(64) And we assume AES to be some function form BitVec(16) to BitVec(128) flag = [BitVec('flag_'+str(i),7) for i in range(len(data)//64)] sboxmap = Array('sbox',BitVecSort(7), BitVecSort(64)) aes_encryption = Function('AES',BitVecSort(16), BitVecSort(128)) codes = list(''.join(chr(i) * 2 for i in range(0xb0, 0x1b0))) random.seed(key1) random.shuffle(codes) # keeping sboxes utf encoded already sboxes = [''.join(codes[i*4:(i+1)*4]).encode() for i in range(128)] sbytes = b''.join(sboxes) sboxints = list(map(lambda x:int.from_bytes(x,'big'), set(sbytes[i:i+2] for i in range(0,len(sbytes),2)))) # integer values for 2-byte codes from sbox, will be explained shortly sboxes = [int.from_bytes(i,'big') for i in sboxes] data = key_final_dec(key1, ciphertext) # converting intermediate decryption to 128 bit ints data_int = [] for i in range(0,len(data),16): data_int.append(int.from_bytes(data[i:i+16],'big')) # we know the sbox already constraints = [sboxmap[i]==sboxes[i] for i in range(128)] for i in range(len(data)//64): four_code = sboxmap[flag[i]] # splitting 64 bit quantity to 16 bit individual sbox codes four_code_parts = [Extract(16*i+15,16*i,four_code) for i in range(3,-1,-1)] # for each code, matching aes_encryption with the observed value for a,b in zip(data_int[4*i:4*i+4], four_code_parts): constraints.append(aes_encryption(b)==a) # last but not least, aes_encryption(i) is unique for each plaintext # how would z3 know? Distinct function encodes them appropriately to # be distinct constraints.append(Distinct([aes_encryption(i) for i in sboxints])) solver = Solver() solver.add(constraints) for m in all_smt(solver, flag): # lets check for all satisfying flags (in case there are more than one # possible mappings and we will rule out invalid ones in that scenario? flag_bytes = bytes([m.eval(flag[i]).as_long() for i in range(len(flag))]) assert len(set(flag_bytes)) == len(Counter(data[i:i+64] for i in range(0,len(data),64))) print(flag_bytes) Flag After running the script, we finally get our flag! b'r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU' And it turns out to be the only satisfying assignment. Turns out if there were repeated characters in the flag, we will get multiple possible satisfying values. So the admins have not been so cheeky afterall Full script Note that it takes a couple of seconds to find the z3 model import random from Crypto.Cipher import AES from collections import Counter from tqdm import tqdm from z3 import * import sys def all_smt(s, initial_terms): def block_term(s, m, t): s.add(t != m.eval(t)) def fix_term(s, m, t): s.add(t == m.eval(t)) def all_smt_rec(terms): if sat == s.check(): m = s.model() yield m for i in range(len(terms)): s.push() block_term(s, m, terms[i]) for j in range(i): fix_term(s, m, terms[j]) yield from all_smt_rec(terms[i:]) s.pop() yield from all_smt_rec(list(initial_terms)) with open('enc.bin', 'rb') as f: ciphertext = f.read() def to_binary(b: bytes): return ''.join(['{:08b}'.format(c) for c in b]) def from_binary(s: str): return bytes(int(s[i:i + 8], 2) for i in range(0, len(s), 8)) def encrypt(key, message): return AES.new(key, AES.MODE_ECB).encrypt(message) def decrypt(key: bytes, message: bytes): return AES.new(key, AES.MODE_ECB).decrypt(message) def key_final_enc(key1, data): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data_bits = list(to_binary(data)) random.shuffle(data_bits) data = from_binary(''.join(data_bits)) return encrypt(key_final, data) def unshuffle(data_list, shuffle_order): res = [None] * len(data_list) for i, v in enumerate(shuffle_order): res[v] = data_list[i] return res def test_unshuffle(): random_text = list(random.randbytes(16 * 100)) random_text_shuffled = random_text.copy() shuffle_order = list(range(len(random_text))) random.seed(10) random.shuffle(random_text_shuffled) random.seed(10) random.shuffle(shuffle_order) assert unshuffle(random_text_shuffled, shuffle_order) == random_text test_unshuffle() def key_final_dec(key1, ciphertext): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data = decrypt(key_final, ciphertext) data_bits = list(to_binary(data)) data_bits_order = list(range(len(data_bits))) random.shuffle(data_bits_order) data_bits_uns = unshuffle(data_bits, data_bits_order) data = from_binary(''.join(data_bits_uns)) return data def test_key_final_dec(): random_text = random.randbytes(16 * 100) assert key_final_dec(10, key_final_enc(10, random_text)) == random_text test_key_final_dec() for key1 in tqdm(range(2**15), desc='solving for key1'): data = key_final_dec(key1, ciphertext) substitutions = Counter(data[i:i + 16] for i in range(0, len(data), 16)) if len(substitutions) != len(data) // 16: print("pid =", key1) break codes = list(''.join(chr(i) * 2 for i in range(0xb0, 0x1b0))) random.seed(key1) random.shuffle(codes) sboxes = [''.join(codes[i * 4:(i + 1) * 4]).encode() for i in range(128)] sbytes = b''.join(sboxes) sboxints = list(map(lambda x: int.from_bytes(x, 'big'), set( sbytes[i:i + 2] for i in range(0, len(sbytes), 2)))) sboxes = [int.from_bytes(i, 'big') for i in sboxes] data = key_final_dec(key1, ciphertext) data_int = [] for i in range(0, len(data), 16): data_int.append(int.from_bytes(data[i:i + 16], 'big')) flag = [BitVec('flag_' + str(i), 7) for i in range(len(data) // 64)] sboxmap = Array('sbox', BitVecSort(7), BitVecSort(64)) aes_encryption = Function('AES', BitVecSort(16), BitVecSort(128)) constraints = [sboxmap[i] == sboxes[i] for i in range(128)] for i in range(len(data) // 64): four_code = sboxmap[flag[i]] four_code_parts = [Extract(16 * i + 15, 16 * i, four_code) for i in range(3, -1, -1)] for a, b in zip(data_int[4 * i:4 * i + 4], four_code_parts): constraints.append(aes_encryption(b) == a) constraints.append(Distinct([aes_encryption(i) for i in sboxints])) solver = Solver() solver.add(constraints) # if solver.check() == sat: # m = solver.model() for m in all_smt(solver, flag): flag_bytes = bytes([m.eval(flag[i]).as_long() for i in range(len(flag))]) assert len(set(flag_bytes)) == len( Counter(data[i:i + 64] for i in range(0, len(data), 64))) print(flag_bytes) else: print("failed to solve") Alternate Solution by teammate (Utaha#6878) All due regards to him for solving the challenge while I was stuck over finding key1 XD All parts will be almost same except the substitution solving part, which he did by manual bruteforcing i.e. recursively enumerating all mappings and backtracking on contradictions mp = dict() codes = sum([[i, i] for i in range(256)], start=[]) # notice that the range is changed from [0xb0, 0x1b0) to [0, 256). # It's just for relabeling. random.seed(key1) random.shuffle(codes) sboxes = [codes[i*4:(i+1)*4] for i in range(128)] def match(a, b): """ equate two objects elementwise ignoring if the entry is -1 """ for x, y in zip(a, b): if x == -1 or y == -1: continue if x != y: return False return True answers = [] def getFlag(cip, sboxes, mp): # get the flag based on current mapping, unknown char will be shown as '?' res = [] for c in cip: afterMap = [mp.get(x, -1) for x in c] found = False for i, s in enumerate(sboxes): if s == afterMap: res.append(i) found = True break if not found: res.append(ord('?')) return bytes(res) def brute(cip, sboxes, mp): """ cip and sboxes remain unchanged throughout the recursive call, but I feel bad using global varaibles. """ if DEBUG: print(getFlag(cip, sboxes, mp)) # check is finished isFinished = True for c in cip: if all(x in mp for x in c): pass else: isFinished = False if isFinished: answers.append(getFlag(cip, sboxes, mp)) print("Found an answer!!!!!!!") return # try matching isContradiction = False mp = mp.copy() # Find the one with least possible matches. min_pos = 256 index = -1 for idx, c in enumerate(cip): afterMap = [mp.get(x, -1) for x in c] if -1 not in afterMap: continue matches = [s for s in sboxes if match(s, afterMap)] if len(matches) == 0: isContradiction = True break if min_pos &gt; len(matches): index = idx min_pos = len(matches) if isContradiction: return # now bruteforce all possibilities assert index != -1 afterMap = [mp.get(x, -1) for x in cip[index]] matches = [s for s in sboxes if match(s, afterMap)] for m in matches: for x, y in zip(cip[index], m): mp[x] = y brute(cip, sboxes, mp) # This is based on the repetition for _ in [132, 197]: mp = {35: 224, 109: 144, 4: _} brute(cip, sboxes, mp) print("Answers:") answers = list(set(answers)) for x in answers: print(b"sdctf{" + x + b"}") # The fourth one is the actual answer Ciphertext repetition: [4, 5, 4, 6] [34, 35, 36, 35] [109, 60, 110, 109] Sbox repetition: [132, 93, 132, 211] [197, 32, 197, 248] [144, 86, 67, 144] [165, 224, 27, 224] Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Answers: b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}' b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}' b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}' full script in solve2.py]]></summary></entry><entry><title type="html">HSCTF 2020 Crypto - Affina and the quadratics</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Affina%20and%20the%20Quadratics/2020-06-06-HSCTF-2020-Affina-and-the-quadratics" rel="alternate" type="text/html" title="HSCTF 2020 Crypto - Affina and the quadratics" /><published>2020-06-06T00:00:00+05:30</published><updated>2020-06-06T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Affina%20and%20the%20Quadratics/HSCTF-2020-Affina-and-the-quadratics</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Affina%20and%20the%20Quadratics/2020-06-06-HSCTF-2020-Affina-and-the-quadratics"><![CDATA[<h1 id="affina-and-the-quadratics">Affina and the Quadratics</h1>

<p><img src="Capture.PNG" alt="" /></p>

<p>We are given this image, and hinted towards the name <a href="https://en.wikipedia.org/wiki/Affine_cipher">Affina</a>.</p>

<p><img src="affffinaaaa-page-001.jpg" alt="" />
With a description reading</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Affina was struggling with her graphing quadratics homework. Bored, she decided to cheat by using Desmos to graph the given quadratic, and then realized that she could use it to send messages to her best friend without anyone noticing!

She sent the following message to her friend: 7rr4p6_4e_4ph6bo8hap2?

Can you decrypt it using the image of the quadratic Affina used? Note: the flag should make relative sense.
</code></pre></div></div>

<p>The task is to GUESS how Affine cipher is used with respect to the quadratic <code class="language-plaintext highlighter-rouge">(x+1)*(x+2) = 0</code></p>

<p>After having many GUESSES, I GUESSED that it could be simple affine cipher with mapping <code class="language-plaintext highlighter-rouge">3x+2 mod 26</code> as <code class="language-plaintext highlighter-rouge">(x+1)*(x+2) = x^2 + 3x + 2</code> as hey!, why should it be quadratic right?</p>

<p>But dont we have letters too? So I GUESSED we shouldnt care about them for now.<br />
What about underscores? GUESS that they are just word-delimiters.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c = 3x + 2 mod 26
c - 2 = 3x mod 26
3^-1 * (c - 2) = x mod 26
9c - 18 = x mod 26
x = 9c + 8 mod 26
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ct</span> <span class="o">=</span> <span class="s">"7rr4p6_4e_4ph6bo8hap2"</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="s">"rrpephbohap"</span>
<span class="n">ct26</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">97</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">alpha</span><span class="p">]</span>
<span class="n">pt</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">chr</span><span class="p">((</span><span class="mi">9</span><span class="o">*</span><span class="n">c</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span><span class="o">%</span><span class="mi">26</span> <span class="o">+</span> <span class="mi">97</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ct26</span> <span class="p">]</span>
</code></pre></div></div>

<p>putting it in places, we get
<code class="language-plaintext highlighter-rouge">7ff4n6_4s_4nt6re8tin2</code></p>

<p>Now why GUESS that number are encoded with the same affine cipher modulo when you can easily GUESS the flag is <code class="language-plaintext highlighter-rouge">4ff1n3_1s_1nt3re5tin6</code> :smile:</p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="HSCTF" /><category term="2020" /><category term="cryptography" /><category term="affine" /><category term="classical" /><category term="substitution" /><summary type="html"><![CDATA[Affina and the Quadratics We are given this image, and hinted towards the name Affina. With a description reading Affina was struggling with her graphing quadratics homework. Bored, she decided to cheat by using Desmos to graph the given quadratic, and then realized that she could use it to send messages to her best friend without anyone noticing! She sent the following message to her friend: 7rr4p6_4e_4ph6bo8hap2? Can you decrypt it using the image of the quadratic Affina used? Note: the flag should make relative sense. The task is to GUESS how Affine cipher is used with respect to the quadratic (x+1)*(x+2) = 0 After having many GUESSES, I GUESSED that it could be simple affine cipher with mapping 3x+2 mod 26 as (x+1)*(x+2) = x^2 + 3x + 2 as hey!, why should it be quadratic right? But dont we have letters too? So I GUESSED we shouldnt care about them for now. What about underscores? GUESS that they are just word-delimiters. c = 3x + 2 mod 26 c - 2 = 3x mod 26 3^-1 * (c - 2) = x mod 26 9c - 18 = x mod 26 x = 9c + 8 mod 26 ct = "7rr4p6_4e_4ph6bo8hap2" alpha = "rrpephbohap" ct26 = [ chr(i) - 97 for i in alpha] pt = [ chr((9*c + 8)%26 + 97) for c in ct26 ] putting it in places, we get 7ff4n6_4s_4nt6re8tin2 Now why GUESS that number are encoded with the same affine cipher modulo when you can easily GUESS the flag is 4ff1n3_1s_1nt3re5tin6 :smile:]]></summary></entry><entry><title type="html">HSCTF 2020 Crypto - Chonky E</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Chonky%20E/2020-06-06-HSCTF-2020-Chonky-E" rel="alternate" type="text/html" title="HSCTF 2020 Crypto - Chonky E" /><published>2020-06-06T00:00:00+05:30</published><updated>2020-06-06T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Chonky%20E/HSCTF-2020-Chonky-E</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Chonky%20E/2020-06-06-HSCTF-2020-Chonky-E"><![CDATA[<h1 id="chonky-e">Chonky E</h1>
<p><img src="Capture.PNG" alt="" /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Allen and Jason rely on two different cryptosystems to keep their information secure.

Allen uses the RSA cryptosystem, given by the following public key:
e = 91043118409828550796773745518585981151180206101005135117565865602978722878478494447048783557571813980525643725323377488249838860897784683927029906188947001149632101513367258267329961684034661252866484981926055087386190015432964608927947646476193251820354738640453947833718397360834701566765504916472450194494897616371452996381159817427887623703639133290358520498419049175941584678802701606995099241245926884172985004839801270005583030514286561971825047719421487004569752638468907609110285739083279629747310953086535889932550905065172805818862336335628248528993024112446002398466115161473573451161053837400091893285717
n = 156749047558583013960513267351769479915110440411448078412590565797031533622509813352093119636835511977253033854388466854142753776146092587825440445182008237325262012698034419137157047927918635897378973846177552961727126115560551970797370239385129543828686170774323306933202481728884019420422360360849592983818405154473369790181636472137741865440233383956571081122982223602667853668754338360008279002325576495573847568301584365514417593244726435632222027817410359417329310347952169273512510934251453361933794586716533950489973436393834189505450956622286216819440777162804798432330933357058175885674184582816364542591313

Jason uses the Schmidt-Samoa cryptosystem. Although a public key has not been recovered, we know that Allen and Jason share the same primes (p,q).

A ciphertext was found on Jasonâ€™s computer that reads: 16267540901004879123859424672087486188548628828063789528428674467464407443871599865993337555869530486241139138650641838377419734897801380883629894166353225288006148210453677023750688175192317241440457768788267270422857060534261674538755743244831152470995124962736526978165448560149498403762447372653982922113772190234143253450918953235222315161964539311032659628670417496174123483045439359846360048774164337257829398345686635091862306204455687347443958931441225500856408331795261329035072585605404416473987280037959184981453888701567175803979981461050532113072292714696752692872526424122826696681194705563391161137426703690900733706866842363055967856443765215723398555522126909749236759332964873221973970368877565410624895160438695006432021529071866881905134494489266801004903504121740435965696128048690741210812963902631391765192187570107372453917327060678806282122942318369245760773848604249664378721970318257356486696764545

What are the contents of this message?
</code></pre></div></div>

<p>Since both crypto use same p and q doesnt reveal a method to recover p or q or the plaintext somehow, second BIG hint is the name of the challenge :- chonkyE</p>

<p>Big E could lead to two attacks, and Boneh Durfee attack is more powerful of the two.</p>

<p>Here is the evergreen <a href="https://github.com/mimoo/RSA-and-LLL-attacks">sage script</a> for the same. I modified it a bit (by fixing annoying python2 print statements) to run on sage 9 (python3).</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">d = 4801820624110300567381264152630360984400101198006662778338105999190025449039653722546363948393959163699344836724430590700225590643966670154013435626235133</code></p>
</blockquote>

<p>We can recover p, q from n, e, d. The most convenient way according to me is to use RSA module from Crypto.PublicKey</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">Crypto.PublicKey</span> <span class="kn">import</span> <span class="n">RSA</span>
<span class="kn">import</span> <span class="nn">gmpy2</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">156749047558583013960513267351769479915110440411448078412590565797031533622509813352093119636835511977253033854388466854142753776146092587825440445182008237325262012698034419137157047927918635897378973846177552961727126115560551970797370239385129543828686170774323306933202481728884019420422360360849592983818405154473369790181636472137741865440233383956571081122982223602667853668754338360008279002325576495573847568301584365514417593244726435632222027817410359417329310347952169273512510934251453361933794586716533950489973436393834189505450956622286216819440777162804798432330933357058175885674184582816364542591313</span>
<span class="n">e</span> <span class="o">=</span> <span class="mi">91043118409828550796773745518585981151180206101005135117565865602978722878478494447048783557571813980525643725323377488249838860897784683927029906188947001149632101513367258267329961684034661252866484981926055087386190015432964608927947646476193251820354738640453947833718397360834701566765504916472450194494897616371452996381159817427887623703639133290358520498419049175941584678802701606995099241245926884172985004839801270005583030514286561971825047719421487004569752638468907609110285739083279629747310953086535889932550905065172805818862336335628248528993024112446002398466115161473573451161053837400091893285717</span>
<span class="n">d</span> <span class="o">=</span> <span class="mi">4801820624110300567381264152630360984400101198006662778338105999190025449039653722546363948393959163699344836724430590700225590643966670154013435626235133</span>

<span class="n">rsa</span> <span class="o">=</span> <span class="n">RSA</span><span class="p">.</span><span class="n">construct</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">rsa</span><span class="p">.</span><span class="n">p</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">rsa</span><span class="p">.</span><span class="n">q</span>

<span class="c1"># rest is just implementation of Schmidt-Samoa
</span>
<span class="n">ct</span> <span class="o">=</span> <span class="mi">16267540901004879123859424672087486188548628828063789528428674467464407443871599865993337555869530486241139138650641838377419734897801380883629894166353225288006148210453677023750688175192317241440457768788267270422857060534261674538755743244831152470995124962736526978165448560149498403762447372653982922113772190234143253450918953235222315161964539311032659628670417496174123483045439359846360048774164337257829398345686635091862306204455687347443958931441225500856408331795261329035072585605404416473987280037959184981453888701567175803979981461050532113072292714696752692872526424122826696681194705563391161137426703690900733706866842363055967856443765215723398555522126909749236759332964873221973970368877565410624895160438695006432021529071866881905134494489266801004903504121740435965696128048690741210812963902631391765192187570107372453917327060678806282122942318369245760773848604249664378721970318257356486696764545</span>

<span class="c1"># N = p**2*q
# d = N^-1 mod lcm(p-1, q-1)
# m = c^d mod pq
</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">q</span>  <span class="c1"># since this one works
</span><span class="n">lcm_val</span> <span class="o">=</span> <span class="n">gmpy2</span><span class="p">.</span><span class="n">lcm</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">gmpy2</span><span class="p">.</span><span class="n">invert</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">lcm_val</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">m</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]))</span>
<span class="c1"># flag{remarkably_superb_acronym}
</span></code></pre></div></div>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="HSCTF" /><category term="2020" /><category term="cryptography" /><category term="RSA" /><category term="schmidtsamoa" /><category term="bonehdurfee" /><category term="bigE" /><summary type="html"><![CDATA[Chonky E Allen and Jason rely on two different cryptosystems to keep their information secure. Allen uses the RSA cryptosystem, given by the following public key: e = 91043118409828550796773745518585981151180206101005135117565865602978722878478494447048783557571813980525643725323377488249838860897784683927029906188947001149632101513367258267329961684034661252866484981926055087386190015432964608927947646476193251820354738640453947833718397360834701566765504916472450194494897616371452996381159817427887623703639133290358520498419049175941584678802701606995099241245926884172985004839801270005583030514286561971825047719421487004569752638468907609110285739083279629747310953086535889932550905065172805818862336335628248528993024112446002398466115161473573451161053837400091893285717 n = 156749047558583013960513267351769479915110440411448078412590565797031533622509813352093119636835511977253033854388466854142753776146092587825440445182008237325262012698034419137157047927918635897378973846177552961727126115560551970797370239385129543828686170774323306933202481728884019420422360360849592983818405154473369790181636472137741865440233383956571081122982223602667853668754338360008279002325576495573847568301584365514417593244726435632222027817410359417329310347952169273512510934251453361933794586716533950489973436393834189505450956622286216819440777162804798432330933357058175885674184582816364542591313 Jason uses the Schmidt-Samoa cryptosystem. Although a public key has not been recovered, we know that Allen and Jason share the same primes (p,q). A ciphertext was found on Jasonâ€™s computer that reads: 16267540901004879123859424672087486188548628828063789528428674467464407443871599865993337555869530486241139138650641838377419734897801380883629894166353225288006148210453677023750688175192317241440457768788267270422857060534261674538755743244831152470995124962736526978165448560149498403762447372653982922113772190234143253450918953235222315161964539311032659628670417496174123483045439359846360048774164337257829398345686635091862306204455687347443958931441225500856408331795261329035072585605404416473987280037959184981453888701567175803979981461050532113072292714696752692872526424122826696681194705563391161137426703690900733706866842363055967856443765215723398555522126909749236759332964873221973970368877565410624895160438695006432021529071866881905134494489266801004903504121740435965696128048690741210812963902631391765192187570107372453917327060678806282122942318369245760773848604249664378721970318257356486696764545 What are the contents of this message? Since both crypto use same p and q doesnt reveal a method to recover p or q or the plaintext somehow, second BIG hint is the name of the challenge :- chonkyE Big E could lead to two attacks, and Boneh Durfee attack is more powerful of the two. Here is the evergreen sage script for the same. I modified it a bit (by fixing annoying python2 print statements) to run on sage 9 (python3). d = 4801820624110300567381264152630360984400101198006662778338105999190025449039653722546363948393959163699344836724430590700225590643966670154013435626235133 We can recover p, q from n, e, d. The most convenient way according to me is to use RSA module from Crypto.PublicKey from Crypto.PublicKey import RSA import gmpy2 n = 156749047558583013960513267351769479915110440411448078412590565797031533622509813352093119636835511977253033854388466854142753776146092587825440445182008237325262012698034419137157047927918635897378973846177552961727126115560551970797370239385129543828686170774323306933202481728884019420422360360849592983818405154473369790181636472137741865440233383956571081122982223602667853668754338360008279002325576495573847568301584365514417593244726435632222027817410359417329310347952169273512510934251453361933794586716533950489973436393834189505450956622286216819440777162804798432330933357058175885674184582816364542591313 e = 91043118409828550796773745518585981151180206101005135117565865602978722878478494447048783557571813980525643725323377488249838860897784683927029906188947001149632101513367258267329961684034661252866484981926055087386190015432964608927947646476193251820354738640453947833718397360834701566765504916472450194494897616371452996381159817427887623703639133290358520498419049175941584678802701606995099241245926884172985004839801270005583030514286561971825047719421487004569752638468907609110285739083279629747310953086535889932550905065172805818862336335628248528993024112446002398466115161473573451161053837400091893285717 d = 4801820624110300567381264152630360984400101198006662778338105999190025449039653722546363948393959163699344836724430590700225590643966670154013435626235133 rsa = RSA.construct((n, e, d)) p = rsa.p q = rsa.q # rest is just implementation of Schmidt-Samoa ct = 16267540901004879123859424672087486188548628828063789528428674467464407443871599865993337555869530486241139138650641838377419734897801380883629894166353225288006148210453677023750688175192317241440457768788267270422857060534261674538755743244831152470995124962736526978165448560149498403762447372653982922113772190234143253450918953235222315161964539311032659628670417496174123483045439359846360048774164337257829398345686635091862306204455687347443958931441225500856408331795261329035072585605404416473987280037959184981453888701567175803979981461050532113072292714696752692872526424122826696681194705563391161137426703690900733706866842363055967856443765215723398555522126909749236759332964873221973970368877565410624895160438695006432021529071866881905134494489266801004903504121740435965696128048690741210812963902631391765192187570107372453917327060678806282122942318369245760773848604249664378721970318257356486696764545 # N = p**2*q # d = N^-1 mod lcm(p-1, q-1) # m = c^d mod pq N = p*q*q # since this one works lcm_val = gmpy2.lcm(p-1, q-1) D = gmpy2.invert(N, lcm_val) m = pow(ct, D, p*q) print(bytes.fromhex(hex(m)[2:])) # flag{remarkably_superb_acronym}]]></summary></entry><entry><title type="html">HSCTF 2020 Crypto - Extremely Complex Challenge</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Extremely%20Complex%20Challenge/2020-06-06-HSCTF-2020-Extremely-Complex-Challenge" rel="alternate" type="text/html" title="HSCTF 2020 Crypto - Extremely Complex Challenge" /><published>2020-06-06T00:00:00+05:30</published><updated>2020-06-06T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Extremely%20Complex%20Challenge/HSCTF-2020-Extremely-Complex-Challenge</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Extremely%20Complex%20Challenge/2020-06-06-HSCTF-2020-Extremely-Complex-Challenge"><![CDATA[<h1 id="extremely-complex-challenge">Extremely Complex Challenge</h1>

<p><img src="Capture.PNG" alt="" /></p>

<p>We are given two points on an <a href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography#Theory">Elliptic Curve</a>, its order and parameter <code class="language-plaintext highlighter-rouge">b</code>.<br />
Using these quantities, we can recover parameter <code class="language-plaintext highlighter-rouge">a</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>y^2 = x^3 + ax + b (mod p)
y^2 - x^3 - b = ax (mod p)

If we have two points on curve, (x1, y1) and (x2, y2), we can get

(y1^2 - x1^3) - (y2^2 - x2^3) = a(x1 - x2)  (mod p)
a = (x1 - x2)^-1 (y1^2 - x1^3) - (y2^2 - x2^3)  (mod p)

(x1 - x2)^-1 is inverse of (x1-x2) modulo p
</code></pre></div></div>

<p>Now as we have all parameters, we can solve <a href="https://en.wikipedia.org/wiki/Discrete_logarithm#Cryptography">ECDLP</a> easily since the sizes are too small.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">gmpy2</span>

<span class="n">p</span> <span class="o">=</span> <span class="mi">404993569381</span>
<span class="n">G</span> <span class="o">=</span> <span class="p">(</span><span class="mi">391109997465</span><span class="p">,</span> <span class="mi">167359562362</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="mi">209038982304</span><span class="p">,</span> <span class="mi">168517698208</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">54575449882</span>

<span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="n">diff</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">%</span> <span class="n">p</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">gmpy2</span><span class="p">.</span><span class="n">invert</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">diff</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">%</span> <span class="n">p</span>

<span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">])</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">E</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">E</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="n">PK</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">discrete_log</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">PK</span><span class="p">)</span>
<span class="n">G</span><span class="o">*</span><span class="n">PK</span> <span class="o">==</span> <span class="n">P</span>
<span class="c1">#17683067357
</span></code></pre></div></div>

<p>Altough I solved it using <a href="https://www.sagemath.org/">SageMath</a>, I think it can be solved on python too using relevant libraries.</p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="HSCTF" /><category term="2020" /><category term="cryptography" /><category term="ECC" /><category term="ECDLP" /><summary type="html"><![CDATA[Extremely Complex Challenge We are given two points on an Elliptic Curve, its order and parameter b. Using these quantities, we can recover parameter a. y^2 = x^3 + ax + b (mod p) y^2 - x^3 - b = ax (mod p) If we have two points on curve, (x1, y1) and (x2, y2), we can get (y1^2 - x1^3) - (y2^2 - x2^3) = a(x1 - x2) (mod p) a = (x1 - x2)^-1 (y1^2 - x1^3) - (y2^2 - x2^3) (mod p) (x1 - x2)^-1 is inverse of (x1-x2) modulo p Now as we have all parameters, we can solve ECDLP easily since the sizes are too small. import gmpy2 p = 404993569381 G = (391109997465, 167359562362) P = (209038982304, 168517698208) b = 54575449882 diff = (G[1]**2 - P[1]**2) - (G[0]**3 - P[0]**3) diff = diff % p a = gmpy2.invert(G[0] - P[0],p)*diff a = a % p E = EllipticCurve(GF(p) , [a,b]) G = E(G) P = E(P) PK = G.discrete_log(P) print(PK) G*PK == P #17683067357 Altough I solved it using SageMath, I think it can be solved on python too using relevant libraries.]]></summary></entry><entry><title type="html">HSCTF 2020 Crypto - Morbid</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Morbid/2020-06-06-HSCTF-2020-Morbid" rel="alternate" type="text/html" title="HSCTF 2020 Crypto - Morbid" /><published>2020-06-06T00:00:00+05:30</published><updated>2020-06-06T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Morbid/HSCTF-2020-Morbid</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Morbid/2020-06-06-HSCTF-2020-Morbid"><![CDATA[<hr />
<p>aside:
  toc: true
sidebar:
  nav: aboutnav
author: deuterium
full_width: true
mathjax: false
mathjax_autoNumber: false
mermaid: false
chart: false
show_edit_on_github: true
comment: false:
show_author_profile: true
excerpt_separator: <!--more-->
â€”</p>

<h1 id="morbid">Morbid</h1>

<p><img src="Capture.PNG" alt="" /></p>

<h3 id="contents-of-morbitpdf">Contents of Morbit.pdf</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MORBIT (50-75 plaintext letters)

Choose a  9-letter  keyword  to  set  up an  array  as  shown.  Plaintext  is  enciphered
exactly  as in  the  Fractionated  Morse,  x  between  letters,  xx  between  words.  The
result is then taken off in units of 2, placed vertically, and numbers are taken from
the array to form the ciphertext. Numbers represent alphabetical order of the key. (It
is often as easy to read pairs horizontally as to rearrange them vertically.) Morse
code letters, numbers, and punctuation can be found in Appendix 1.

Key:

 W I S E C R A C K
 9 5 8 4 2 7 1 3 6
 â€¢ â€¢ â€¢ â€“ â€“ â€“ x x x
 â€¢ â€“ x â€¢ â€“ x â€¢ â€“ x

pt: Once upon a time.

pt:   o      n       c     e   /    u        p       o       n
MC: â€“ â€“ â€“ x â€“ â€¢ x â€“ â€¢ â€“ â€¢ x â€¢ x x â€¢ â€¢ â€“ x â€¢ â€“ â€“ â€¢ x â€“ â€“ â€“ x â€“ â€¢
CT: 2   7   4   3   5   8   8   1   5   1   2   8   2   7   4

 /  a    /  t    i     m    e
x x â€¢ â€“ x x â€“ x â€¢ â€¢ x â€“ â€“ x â€¢ x
6   5   6   7   9   3   7   8

CT: 27435 88151 28274 65679 378.
</code></pre></div></div>

<blockquote>
  <p>We have to decrypt 118289293938434193849271464117429364476994241473157664969879696938145689474393647294392739247721652822414624317164228466</p>
</blockquote>

<p>Since Morse code is <a href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman encoded</a>, the frequencies of - (dash) and . (dot) would be equivalent in the ciphertext.
(I am not sure about x since spaces are way more frequent than any letter) 
Without thinking more about analyzing the problem statistically, one simple way to solve the problem is <a href="https://en.wikipedia.org/wiki/Brute-force_attack">brute-forcing</a>
the key which is 9 different decimal characters i.e <strong>9! (362880)</strong> permutations to check, which is fairly easy.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">itertools</span>  <span class="c1"># creates iterators for efficient looping
</span>
<span class="c1"># dictionary of mapping as on
# https://en.wikipedia.org/wiki/Morse_code#Letters,_numbers,_punctuation,_prosigns_for_Morse_code_and_non-English_variants
</span>
<span class="n">morse</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">"a"</span><span class="p">:</span> <span class="s">".-"</span><span class="p">,</span>
    <span class="s">"b"</span><span class="p">:</span> <span class="s">"-..."</span><span class="p">,</span>
    <span class="s">"c"</span><span class="p">:</span> <span class="s">"-.-."</span><span class="p">,</span>
    <span class="s">"d"</span><span class="p">:</span> <span class="s">"-.."</span><span class="p">,</span>
    <span class="s">"e"</span><span class="p">:</span> <span class="s">"."</span><span class="p">,</span>
    <span class="s">"f"</span><span class="p">:</span> <span class="s">"..-."</span><span class="p">,</span>
    <span class="s">"g"</span><span class="p">:</span> <span class="s">"--."</span><span class="p">,</span>
    <span class="s">"h"</span><span class="p">:</span> <span class="s">"...."</span><span class="p">,</span>
    <span class="s">"i"</span><span class="p">:</span> <span class="s">".."</span><span class="p">,</span>
    <span class="s">"j"</span><span class="p">:</span> <span class="s">".---"</span><span class="p">,</span>
    <span class="s">"k"</span><span class="p">:</span> <span class="s">"-.-"</span><span class="p">,</span>
    <span class="s">"l"</span><span class="p">:</span> <span class="s">".-.."</span><span class="p">,</span>
    <span class="s">"m"</span><span class="p">:</span> <span class="s">"--"</span><span class="p">,</span>
    <span class="s">"n"</span><span class="p">:</span> <span class="s">"-."</span><span class="p">,</span>
    <span class="s">"o"</span><span class="p">:</span> <span class="s">"---"</span><span class="p">,</span>
    <span class="s">"p"</span><span class="p">:</span> <span class="s">".--."</span><span class="p">,</span>
    <span class="s">"q"</span><span class="p">:</span> <span class="s">"--.-"</span><span class="p">,</span>
    <span class="s">"r"</span><span class="p">:</span> <span class="s">".-."</span><span class="p">,</span>
    <span class="s">"s"</span><span class="p">:</span> <span class="s">"..."</span><span class="p">,</span>
    <span class="s">"t"</span><span class="p">:</span> <span class="s">"-"</span><span class="p">,</span>
    <span class="s">"u"</span><span class="p">:</span> <span class="s">"..-"</span><span class="p">,</span>
    <span class="s">"v"</span><span class="p">:</span> <span class="s">"...-"</span><span class="p">,</span>
    <span class="s">"w"</span><span class="p">:</span> <span class="s">".--"</span><span class="p">,</span>
    <span class="s">"x"</span><span class="p">:</span> <span class="s">"-..-"</span><span class="p">,</span>
    <span class="s">"y"</span><span class="p">:</span> <span class="s">"-.--"</span><span class="p">,</span>
    <span class="s">"z"</span><span class="p">:</span> <span class="s">"--.."</span><span class="p">,</span>
    <span class="s">"0"</span><span class="p">:</span> <span class="s">"-----"</span><span class="p">,</span>
    <span class="s">"1"</span><span class="p">:</span> <span class="s">".----"</span><span class="p">,</span>
    <span class="s">"2"</span><span class="p">:</span> <span class="s">"..---"</span><span class="p">,</span>
    <span class="s">"3"</span><span class="p">:</span> <span class="s">"...--"</span><span class="p">,</span>
    <span class="s">"4"</span><span class="p">:</span> <span class="s">"....-"</span><span class="p">,</span>
    <span class="s">"5"</span><span class="p">:</span> <span class="s">"....."</span><span class="p">,</span>
    <span class="s">"6"</span><span class="p">:</span> <span class="s">"-...."</span><span class="p">,</span>
    <span class="s">"7"</span><span class="p">:</span> <span class="s">"--..."</span><span class="p">,</span>
    <span class="s">"8"</span><span class="p">:</span> <span class="s">"---.."</span><span class="p">,</span>
    <span class="s">"9"</span><span class="p">:</span> <span class="s">"----."</span><span class="p">,</span>
    <span class="s">"."</span><span class="p">:</span> <span class="s">".-.-.-"</span><span class="p">,</span>
    <span class="s">","</span><span class="p">:</span> <span class="s">"--..--"</span><span class="p">,</span>
    <span class="s">"?"</span><span class="p">:</span> <span class="s">"..--.."</span><span class="p">,</span>
    <span class="s">"'"</span><span class="p">:</span> <span class="s">".----."</span><span class="p">,</span>
    <span class="s">"!"</span><span class="p">:</span> <span class="s">"-.-.--"</span><span class="p">,</span>
    <span class="s">"/"</span><span class="p">:</span> <span class="s">"-..-."</span><span class="p">,</span>
    <span class="s">"("</span><span class="p">:</span> <span class="s">"-.--."</span><span class="p">,</span>
    <span class="s">")"</span><span class="p">:</span> <span class="s">"-.--.-"</span><span class="p">,</span>
    <span class="s">"&amp;"</span><span class="p">:</span> <span class="s">".-..."</span><span class="p">,</span>
    <span class="s">":"</span><span class="p">:</span> <span class="s">"---..."</span><span class="p">,</span>
    <span class="s">";"</span><span class="p">:</span> <span class="s">"-.-.-."</span><span class="p">,</span>
    <span class="s">"="</span><span class="p">:</span> <span class="s">"-...-"</span><span class="p">,</span>
    <span class="s">"+"</span><span class="p">:</span> <span class="s">".-.-."</span><span class="p">,</span>
    <span class="s">"-"</span><span class="p">:</span> <span class="s">"-....-"</span><span class="p">,</span>
    <span class="s">"_"</span><span class="p">:</span> <span class="s">"..--.-"</span><span class="p">,</span>
    <span class="s">"</span><span class="se">\"</span><span class="s">"</span><span class="p">:</span> <span class="s">".-..-."</span><span class="p">,</span>
    <span class="s">"$"</span><span class="p">:</span> <span class="s">"...-..-"</span><span class="p">,</span>
    <span class="s">"@"</span><span class="p">:</span> <span class="s">".--.-."</span><span class="p">,</span>
    <span class="s">" "</span><span class="p">:</span> <span class="s">""</span>
<span class="p">}</span>

<span class="n">revMorse</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Dictionary containing inverse mapping from morse code to its corresponding encoded character
</span><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">morse</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">revMorse</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>


<span class="k">def</span> <span class="nf">decrypt_morse</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="s">"""
    Finds the decryption of `message` encoded in morse with individual
    letters separated by x and words separated by xx
    """</span>
    <span class="n">words</span> <span class="o">=</span> <span class="n">message</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'x'</span><span class="p">)</span>
    <span class="k">return</span> <span class="s">""</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">revMorse</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">)</span>


<span class="c1"># Checking the example given in the pdf
</span><span class="k">print</span><span class="p">(</span><span class="n">decrypt_morse</span><span class="p">(</span><span class="s">"---x-.x-.-.x.xx..-x.--.x---x-.xx.-xx-x..x--x.x"</span><span class="p">))</span>
<span class="n">ct</span> <span class="o">=</span> <span class="s">"118289293938434193849271464117429364476994241473157664969879696938145689474393647294392739247721652822414624317164228466"</span>

<span class="n">substitution_token</span> <span class="o">=</span> <span class="p">[</span><span class="s">'..'</span><span class="p">,</span> <span class="s">'.-'</span><span class="p">,</span> <span class="s">'.x'</span><span class="p">,</span> <span class="s">'-.'</span><span class="p">,</span> <span class="s">'--'</span><span class="p">,</span> <span class="s">'-x'</span><span class="p">,</span> <span class="s">'x.'</span><span class="p">,</span> <span class="s">'x-'</span><span class="p">,</span> <span class="s">'xx'</span><span class="p">]</span>
<span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">itertools</span><span class="p">.</span><span class="n">permutations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)):</span>
    <span class="c1"># Iterate over permutations of substitution_tokens to find the
</span>    <span class="c1"># permutations which finds the valid decryption
</span>    <span class="n">ct1</span> <span class="o">=</span> <span class="n">ct</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
        <span class="n">ct1</span> <span class="o">=</span> <span class="n">ct1</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">substitution_token</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="c1"># Replace digit in ciphertext with given permutation of substitutions
</span>    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="s">'flag'</span> <span class="ow">in</span> <span class="n">decrypt_morse</span><span class="p">(</span><span class="n">ct1</span><span class="p">):</span>
            <span class="c1"># if the decyrpted strings containts flag, we get our string
</span>            <span class="k">print</span><span class="p">(</span><span class="n">decrypt_morse</span><span class="p">(</span><span class="n">ct1</span><span class="p">))</span>
            <span class="k">break</span>
    <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
        <span class="k">continue</span>
        
<span class="c1"># Output
# once upon a time
# congratulations. please wrap this message in a flag format: m0r3_b1t5
</span></code></pre></div></div>

<h2 id="post-challenge-analysis">Post-challenge analysis</h2>
<p>Since I found the challenge interesting, here is some analysis</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">substitution</span> <span class="o">=</span> <span class="p">[</span><span class="n">substitution_token</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">perm</span><span class="p">]</span>
<span class="n">frequency</span> <span class="o">=</span> <span class="p">[</span><span class="n">ct</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">digit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">digit</span> <span class="ow">in</span> <span class="n">perm</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"digit {0}: {1} {2}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">substitution</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">frequency</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Digits</th>
      <th style="text-align: center">1</th>
      <th style="text-align: center">2</th>
      <th style="text-align: center">3</th>
      <th style="text-align: center">4</th>
      <th style="text-align: center">5</th>
      <th style="text-align: center">6</th>
      <th style="text-align: center">7</th>
      <th style="text-align: center">8</th>
      <th style="text-align: center">9</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Substitution</td>
      <td style="text-align: center">â€¢â€¢</td>
      <td style="text-align: center">â€¢â€“</td>
      <td style="text-align: center">â€¢X</td>
      <td style="text-align: center">â€“â€¢</td>
      <td style="text-align: center">â€“â€“</td>
      <td style="text-align: center">â€“X</td>
      <td style="text-align: center">Xâ€¢</td>
      <td style="text-align: center">Xâ€“</td>
      <td style="text-align: center">XX</td>
    </tr>
    <tr>
      <td style="text-align: center">Frequency</td>
      <td style="text-align: center">13</td>
      <td style="text-align: center">15</td>
      <td style="text-align: center">12</td>
      <td style="text-align: center">23</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">15</td>
      <td style="text-align: center">12</td>
      <td style="text-align: center">9</td>
      <td style="text-align: center">18</td>
    </tr>
  </tbody>
</table>

<p>Hmm, 
<code class="language-plaintext highlighter-rouge">--</code> and <code class="language-plaintext highlighter-rouge">X-</code> are quite infrequent, while <code class="language-plaintext highlighter-rouge">-.</code> seems a little bit more frequent. I was expecting <code class="language-plaintext highlighter-rouge">.., .-, --, -.</code> to be equally frequent. Either I did some error or there is something which I cant see currently.</p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="HSCTF" /><category term="2020" /><category term="cryptography" /><category term="classical" /><category term="morse" /><summary type="html"><![CDATA[aside: toc: true sidebar: nav: aboutnav author: deuterium full_width: true mathjax: false mathjax_autoNumber: false mermaid: false chart: false show_edit_on_github: true comment: false: show_author_profile: true excerpt_separator:]]></summary></entry><entry><title type="html">HSCTF 2020 Crypto - Randomization 1</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Randomization%201/2020-06-06-HSCTF-2020-Randomization-1" rel="alternate" type="text/html" title="HSCTF 2020 Crypto - Randomization 1" /><published>2020-06-06T00:00:00+05:30</published><updated>2020-06-06T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Randomization%201/HSCTF-2020-Randomization-1</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Randomization%201/2020-06-06-HSCTF-2020-Randomization-1"><![CDATA[<h1 id="randomization-1">Randomization 1</h1>

<p><img src="Capture.PNG" alt="" /></p>

<p>We are provided a binary <a href="rand1">rand1</a> which supposedly runs on the server. We have to figure out how would capture the flag</p>

<p>Lets decompile the binary quickly in <a href="https://ghidra-sre.org/">Ghidra</a>.<br />
Seeing the output of <code class="language-plaintext highlighter-rouge">main</code> function we get</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">undefined8</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>

<span class="p">{</span>
  <span class="n">uint</span> <span class="n">uVar1</span><span class="p">;</span>
  <span class="n">undefined8</span> <span class="n">uVar2</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">in_FS_OFFSET</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">local_1c</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">local_18</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">local_14</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">local_10</span><span class="p">;</span>
  
  <span class="n">local_10</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_FS_OFFSET</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">);</span>
  <span class="n">initRandom</span><span class="p">();</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"I heard LCGs were cool so I made my own"</span><span class="p">);</span>
  <span class="n">uVar1</span> <span class="o">=</span> <span class="n">next</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Since I</span><span class="se">\'</span><span class="s">m so generous you get a free number: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,(</span><span class="n">ulong</span><span class="p">)</span><span class="n">uVar1</span><span class="p">);</span>
  <span class="n">local_18</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// local_18 works as in iterator from 0 to 9</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">9</span> <span class="o">&lt;</span> <span class="n">local_18</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">win</span><span class="p">();</span>
      <span class="n">uVar2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">LAB_0010132e:</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">local_10</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_FS_OFFSET</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">))</span> <span class="p">{</span>
                    <span class="cm">/* WARNING: Subroutine does not return */</span>
        <span class="n">__stack_chk_fail</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">uVar2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Guess my number: "</span><span class="p">);</span>
    <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DAT_00102093</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_1c</span><span class="p">);</span>
    <span class="n">local_14</span> <span class="o">=</span> <span class="n">next</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">local_14</span> <span class="o">!=</span> <span class="n">local_1c</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">puts</span><span class="p">(</span><span class="s">"Wrong!"</span><span class="p">);</span>
      <span class="n">uVar2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">goto</span> <span class="n">LAB_0010132e</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">local_18</span> <span class="o">=</span> <span class="n">local_18</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As a quick overview, one could tell there is a loop which runs 10 times and after running 10 times successfully, it should spit out the flag.<br />
It asks for input 10 times, and each time it compares the value with return value of the function next().<br />
Taking a quick look of decompilaton of next</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ulong</span> <span class="nf">next</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>

<span class="p">{</span>
  <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span> <span class="o">*</span> <span class="sc">'%'</span> <span class="o">+</span> <span class="mh">0x41</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">curr</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>
<p>We see its a simple linear function, but the decompiled value seems off, it should actually be taking <code class="language-plaintext highlighter-rouge">curr</code> which is actually <code class="language-plaintext highlighter-rouge">local_14</code> and returning a <code class="language-plaintext highlighter-rouge">char</code> type.</p>

<p>As the start value is printed out before beginning the loop, we can predict all the values by writing a simple function</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">next_10</span><span class="p">(</span><span class="n">curr</span><span class="p">):</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
		<span class="n">curr</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr</span> <span class="o">*</span> <span class="mh">0x25</span> <span class="o">+</span> <span class="mh">0x41</span><span class="p">)</span><span class="o">%</span><span class="mi">256</span>
		<span class="k">print</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span> 
</code></pre></div></div>

<p>We dont need to bother about automating nc, just input all 10 values in one go as timing is not really an issue</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>I heard LCGs were cool so I made my own
Since I'm so generous you get a free number: 184
Guess my number: 217
158
23
148
165
26
3
176
177
214Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number:
flag{l1n34r_c0n6ru3n714l_63n3r470r_f41lur3_4b3bcd43}
</code></pre></div></div>
<p>BRAVO we did it</p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="HSCTF" /><category term="2020" /><category term="cryptograpy" /><category term="reversing" /><category term="LCG" /><summary type="html"><![CDATA[Randomization 1 We are provided a binary rand1 which supposedly runs on the server. We have to figure out how would capture the flag Lets decompile the binary quickly in Ghidra. Seeing the output of main function we get undefined8 main(void) { uint uVar1; undefined8 uVar2; long in_FS_OFFSET; int local_1c; int local_18; int local_14; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); initRandom(); puts("I heard LCGs were cool so I made my own"); uVar1 = next(); printf("Since I\'m so generous you get a free number: %d\n",(ulong)uVar1); local_18 = 0; // local_18 works as in iterator from 0 to 9 do { if (9 &lt; local_18) { win(); uVar2 = 0; LAB_0010132e: if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return uVar2; } printf("Guess my number: "); __isoc99_scanf(&amp;DAT_00102093,&amp;local_1c); local_14 = next(); if (local_14 != local_1c) { puts("Wrong!"); uVar2 = 1; goto LAB_0010132e; } local_18 = local_18 + 1; } while( true ); } As a quick overview, one could tell there is a loop which runs 10 times and after running 10 times successfully, it should spit out the flag. It asks for input 10 times, and each time it compares the value with return value of the function next(). Taking a quick look of decompilaton of next ulong next(void) { curr = curr * '%' + 0x41; return (ulong)curr; } We see its a simple linear function, but the decompiled value seems off, it should actually be taking curr which is actually local_14 and returning a char type. As the start value is printed out before beginning the loop, we can predict all the values by writing a simple function def next_10(curr): for i in range(10): curr = (curr * 0x25 + 0x41)%256 print(curr) We dont need to bother about automating nc, just input all 10 values in one go as timing is not really an issue I heard LCGs were cool so I made my own Since I'm so generous you get a free number: 184 Guess my number: 217 158 23 148 165 26 3 176 177 214Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: flag{l1n34r_c0n6ru3n714l_63n3r470r_f41lur3_4b3bcd43} BRAVO we did it]]></summary></entry><entry><title type="html">HSCTF 2020 Crypto - Randomization 2</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Randomization%202/2020-06-06-HSCTF-2020-Crypto-Randomization-2" rel="alternate" type="text/html" title="HSCTF 2020 Crypto - Randomization 2" /><published>2020-06-06T00:00:00+05:30</published><updated>2020-06-06T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Randomization%202/HSCTF-2020-Crypto-Randomization-2</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Randomization%202/2020-06-06-HSCTF-2020-Crypto-Randomization-2"><![CDATA[<h1 id="randomization-2">Randomization 2</h1>

<p><img src="Capture.png" alt="Screenshot" /></p>

<p>Again, we are provided a binary <a href="rand2">rand2</a> which runs on the server. On connecting to the server, weâ€™re provided with 2 numbers and then weâ€™re asked to guess the next numbers several(10) times.</p>

<p>Going ahead, letâ€™s use <a href="https://ghidra-sre.org/">Ghidra</a> to decompile this binary, and then work our ass off to understand the terrible decompiled code.
Just kiddingâ€¦</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">undefined8</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>

<span class="p">{</span>
  <span class="kt">long</span> <span class="n">lVar1</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">in_FS_OFFSET</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">local_1c</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">local_18</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">local_10</span><span class="p">;</span>
  
  <span class="n">local_10</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">in_FS_OFFSET</span> <span class="o">+</span> <span class="mi">40</span><span class="p">);</span>
  <span class="n">initRandom</span><span class="p">();</span>
  <span class="n">setvbuf</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">setvbuf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">local_18</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"I had a bit too much coffee so this is in Java not C"</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"(Actually it</span><span class="se">\'</span><span class="s">s still in C because Java is a pain)"</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Since I</span><span class="se">\'</span><span class="s">m so generous you get 2 free numbers"</span><span class="p">);</span>
  <span class="n">lVar1</span> <span class="o">=</span> <span class="n">next</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%llu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">lVar1</span><span class="p">);</span>
  <span class="n">lVar1</span> <span class="o">=</span> <span class="n">next</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%llu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">lVar1</span><span class="p">);</span>
  <span class="n">local_1c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">local_1c</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Guess my number: "</span><span class="p">);</span>
    <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DAT_001020e5</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_18</span><span class="p">);</span>
    <span class="n">lVar1</span> <span class="o">=</span> <span class="n">next</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lVar1</span> <span class="o">!=</span> <span class="n">local_18</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">puts</span><span class="p">(</span><span class="s">"WRONG!"</span><span class="p">);</span>
                    <span class="cm">/* WARNING: Subroutine does not return */</span>
      <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">local_1c</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"You win!"</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Have a flag: "</span><span class="p">);</span>
  <span class="n">win</span><span class="p">();</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">""</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">local_10</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="n">in_FS_OFFSET</span> <span class="o">+</span> <span class="mi">40</span><span class="p">))</span> <span class="p">{</span>
                    <span class="cm">/* WARNING: Subroutine does not return */</span>
    <span class="n">__stack_chk_fail</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Briefly, we can see an initRandom function and a next function which weâ€™ll look at just in a moment, and the loop runs 10 times and weâ€™re asked for a guess of the next number every time, and if all our guesses work out, weâ€™ll have the flag.</p>

<p>Moving over to the initRandom function:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">initRandom</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>

<span class="p">{</span>
  <span class="kt">int</span> <span class="n">iVar1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">local_14</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">local_10</span><span class="p">;</span>
  
  <span class="n">urandom</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"/dev/urandom"</span><span class="p">,</span><span class="s">"r"</span><span class="p">);</span>
  <span class="n">local_10</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">local_14</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">local_14</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">iVar1</span> <span class="o">=</span> <span class="n">fgetc</span><span class="p">(</span><span class="n">urandom</span><span class="p">);</span>
    <span class="n">local_10</span> <span class="o">=</span> <span class="n">local_10</span> <span class="o">*</span> <span class="mi">256</span> <span class="o">+</span> <span class="n">iVar1</span><span class="p">;</span>
    <span class="n">local_14</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">curr</span> <span class="o">=</span> <span class="n">local_10</span><span class="p">;</span>
  <span class="n">fclose</span><span class="p">(</span><span class="n">urandom</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Basically it initializes the seed to the PRNG, meh we neednâ€™t worry too much about this probably.</p>

<p>Then comes the next function:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">next</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>

<span class="p">{</span>
  <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span> <span class="o">*</span> <span class="mi">25214903917</span> <span class="o">+</span> <span class="mi">11</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">curr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Voila, this equation is what we wanted! But a catch, <code class="language-plaintext highlighter-rouge">long</code> values can be negative, but we donâ€™t see any negative numbers. Maybe it is <code class="language-plaintext highlighter-rouge">unsigned long</code> (64 bits, now we realize what the description probably meant).</p>

<p>Our linear PRNGâ€™s state comprises of just 1 number, so we donâ€™t even need the first number. Take the second number, and do the next function on it.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">25214903917</span><span class="o">+</span><span class="mi">11</span><span class="p">;</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If youâ€™re trying it out in Python, donâ€™t forget to take numbers modulo 2**64.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>I had a bit too much coffee so this is in Java not C
(Actually it's still in C because Java is a pain)
Since I'm so generous you get 2 free numbers
7258447304246973212
17116010196804995831
Guess my number: 16690969720309355830
6468650403376040969
4458106111961708000
8544260868340822123
785197920356155290
16490108719449469085
16773761617645535460
13390247135748110623
11364946156142406718
3626610375201229425
Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: You win!
Have a flag: flag{1n53cur3_r4nd0m_46b8861b}
</code></pre></div></div>

<p>Easy huh, turns out java.util.Random uses almost the same PRNG, DONâ€™T USE THIS FOR CRYPTO lol :triumph:</p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="HSCTF" /><category term="2020" /><category term="cryptography" /><category term="LCG" /><category term="reversing" /><summary type="html"><![CDATA[Randomization 2 Again, we are provided a binary rand2 which runs on the server. On connecting to the server, weâ€™re provided with 2 numbers and then weâ€™re asked to guess the next numbers several(10) times. Going ahead, letâ€™s use Ghidra to decompile this binary, and then work our ass off to understand the terrible decompiled code. Just kiddingâ€¦ undefined8 main(void) { long lVar1; long in_FS_OFFSET; int local_1c; long local_18; long local_10; local_10 = *(in_FS_OFFSET + 40); initRandom(); setvbuf(stdin,NULL,2,0); setvbuf(stdout,NULL,2,0); local_18 = 0; puts("I had a bit too much coffee so this is in Java not C"); puts("(Actually it\'s still in C because Java is a pain)"); puts("Since I\'m so generous you get 2 free numbers"); lVar1 = next(); printf("%llu\n",lVar1); lVar1 = next(); printf("%llu\n",lVar1); local_1c = 0; while (local_1c &lt; 10) { printf("Guess my number: "); __isoc99_scanf(&amp;DAT_001020e5,&amp;local_18); lVar1 = next(); if (lVar1 != local_18) { puts("WRONG!"); /* WARNING: Subroutine does not return */ exit(0); } local_1c += 1; } puts("You win!"); printf("Have a flag: "); win(); puts(""); if (local_10 != *(in_FS_OFFSET + 40)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return 0; } Briefly, we can see an initRandom function and a next function which weâ€™ll look at just in a moment, and the loop runs 10 times and weâ€™re asked for a guess of the next number every time, and if all our guesses work out, weâ€™ll have the flag. Moving over to the initRandom function: void initRandom(void) { int iVar1; int local_14; long local_10; urandom = fopen("/dev/urandom","r"); local_10 = 0; local_14 = 0; while (local_14 &lt; 8) { iVar1 = fgetc(urandom); local_10 = local_10 * 256 + iVar1; local_14 += 1; } curr = local_10; fclose(urandom); return; } Basically it initializes the seed to the PRNG, meh we neednâ€™t worry too much about this probably. Then comes the next function: long next(void) { curr = curr * 25214903917 + 11; return curr; } Voila, this equation is what we wanted! But a catch, long values can be negative, but we donâ€™t see any negative numbers. Maybe it is unsigned long (64 bits, now we realize what the description probably meant). Our linear PRNGâ€™s state comprises of just 1 number, so we donâ€™t even need the first number. Take the second number, and do the next function on it. #include &lt;bits/stdc++.h&gt; using namespace std; int main() { unsigned long x; cin &gt;&gt; x; for (int i = 0; i &lt; 10; i++) { x = x * 25214903917+11; cout &lt;&lt; x &lt;&lt; endl; } } If youâ€™re trying it out in Python, donâ€™t forget to take numbers modulo 2**64. I had a bit too much coffee so this is in Java not C (Actually it's still in C because Java is a pain) Since I'm so generous you get 2 free numbers 7258447304246973212 17116010196804995831 Guess my number: 16690969720309355830 6468650403376040969 4458106111961708000 8544260868340822123 785197920356155290 16490108719449469085 16773761617645535460 13390247135748110623 11364946156142406718 3626610375201229425 Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: You win! Have a flag: flag{1n53cur3_r4nd0m_46b8861b} Easy huh, turns out java.util.Random uses almost the same PRNG, DONâ€™T USE THIS FOR CRYPTO lol :triumph:]]></summary></entry><entry><title type="html">HSCTF 2020 Crypto - Smol E</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Smol%20E/2020-06-06-HSCTF-2020-Smol-E" rel="alternate" type="text/html" title="HSCTF 2020 Crypto - Smol E" /><published>2020-06-06T00:00:00+05:30</published><updated>2020-06-06T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Smol%20E/HSCTF-2020-Smol-E</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Smol%20E/2020-06-06-HSCTF-2020-Smol-E"><![CDATA[<h1 id="smol-e">Smol E</h1>

<p><img src="Capture.PNG" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>N = 163741039289512913448211316444208415089696281156598707546239939060930005300801050041110593445808590019811244791595198691653105173667082682192119631702680644123546329907362913533410257711393278981293987091294252121612050351292239086354120710656815218407878832422193841935690159084860401941224426397820742950923

E = 3

C1 = 110524539798470366613834133888472781069399552085868942087632499354651575111511036068021885688092481936060366815322764760005015342876190750877958695168393505027738910101191528175868547818851667359542590042073677436170569507102025782872063324950368166532649021589734367946954269468844281238141036170008727208883

C2 =
42406837735093367941682857892181550522346220427504754988544140886997339709785380303682471368168102002682892652577294324286913907635616629790484019421641636805493203989143298536257296680179745122126655008200829607192191208919525797616523271426092158734972067387818678258432674493723618035248340048171787246777
</code></pre></div></div>

<p>We have two ciphertexts and N, we can use <a href="https://crypto.stackexchange.com/questions/30884/help-understanding-basic-franklin-reiter-related-message-attack">Franklin Reiter related message attack</a>.<br />
But for that, we need the difference between the two messages. But since the messages are padded with a small pad, here we have another instance of <a href="https://en.wikipedia.org/wiki/Coppersmith%27s_attack">CopperSmithâ€™s Attack</a>. We have to use sage to solve this challenge. There are plenty of scripts for this, I used <a href="http://mslc.ctf.su/wp/confidence-ctf-2015-rsa1-crypto-400/">this nice script</a></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">n</span> <span class="o">=</span> <span class="mi">163741039289512913448211316444208415089696281156598707546239939060930005300801050041110593445808590019811244791595198691653105173667082682192119631702680644123546329907362913533410257711393278981293987091294252121612050351292239086354120710656815218407878832422193841935690159084860401941224426397820742950923</span>

<span class="n">e</span> <span class="o">=</span> <span class="mi">3</span>

<span class="n">C1</span> <span class="o">=</span> <span class="mi">110524539798470366613834133888472781069399552085868942087632499354651575111511036068021885688092481936060366815322764760005015342876190750877958695168393505027738910101191528175868547818851667359542590042073677436170569507102025782872063324950368166532649021589734367946954269468844281238141036170008727208883</span>

<span class="n">C2</span> <span class="o">=</span> <span class="mi">42406837735093367941682857892181550522346220427504754988544140886997339709785380303682471368168102002682892652577294324286913907635616629790484019421641636805493203989143298536257296680179745122126655008200829607192191208919525797616523271426092158734972067387818678258432674493723618035248340048171787246777</span>


<span class="n">PRxy</span><span class="p">.</span><span class="o">&lt;</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">Zmod</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="n">PRx</span><span class="p">.</span><span class="o">&lt;</span><span class="n">xn</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">Zmod</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>
<span class="n">PRZZ</span><span class="p">.</span><span class="o">&lt;</span><span class="n">xz</span><span class="p">,</span><span class="n">yz</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">PolynomialRing</span><span class="p">(</span><span class="n">Zmod</span><span class="p">(</span><span class="n">n</span><span class="p">))</span>

<span class="n">g1</span> <span class="o">=</span> <span class="n">x</span><span class="o">**</span><span class="n">e</span> <span class="o">-</span> <span class="n">C1</span>
<span class="n">g2</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="n">e</span> <span class="o">-</span> <span class="n">C2</span>

<span class="n">q1</span> <span class="o">=</span> <span class="n">g1</span><span class="p">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">PRZZ</span><span class="p">)</span>
<span class="n">q2</span> <span class="o">=</span> <span class="n">g2</span><span class="p">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">PRZZ</span><span class="p">)</span>

<span class="n">h</span> <span class="o">=</span> <span class="n">q2</span><span class="p">.</span><span class="n">resultant</span><span class="p">(</span><span class="n">q1</span><span class="p">)</span>
<span class="c1"># need to switch to univariate polynomial ring
# because .small_roots is implemented only for univariate
</span><span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">univariate_polynomial</span><span class="p">()</span> <span class="c1"># x is hopefully eliminated
</span><span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">change_ring</span><span class="p">(</span><span class="n">PRx</span><span class="p">).</span><span class="n">subs</span><span class="p">(</span><span class="n">y</span><span class="o">=</span><span class="n">xn</span><span class="p">)</span>
<span class="n">h</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">monic</span><span class="p">()</span>

<span class="n">roots</span> <span class="o">=</span> <span class="n">h</span><span class="p">.</span><span class="n">small_roots</span><span class="p">(</span><span class="n">X</span><span class="o">=</span><span class="mi">2</span><span class="o">**</span><span class="mi">60</span><span class="p">,</span> <span class="n">beta</span><span class="o">=</span><span class="mf">0.3</span><span class="p">)</span>
<span class="k">assert</span> <span class="n">roots</span><span class="p">,</span> <span class="s">"Failed1"</span>

<span class="n">diff</span> <span class="o">=</span> <span class="n">roots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">if</span> <span class="n">diff</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="o">**</span><span class="mi">32</span><span class="p">:</span>
    <span class="n">diff</span> <span class="o">=</span> <span class="o">-</span><span class="n">diff</span>
    <span class="n">C1</span><span class="p">,</span> <span class="n">C2</span> <span class="o">=</span> <span class="n">C2</span><span class="p">,</span> <span class="n">C1</span>

<span class="n">r</span> <span class="o">=</span> <span class="n">diff</span>
<span class="n">R</span><span class="p">.</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">Zmod</span><span class="p">(</span><span class="n">n</span><span class="p">)[]</span>
<span class="n">f1</span> <span class="o">=</span> <span class="n">X</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="n">C1</span>
<span class="n">f2</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span> <span class="o">+</span> <span class="n">r</span><span class="p">)</span><span class="o">^</span><span class="mi">3</span> <span class="o">-</span> <span class="n">C2</span>

<span class="c1"># GCD is not implemented for rings over composite modulus in Sage
</span><span class="k">def</span> <span class="nf">my_gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">monic</span><span class="p">()</span> <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">my_gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">a</span> <span class="o">%</span> <span class="n">b</span><span class="p">)</span>

<span class="n">mint</span><span class="o">=-</span><span class="n">my_gcd</span><span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">).</span><span class="n">coefficients</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">print</span><span class="p">(</span><span class="n">mint</span><span class="p">)</span> <span class="c1"># coefficient 0 = -m
</span><span class="k">print</span><span class="p">(</span><span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">mint</span><span class="o">&gt;&gt;</span><span class="mi">1</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]))</span>
</code></pre></div></div>

<p>Probably the most annoying part of the callenge was that pad was odd, making me think that the message is gibberish or I may be doing something wrong. Well smashing your head over something is the best part of ctf challenges I guess</p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="HSCTF" /><category term="2020" /><category term="cryptography" /><category term="RSA" /><category term="franklinreiter" /><category term="coppersmith" /><category term="smalle" /><summary type="html"><![CDATA[Smol E N = 163741039289512913448211316444208415089696281156598707546239939060930005300801050041110593445808590019811244791595198691653105173667082682192119631702680644123546329907362913533410257711393278981293987091294252121612050351292239086354120710656815218407878832422193841935690159084860401941224426397820742950923 E = 3 C1 = 110524539798470366613834133888472781069399552085868942087632499354651575111511036068021885688092481936060366815322764760005015342876190750877958695168393505027738910101191528175868547818851667359542590042073677436170569507102025782872063324950368166532649021589734367946954269468844281238141036170008727208883 C2 = 42406837735093367941682857892181550522346220427504754988544140886997339709785380303682471368168102002682892652577294324286913907635616629790484019421641636805493203989143298536257296680179745122126655008200829607192191208919525797616523271426092158734972067387818678258432674493723618035248340048171787246777 We have two ciphertexts and N, we can use Franklin Reiter related message attack. But for that, we need the difference between the two messages. But since the messages are padded with a small pad, here we have another instance of CopperSmithâ€™s Attack. We have to use sage to solve this challenge. There are plenty of scripts for this, I used this nice script n = 163741039289512913448211316444208415089696281156598707546239939060930005300801050041110593445808590019811244791595198691653105173667082682192119631702680644123546329907362913533410257711393278981293987091294252121612050351292239086354120710656815218407878832422193841935690159084860401941224426397820742950923 e = 3 C1 = 110524539798470366613834133888472781069399552085868942087632499354651575111511036068021885688092481936060366815322764760005015342876190750877958695168393505027738910101191528175868547818851667359542590042073677436170569507102025782872063324950368166532649021589734367946954269468844281238141036170008727208883 C2 = 42406837735093367941682857892181550522346220427504754988544140886997339709785380303682471368168102002682892652577294324286913907635616629790484019421641636805493203989143298536257296680179745122126655008200829607192191208919525797616523271426092158734972067387818678258432674493723618035248340048171787246777 PRxy.&lt;x,y&gt; = PolynomialRing(Zmod(n)) PRx.&lt;xn&gt; = PolynomialRing(Zmod(n)) PRZZ.&lt;xz,yz&gt; = PolynomialRing(Zmod(n)) g1 = x**e - C1 g2 = (x + y)**e - C2 q1 = g1.change_ring(PRZZ) q2 = g2.change_ring(PRZZ) h = q2.resultant(q1) # need to switch to univariate polynomial ring # because .small_roots is implemented only for univariate h = h.univariate_polynomial() # x is hopefully eliminated h = h.change_ring(PRx).subs(y=xn) h = h.monic() roots = h.small_roots(X=2**60, beta=0.3) assert roots, "Failed1" diff = roots[0] if diff &gt; 2**32: diff = -diff C1, C2 = C2, C1 r = diff R.&lt;X&gt; = Zmod(n)[] f1 = X^3 - C1 f2 = (X + r)^3 - C2 # GCD is not implemented for rings over composite modulus in Sage def my_gcd(a, b): return a.monic() if b == 0 else my_gcd(b, a % b) mint=-my_gcd(f1, f2).coefficients()[0] print(mint) # coefficient 0 = -m print(bytes.fromhex(hex(mint&gt;&gt;1)[2:])) Probably the most annoying part of the callenge was that pad was odd, making me think that the message is gibberish or I may be doing something wrong. Well smashing your head over something is the best part of ctf challenges I guess]]></summary></entry><entry><title type="html">HSCTF 2020 Crypto - Unexpected</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Unexpected/2020-06-06-HSCTF-2020-unexpected" rel="alternate" type="text/html" title="HSCTF 2020 Crypto - Unexpected" /><published>2020-06-06T00:00:00+05:30</published><updated>2020-06-06T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Unexpected/HSCTF-2020-unexpected</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Unexpected/2020-06-06-HSCTF-2020-unexpected"><![CDATA[<h1 id="unexpected">Unexpected</h1>

<p><img src="Capture.PNG" alt="" /></p>

<p>We are given 3 Nâ€™s and 3 Câ€™s and given that all three share primes
i.e</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>N1 = p*q
N2 = q*r
N3 = r*p
</code></pre></div></div>
<p>This is a problem of classic <a href="https://en.wikipedia.org/wiki/RSA_(cryptosystem)">RSA</a> with a small twist.<br />
Now, we know factoring N into their factors is hard. However this can be don easily considering we have a common factor between pairs of N
i.e q is a common factor of N1 and N2, r is a common factor of N2 and N3
and p is a common factor of N3 and N1.</p>

<p>Once we get p, q and r, we can easily calculate <a href="https://en.wikipedia.org/wiki/Euler%27s_totient_function">Euler Totien phi</a> and the modular inverse of E with respect to respective phis.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#python3
</span><span class="kn">import</span> <span class="nn">gmpy2</span>  <span class="c1">#Cool asf library
</span><span class="n">N1</span> <span class="o">=</span> <span class="mi">3895738302299059518129198422310169628530536557191890566210939781698372336257482186582163630847612416277492034959243510457939210010336159061758606919109259916143600981918456942199762738624796190838889500238780675229383463267807384154074134251073572174392024892486431125499446924573006208711810847272390619510395812856188247531815920797526102562723333957594242603466996229335924848954210939152042149332307810693239925149256224795031982752752336401872520016106145667479144091130160998875256860809091721275069193773739370057334041922519998813268278574260846083883264261920589114740823464192397850923545998904365370408113</span>

<span class="n">N2</span> <span class="o">=</span> <span class="mi">3036683903819675505741091164945461947189004916494633766372176282409409694958701211748277050499101511956962003835932755555293255586827283990400451317444723234406968971873530093281591689832798646915816609347861047534121792409030834659241904646743453387504496246791081682741245482378149293399372654558929658582070853972454887854658545741800574343930155288517185535533201220281739954820271979667081052363406511938025061398551356675540358212449132781674832812796443378476387659729623581274433769056775163718782871879747276327458473970177451591251859530403032170215968101310739004163533767679394201611410832974546802038041</span>

<span class="n">N3</span> <span class="o">=</span> <span class="mi">4793455677299549137382284585015750073239112414361680529255951318217960300841340399094743130287927996565298160174555422185410320841942637374406558835150138631140265626020072464652973386772727192540062051929655235552439145036105501434801984612127808829810146844869487529177642676245549299371487478280457673839725488195812744535928488844735950540356920273038857127652414836352483913807655170699520816765863272825856765769043174406026964068017257738085400965661973681558654658747878342173984592411085018242201038877382766239487564503728442821348064764166024851080258629751476765613997512620274759264076272801682962144457</span>

<span class="n">E</span> <span class="o">=</span> <span class="mi">65537</span>

<span class="n">C1</span> <span class="o">=</span> <span class="mi">396708474546125804352894757436683688457291028695044217325853929491171136935487190613513217479209066321213697066977005912522338337419604329864854419961723570625025089500459612736934675744115710978556346050350466970024450696226499749911198313775828281699871502987873199226066403667788132060336882800770615332190939846610876881382430101512212915247532319827304296610854802037475047119525110795533529161852951539770153761419387662527094415537933400873451490021233979268224054475360645920086811082803271848565851436058022797610887635287190533293980480191482625531855511415716253479184799509403767653927424232672209598509</span>

<span class="n">C2</span> <span class="o">=</span> <span class="mi">355006513750551550798931713354683491263062473879176656452255051848683497534660576981575518851351256702360823676609578259232763677292692743319345273559085724516350773319337226043634439282120083618718026203533033564167432280901197175559735572797382863132012675404876908914335941746393221402727788260354881773319480220225939283398326940847106630716629330817737251316474369640273632208347751866683363389016722969822345738247486942531821199790024647950924227337611907877819668593060172268197128413003269501597578146759488894526193598933152416894414296396043283131502951693668167550687432080480619240585408701379144341703</span>

<span class="n">C3</span> <span class="o">=</span> <span class="mi">924835278307680480966328618545268895077532556525413716080960421925985654497130329688156219485942736928562517552888163928270855659413958949301590302010862666331053838345196518237383846281768395909801043955047640003147798786793258813501366000503338638933238548605016169865688228297750780710248359326295693845663887055907900967535999885217905972006140096240831305484619796964713673839223632057905454213937054336962510051529266336629730913756688411854427999570223208667606703681762027957427028839409594591627448224813082072169775916331655060221445546199171668136050686471357710989346885039441000083764142021784018773006</span>


<span class="n">q</span> <span class="o">=</span> <span class="n">gmpy2</span><span class="p">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">N1</span><span class="p">,</span> <span class="n">N2</span><span class="p">)</span> <span class="c1"># taking q as greatest common divisor of N1 and N2
</span><span class="n">r</span> <span class="o">=</span> <span class="n">gmpy2</span><span class="p">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">N2</span><span class="p">,</span> <span class="n">N3</span><span class="p">)</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">gmpy2</span><span class="p">.</span><span class="n">gcd</span><span class="p">(</span><span class="n">N3</span><span class="p">,</span> <span class="n">N1</span><span class="p">)</span>

<span class="n">phi1</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># calculation of phi
</span><span class="n">phi2</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">phi3</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">p</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

<span class="n">d1</span> <span class="o">=</span> <span class="n">gmpy2</span><span class="p">.</span><span class="n">invert</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">phi1</span><span class="p">)</span> <span class="c1"># taking inverse of E modulo phi1
</span><span class="n">d2</span> <span class="o">=</span> <span class="n">gmpy2</span><span class="p">.</span><span class="n">invert</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">phi2</span><span class="p">)</span>
<span class="n">d3</span> <span class="o">=</span> <span class="n">gmpy2</span><span class="p">.</span><span class="n">invert</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">phi3</span><span class="p">)</span>

<span class="n">m1</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">C1</span><span class="p">,</span> <span class="n">d1</span><span class="p">,</span> <span class="n">N1</span><span class="p">)</span> <span class="c1"># decrypting ciphertexts with corresponding keys
</span><span class="n">m2</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">C2</span><span class="p">,</span> <span class="n">d2</span><span class="p">,</span> <span class="n">N2</span><span class="p">)</span>
<span class="n">m3</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">C3</span><span class="p">,</span> <span class="n">d3</span><span class="p">,</span> <span class="n">N3</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">m1</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">m2</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span> <span class="o">+</span> <span class="nb">hex</span><span class="p">(</span><span class="n">m3</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]).</span><span class="n">decode</span><span class="p">())</span>
<span class="c1"># flag{n0_0n3_3xp3ct5_th3_sp4nish_inquisiti0n!} I wasnt expecting that either
</span></code></pre></div></div>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="cryptography" /><category term="HSCTF" /><category term="2020" /><category term="RSA" /><category term="GCD" /><summary type="html"><![CDATA[Unexpected We are given 3 Nâ€™s and 3 Câ€™s and given that all three share primes i.e N1 = p*q N2 = q*r N3 = r*p This is a problem of classic RSA with a small twist. Now, we know factoring N into their factors is hard. However this can be don easily considering we have a common factor between pairs of N i.e q is a common factor of N1 and N2, r is a common factor of N2 and N3 and p is a common factor of N3 and N1. Once we get p, q and r, we can easily calculate Euler Totien phi and the modular inverse of E with respect to respective phis. #python3 import gmpy2 #Cool asf library N1 = 3895738302299059518129198422310169628530536557191890566210939781698372336257482186582163630847612416277492034959243510457939210010336159061758606919109259916143600981918456942199762738624796190838889500238780675229383463267807384154074134251073572174392024892486431125499446924573006208711810847272390619510395812856188247531815920797526102562723333957594242603466996229335924848954210939152042149332307810693239925149256224795031982752752336401872520016106145667479144091130160998875256860809091721275069193773739370057334041922519998813268278574260846083883264261920589114740823464192397850923545998904365370408113 N2 = 3036683903819675505741091164945461947189004916494633766372176282409409694958701211748277050499101511956962003835932755555293255586827283990400451317444723234406968971873530093281591689832798646915816609347861047534121792409030834659241904646743453387504496246791081682741245482378149293399372654558929658582070853972454887854658545741800574343930155288517185535533201220281739954820271979667081052363406511938025061398551356675540358212449132781674832812796443378476387659729623581274433769056775163718782871879747276327458473970177451591251859530403032170215968101310739004163533767679394201611410832974546802038041 N3 = 4793455677299549137382284585015750073239112414361680529255951318217960300841340399094743130287927996565298160174555422185410320841942637374406558835150138631140265626020072464652973386772727192540062051929655235552439145036105501434801984612127808829810146844869487529177642676245549299371487478280457673839725488195812744535928488844735950540356920273038857127652414836352483913807655170699520816765863272825856765769043174406026964068017257738085400965661973681558654658747878342173984592411085018242201038877382766239487564503728442821348064764166024851080258629751476765613997512620274759264076272801682962144457 E = 65537 C1 = 396708474546125804352894757436683688457291028695044217325853929491171136935487190613513217479209066321213697066977005912522338337419604329864854419961723570625025089500459612736934675744115710978556346050350466970024450696226499749911198313775828281699871502987873199226066403667788132060336882800770615332190939846610876881382430101512212915247532319827304296610854802037475047119525110795533529161852951539770153761419387662527094415537933400873451490021233979268224054475360645920086811082803271848565851436058022797610887635287190533293980480191482625531855511415716253479184799509403767653927424232672209598509 C2 = 355006513750551550798931713354683491263062473879176656452255051848683497534660576981575518851351256702360823676609578259232763677292692743319345273559085724516350773319337226043634439282120083618718026203533033564167432280901197175559735572797382863132012675404876908914335941746393221402727788260354881773319480220225939283398326940847106630716629330817737251316474369640273632208347751866683363389016722969822345738247486942531821199790024647950924227337611907877819668593060172268197128413003269501597578146759488894526193598933152416894414296396043283131502951693668167550687432080480619240585408701379144341703 C3 = 924835278307680480966328618545268895077532556525413716080960421925985654497130329688156219485942736928562517552888163928270855659413958949301590302010862666331053838345196518237383846281768395909801043955047640003147798786793258813501366000503338638933238548605016169865688228297750780710248359326295693845663887055907900967535999885217905972006140096240831305484619796964713673839223632057905454213937054336962510051529266336629730913756688411854427999570223208667606703681762027957427028839409594591627448224813082072169775916331655060221445546199171668136050686471357710989346885039441000083764142021784018773006 q = gmpy2.gcd(N1, N2) # taking q as greatest common divisor of N1 and N2 r = gmpy2.gcd(N2, N3) p = gmpy2.gcd(N3, N1) phi1 = (p - 1) * (q - 1) # calculation of phi phi2 = (q - 1) * (r - 1) phi3 = (r - 1) * (p - 1) d1 = gmpy2.invert(E, phi1) # taking inverse of E modulo phi1 d2 = gmpy2.invert(E, phi2) d3 = gmpy2.invert(E, phi3) m1 = pow(C1, d1, N1) # decrypting ciphertexts with corresponding keys m2 = pow(C2, d2, N2) m3 = pow(C3, d3, N3) print(bytes.fromhex(hex(m1)[2:] + hex(m2)[2:] + hex(m3)[2:]).decode()) # flag{n0_0n3_3xp3ct5_th3_sp4nish_inquisiti0n!} I wasnt expecting that either]]></summary></entry><entry><title type="html">HSCTF 2020 Crypto - XORed</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/XORed/2020-06-06-HSCTF-2020-XORed" rel="alternate" type="text/html" title="HSCTF 2020 Crypto - XORed" /><published>2020-06-06T00:00:00+05:30</published><updated>2020-06-06T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/XORed/HSCTF-2020-XORed</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/XORed/2020-06-06-HSCTF-2020-XORed"><![CDATA[<h1 id="xored">XORed</h1>

<p><img src="ChallengeDescription.PNG" alt="" /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>I was given the following equations. Can you help me decode the flag?
Key 1 = 5dcec311ab1a88ff66b69ef46d4aba1aee814fe00a4342055c146533
Key 1 ^ Key 3 = 9a13ea39f27a12000e083a860f1bd26e4a126e68965cc48bee3fa11b
Key 2 ^ Key 3 ^ Key 5 = 557ce6335808f3b812ce31c7230ddea9fb32bbaeaf8f0d4a540b4f05
Key 1 ^ Key 4 ^ Key 5 = 7b33428eb14e4b54f2f4a3acaeab1c2733e4ab6bebc68436177128eb
Key 3 ^ Key 4 = 996e59a867c171397fc8342b5f9a61d90bda51403ff6326303cb865a
Flag ^ Key 1 ^ Key 2 ^ Key 3 ^ Key 4 ^ Key 5 = 306d34c5b6dda0f53c7a0f5a2ce4596cfea5ecb676169dd7d5931139
</code></pre></div></div>

<p>We know XOR has the following properties</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Commutative: A âŠ• B = B âŠ• A
Associative: A âŠ• (B âŠ• C) = (A âŠ• B) âŠ• C
Identity: A âŠ• 0 = A
Self-Inverse: A âŠ• A = 0
</code></pre></div></div>

<p>So if we want to recover Flag from <code class="language-plaintext highlighter-rouge">Flag ^ Key1 ^ Key2 ^ Key3 ^ Key4 ^ Key5</code>, we need to XOR each of <code class="language-plaintext highlighter-rouge">Key1, Key2, Key3, Key4 and Key5</code> exactly once so that we end up only with flag</p>

<p>Notice that we dont need to recover each of the Key value. We can extract Flag (a bit) smartly. All we need is <code class="language-plaintext highlighter-rouge">Key1 ^ Key2 ^ Key3 ^ Key4 ^ Key5</code></p>

<p>We can get it by XORing (Key1 ^ Key3) ^ (Key2 ^ Key3 ^ Key5) ^ (Key3 ^ Key4)
Which is equvalent to Key1 <del>^Key3</del>^ Key2 ^ Key3 ^ Key5 ^ Key4 <del>^Key3</del>
Hence we get Flag as 
<code class="language-plaintext highlighter-rouge">(Flag ^ Key 1^ Key2 ^ Key3 ^ Key4 ^ Key5) ^ (Key1 ^ Key3) ^ (Key2 ^ Key3 ^ Key5) ^ (Key3 ^ Key4))</code></p>

<p>Here are multiple ways of doing it in python</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">pwn</span> <span class="kn">import</span> <span class="n">xor</span>
<span class="n">K13</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s">'9a13ea39f27a12000e083a860f1bd26e4a126e68965cc48bee3fa11b'</span><span class="p">)</span>
<span class="n">K235</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s">'557ce6335808f3b812ce31c7230ddea9fb32bbaeaf8f0d4a540b4f05'</span><span class="p">)</span>
<span class="n">K34</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s">'996e59a867c171397fc8342b5f9a61d90bda51403ff6326303cb865a'</span><span class="p">)</span>
<span class="n">F12345</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="s">'306d34c5b6dda0f53c7a0f5a2ce4596cfea5ecb676169dd7d5931139'</span><span class="p">)</span>

<span class="c1">#1 xor from pwntools
</span><span class="n">flag</span> <span class="o">=</span> <span class="n">xor</span><span class="p">(</span><span class="n">K13</span><span class="p">,</span> <span class="n">K235</span><span class="p">,</span> <span class="n">K34</span><span class="p">,</span> <span class="n">F12345</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">flag</span><span class="p">.</span><span class="n">decode</span><span class="p">())</span>

<span class="c1">#2 Doing shit yourself
</span><span class="n">flag</span> <span class="o">=</span> <span class="s">""</span><span class="p">.</span><span class="n">join</span><span class="p">([</span> <span class="nb">chr</span><span class="p">(</span><span class="n">K13</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">K235</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">K34</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">^</span> <span class="n">F12345</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">K13</span><span class="p">)</span> <span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>

<span class="c1">#flag{n0t_t00_h4rD_h0p3fully} YES
</span></code></pre></div></div>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="HSCTF" /><category term="2020" /><category term="cryptography" /><category term="xor" /><summary type="html"><![CDATA[XORed I was given the following equations. Can you help me decode the flag? Key 1 = 5dcec311ab1a88ff66b69ef46d4aba1aee814fe00a4342055c146533 Key 1 ^ Key 3 = 9a13ea39f27a12000e083a860f1bd26e4a126e68965cc48bee3fa11b Key 2 ^ Key 3 ^ Key 5 = 557ce6335808f3b812ce31c7230ddea9fb32bbaeaf8f0d4a540b4f05 Key 1 ^ Key 4 ^ Key 5 = 7b33428eb14e4b54f2f4a3acaeab1c2733e4ab6bebc68436177128eb Key 3 ^ Key 4 = 996e59a867c171397fc8342b5f9a61d90bda51403ff6326303cb865a Flag ^ Key 1 ^ Key 2 ^ Key 3 ^ Key 4 ^ Key 5 = 306d34c5b6dda0f53c7a0f5a2ce4596cfea5ecb676169dd7d5931139 We know XOR has the following properties Commutative: A âŠ• B = B âŠ• A Associative: A âŠ• (B âŠ• C) = (A âŠ• B) âŠ• C Identity: A âŠ• 0 = A Self-Inverse: A âŠ• A = 0 So if we want to recover Flag from Flag ^ Key1 ^ Key2 ^ Key3 ^ Key4 ^ Key5, we need to XOR each of Key1, Key2, Key3, Key4 and Key5 exactly once so that we end up only with flag Notice that we dont need to recover each of the Key value. We can extract Flag (a bit) smartly. All we need is Key1 ^ Key2 ^ Key3 ^ Key4 ^ Key5 We can get it by XORing (Key1 ^ Key3) ^ (Key2 ^ Key3 ^ Key5) ^ (Key3 ^ Key4) Which is equvalent to Key1 ^Key3^ Key2 ^ Key3 ^ Key5 ^ Key4 ^Key3 Hence we get Flag as (Flag ^ Key 1^ Key2 ^ Key3 ^ Key4 ^ Key5) ^ (Key1 ^ Key3) ^ (Key2 ^ Key3 ^ Key5) ^ (Key3 ^ Key4)) Here are multiple ways of doing it in python from pwn import xor K13 = bytes.fromhex('9a13ea39f27a12000e083a860f1bd26e4a126e68965cc48bee3fa11b') K235 = bytes.fromhex('557ce6335808f3b812ce31c7230ddea9fb32bbaeaf8f0d4a540b4f05') K34 = bytes.fromhex('996e59a867c171397fc8342b5f9a61d90bda51403ff6326303cb865a') F12345 = bytes.fromhex('306d34c5b6dda0f53c7a0f5a2ce4596cfea5ecb676169dd7d5931139') #1 xor from pwntools flag = xor(K13, K235, K34, F12345) print(flag.decode()) #2 Doing shit yourself flag = "".join([ chr(K13[i] ^ K235[i] ^ K34[i] ^ F12345[i]) for i in range(len(K13) ]) print(flag) #flag{n0t_t00_h4rD_h0p3fully} YES]]></summary></entry></feed>