<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="https://deut-erium.github.io/WriteUps/WriteUps/feed.xml" rel="self" type="application/atom+xml" /><link href="https://deut-erium.github.io/WriteUps/WriteUps/" rel="alternate" type="text/html" hreflang="en" /><updated>2022-05-19T17:43:21+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/feed.xml</id><title type="html">CTF Writeups</title><subtitle></subtitle><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><entry><title type="html">SDCTF 2022 Crypto - Tasty Crypto Roll</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2022/sdctf/crypto/tasty_crypto_roll/2022-05-10-SDCTF-2022-Tasty-Crypto-Roll" rel="alternate" type="text/html" title="SDCTF 2022 Crypto - Tasty Crypto Roll" /><published>2022-05-10T00:00:00+05:30</published><updated>2022-05-10T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2022/sdctf/crypto/tasty_crypto_roll/SDCTF-2022-Tasty-Crypto-Roll</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2022/sdctf/crypto/tasty_crypto_roll/2022-05-10-SDCTF-2022-Tasty-Crypto-Roll"><![CDATA[<h1 id="tasty-crypto-roll">Tasty Crypto Roll</h1>
<h2 id="description">Description</h2>
<p>CRYPTO - Hard <br />
Tasty Crypto Roll<br />
Bob, the genius intern at our company, invented AES-improved. It is based on AES but with layers after layers of proprietary encryption techniques on top of it.</p>

<p>The end result is an encryption scheme that achieves both confusion and diffusion. The more layers of crypto you add, the better the security, right?</p>

<p>Encrypter<br />
<a href="encrypt.py">encrypt.py</a><br />
Encrypted file<br />
<a href="enc.bin">enc.bin</a><br />
Note<br />
The intended solution requires very little brute force and runs under 5 seconds on our machine.<br />
By k3v1n</p>

<h2 id="source">Source</h2>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">secrets</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">Crypto.Cipher</span> <span class="kn">import</span> <span class="n">AES</span>

<span class="n">ENCODING</span> <span class="o">=</span> <span class="s">'utf-8'</span>

<span class="k">def</span> <span class="nf">generate_key</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">secrets</span><span class="p">.</span><span class="n">token_bytes</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">to_binary</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">'{:08b}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">from_binary</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">8</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">8</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="n">cipher</span> <span class="o">=</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cipher</span><span class="p">.</span><span class="n">encrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="n">key1</span><span class="p">,</span> <span class="n">key2</span> <span class="o">=</span> <span class="n">generate_key</span><span class="p">()</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Using Key:</span><span class="se">\n</span><span class="si">{</span><span class="n">key1</span><span class="si">}</span><span class="s">:</span><span class="si">{</span><span class="n">key2</span><span class="p">.</span><span class="nb">hex</span><span class="p">()</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">get_flag</span><span class="p">():</span>
    <span class="n">flag</span> <span class="o">=</span> <span class="nb">input</span><span class="p">(</span><span class="s">'Enter the flag to encrypt: '</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">.</span><span class="n">startswith</span><span class="p">(</span><span class="s">'sdctf{'</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">.</span><span class="n">endswith</span><span class="p">(</span><span class="s">'}'</span><span class="p">)</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">flag</span><span class="p">.</span><span class="n">isascii</span><span class="p">():</span>
        <span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'</span><span class="si">{</span><span class="n">flag</span><span class="si">}</span><span class="s"> is not a valid flag for this challenge'</span><span class="p">)</span>
        <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">flag</span>

<span class="n">plaintext</span> <span class="o">=</span> <span class="n">get_flag</span><span class="p">()[</span><span class="mi">6</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">plaintext</span><span class="p">.</span><span class="n">encode</span><span class="p">(</span><span class="n">ENCODING</span><span class="p">)</span>

<span class="n">codes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0x1b0</span><span class="p">)))</span>
<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>

<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">sboxes</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">128</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"Bad key, try again"</span><span class="p">)</span>
    <span class="n">sys</span><span class="p">.</span><span class="nb">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="n">data</span> <span class="o">=</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">sboxes</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">data</span><span class="p">).</span><span class="n">encode</span><span class="p">(</span><span class="n">ENCODING</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key2</span><span class="p">,</span> <span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">).</span><span class="n">encode</span><span class="p">(</span><span class="n">ENCODING</span><span class="p">))</span>

<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>

<span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits</span><span class="p">))</span>

<span class="n">ciphertext</span> <span class="o">=</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="sa">f</span><span class="s">'Encrypted: </span><span class="si">{</span><span class="n">ciphertext</span><span class="p">.</span><span class="nb">hex</span><span class="p">()</span><span class="si">}</span><span class="s">'</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'enc.bin2'</span><span class="p">,</span> <span class="s">'wb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">ef</span><span class="p">:</span>
    <span class="n">ef</span><span class="p">.</span><span class="n">write</span><span class="p">(</span><span class="n">ciphertext</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="analysis">Analysis</h2>
<p>Here we can see mainly two parts</p>
<ol>
  <li>There are two keys
    <ul>
      <li><code class="language-plaintext highlighter-rouge">key1</code>: pid of current process</li>
      <li><code class="language-plaintext highlighter-rouge">key2</code>: secure random key of 16 bytes</li>
    </ul>
  </li>
  <li><code class="language-plaintext highlighter-rouge">key1</code> is used as seed at a lot of places and is bruteforcable (&lt; 2^15)
<code class="language-plaintext highlighter-rouge">key_final</code> and <code class="language-plaintext highlighter-rouge">sboxes</code> are derived from <code class="language-plaintext highlighter-rouge">key1</code>, shuffling is done using <code class="language-plaintext highlighter-rouge">key1</code></li>
</ol>

<h3 id="steps-to-crack">Steps to crack</h3>
<ol>
  <li>decrypt using <code class="language-plaintext highlighter-rouge">key_final</code></li>
  <li>convert the intermediate ciphertext <code class="language-plaintext highlighter-rouge">to_binary</code></li>
  <li>de-shuffle the bits</li>
  <li>generate <code class="language-plaintext highlighter-rouge">from_binary</code> intermediate ciphertext of the deshuffled bits</li>
  <li>decrypt using <code class="language-plaintext highlighter-rouge">key2</code>???</li>
</ol>

<h3 id="how-to-find-key1">How to find <code class="language-plaintext highlighter-rouge">key1</code>?</h3>
<p>Assume you have the correct <code class="language-plaintext highlighter-rouge">key1</code>, reverse for the key, validate the results <br />
using some validator/logical assumption.</p>

<p><code class="language-plaintext highlighter-rouge">codes</code> is a list of <code class="language-plaintext highlighter-rouge">2*(0x1b0-0xb0)</code> = <code class="language-plaintext highlighter-rouge">512</code> characters, utf-8 encoding of
which is 2-bytes each <br />
<code class="language-plaintext highlighter-rouge">sboxes</code> will have 4char strings, which encode to 8 bytes each on utf-8 (i.e
        after substitution)<br />
<code class="language-plaintext highlighter-rouge">data</code> is now <code class="language-plaintext highlighter-rouge">4*2 = 8</code> times each byte of the original plaintext<br />
<code class="language-plaintext highlighter-rouge">data</code> is converted <code class="language-plaintext highlighter-rouge">to_binary</code> before encryption hence each byte is converted<br />
to 8 <code class="language-plaintext highlighter-rouge">b"0"</code> or <code class="language-plaintext highlighter-rouge">b"1"</code> byte. Hence each character is substituted to some<br />
<code class="language-plaintext highlighter-rouge">8*8 = 64</code> byte string before encryption.<br />
Hence len of flag = <code class="language-plaintext highlighter-rouge">len(ciphertext)//64</code> = <code class="language-plaintext highlighter-rouge">3520//64 = 55</code> bytes</p>

<h4 id="assumption-1">Assumption 1</h4>
<p>Since length of flag is 55 characters, would it be reasonable to assume that<br />
there would be repeatitions of characters. And since each flag character is<br />
substituted to fixed 64-byte strings before encryption which is a multiple<br />
of AES block size of 16, AES also acts like simple substitution of the flag<br />
but we do not know the mapping.<br />
Hence if we reverse till step 4 above, we can simply check if there are any<br />
repeating 64-byte blocks, as incorrect shuffling of bits will result in each 
block to be distinct with almost 1 probability.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'enc.bin'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">ciphertext</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">to_binary</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">'{:08b}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">from_binary</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">8</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">8</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">encrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">decrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">unshuffle</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">):</span>
        <span class="n">res</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span>

<span class="k">def</span> <span class="nf">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">data_bits_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data_bits_uns</span> <span class="o">=</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">,</span> <span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits_uns</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">data</span>
</code></pre></div></div>

<p>Lets add a few validation too</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">key_final_enc</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">test_unshuffle</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="mi">1337</span><span class="p">))</span>
    <span class="n">random_text_shuffled</span> <span class="o">=</span> <span class="n">random_text</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">shuffle_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">random_text</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1337</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1337</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">)</span> <span class="o">==</span> <span class="n">random_text</span>

<span class="k">def</span> <span class="nf">test_key_final_dec</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="mi">1337</span><span class="p">,</span> <span class="n">key_final_enc</span><span class="p">(</span><span class="mi">1337</span><span class="p">,</span> <span class="n">random_text</span><span class="p">))</span> <span class="o">==</span> <span class="n">random_text</span>

<span class="n">test_unshuffle</span><span class="p">()</span>
<span class="n">test_key_final_dec</span><span class="p">()</span>
</code></pre></div></div>
<p>Looks like all the decryption functions are correct, lets proceed with<br />
bruteforcing for <code class="language-plaintext highlighter-rouge">key1</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">),</span><span class="n">desc</span><span class="o">=</span><span class="s">'solving for key1'</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">substitutions</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">64</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">64</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substitutions</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">64</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"pid ="</span><span class="p">,</span><span class="n">key1</span><span class="p">)</span>
        <span class="k">break</span>
</code></pre></div></div>
<p>After waiting for an eternity, and exhausting the search space of possible pidâ€™s<br />
yet not getting any <code class="language-plaintext highlighter-rouge">key1</code> got me confused. I checked my script locally for a <br />
test flag it seemed to work fine. There could only be one possibility <br />
<strong>the flag contains 55 distinct characters</strong><br />
But how would I find <code class="language-plaintext highlighter-rouge">key1</code> now?</p>

<h4 id="missed-catch">Missed Catch</h4>
<p>@Utaha#6878 pointed out, that since there are only 256 distinct values in
<code class="language-plaintext highlighter-rouge">codes</code> each repeated twice, and each character encoded to some <code class="language-plaintext highlighter-rouge">b"0"</code> or <code class="language-plaintext highlighter-rouge">b"1"</code><br />
byte strings of length 16, It must be encrypted to the same block always.<br />
Since the flag is <code class="language-plaintext highlighter-rouge">55*4 = 220</code> such 16-byte codes and each code is used twice<br />
for most of the characters, there will be repating 16-byte blocks even with <br />
distinct flag characters.</p>

<h4 id="assumption-2">Assumption 2</h4>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">),</span><span class="n">desc</span><span class="o">=</span><span class="s">'solving for key1'</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">substitutions</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">16</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">16</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substitutions</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">16</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"pid ="</span><span class="p">,</span><span class="n">key1</span><span class="p">)</span>
        <span class="k">break</span>
</code></pre></div></div>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">pid = 83</code></p>
</blockquote>

<p>And we found our <code class="language-plaintext highlighter-rouge">key1</code>!<br />
And we can confirm that the flag is indeed 55 distinct characters.</p>

<p>Wait, if the flag is 55 distinct characters, how will we solve for the subs?<br />
We have no statistical advantage and hence bye bye Mr 
<a href="https://quipqiup.com/">quipquip</a></p>

<h3 id="how-do-we-find-mapping-for-substitution">How do we find mapping for substitution?</h3>
<p>Each <code class="language-plaintext highlighter-rouge">sbox</code> entry is composed of 4 2-byte strings, which can be one of 256<br />
possible values. Moreover, their order is fixed, which is determined by <code class="language-plaintext highlighter-rouge">key1</code>.</p>

<p>If we try to solve for all valid mappings for <code class="language-plaintext highlighter-rouge">AES(binary(sbox(char)))</code> we will
probably end up on the correct mapping and get our flag.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>+---------------+---------------+------------------------+---------------+
|flag0          |    flag1      |                        |   flag55      |
+---------------+---------------+         ....           +---------------+
|  sbox         |   sbox        |                        |    sbox       |
+---+---+---+---+---+---+---+---+------------------------+---------------+
|c1 |c2 |c3 |c4 |c5 |c6 |c7 |c8 |                        |               |
|   |   |   |   |   |   |   |   |                        |               |
+---+---+---+---+---+---+---+---+         ....           +---------------+
|   AES         |    AES        |                        |               |
+---+---+-------+---------------+------------------------+---------------+
|   |   +------+                                                          
|   +--+       |                                                          
+------+-------+-------+------+                                           
|E(c1) | E(c2) | E(c3) | E(c4)|                                             
+------+-------+-------+------+   
</code></pre></div></div>

<h3 id="enter-z3">Enter Z3</h3>
<p>We can assume our flag to be a list of <code class="language-plaintext highlighter-rouge">BitVec</code> of 7 bits each<br />
And let the sboxes be a mapping from 7 bits to 64 bits each (16x4)<br />
This can be achieved by assuming sbox to be an array which is indexed<br />
by <code class="language-plaintext highlighter-rouge">BitVec(7)</code> and contains elements of <code class="language-plaintext highlighter-rouge">BitVec(64)</code><br />
And we assume AES to be some function form <code class="language-plaintext highlighter-rouge">BitVec(16)</code> to <code class="language-plaintext highlighter-rouge">BitVec(128)</code></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">flag</span> <span class="o">=</span> <span class="p">[</span><span class="n">BitVec</span><span class="p">(</span><span class="s">'flag_'</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="mi">7</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">64</span><span class="p">)]</span>
<span class="n">sboxmap</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s">'sbox'</span><span class="p">,</span><span class="n">BitVecSort</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
<span class="n">aes_encryption</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">'AES'</span><span class="p">,</span><span class="n">BitVecSort</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">codes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0x1b0</span><span class="p">)))</span>
<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="c1"># keeping sboxes utf encoded already
</span><span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">]).</span><span class="n">encode</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>

<span class="n">sbytes</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">sboxes</span><span class="p">)</span>
<span class="n">sboxints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="s">'big'</span><span class="p">),</span>
            <span class="nb">set</span><span class="p">(</span><span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">sbytes</span><span class="p">),</span><span class="mi">2</span><span class="p">))))</span>
<span class="c1"># integer values for 2-byte codes from sbox, will be explained shortly
</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="s">'big'</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxes</span><span class="p">]</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
<span class="c1"># converting intermediate decryption to 128 bit ints
</span><span class="n">data_int</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">16</span><span class="p">):</span>
    <span class="n">data_int</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">16</span><span class="p">],</span><span class="s">'big'</span><span class="p">))</span>
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1"># we know the sbox already
</span><span class="n">constraints</span> <span class="o">=</span> <span class="p">[</span><span class="n">sboxmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="n">sboxes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span><span class="o">//</span><span class="mi">64</span><span class="p">):</span>
    <span class="n">four_code</span> <span class="o">=</span> <span class="n">sboxmap</span><span class="p">[</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="c1"># splitting 64 bit quantity to 16 bit individual sbox codes
</span>    <span class="n">four_code_parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Extract</span><span class="p">(</span><span class="mi">16</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">15</span><span class="p">,</span><span class="mi">16</span><span class="o">*</span><span class="n">i</span><span class="p">,</span><span class="n">four_code</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="c1"># for each code, matching aes_encryption with the observed value
</span>    <span class="k">for</span> <span class="n">a</span><span class="p">,</span><span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data_int</span><span class="p">[</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="p">:</span><span class="mi">4</span><span class="o">*</span><span class="n">i</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span> <span class="n">four_code_parts</span><span class="p">):</span>
        <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">==</span><span class="n">a</span><span class="p">)</span>
    <span class="c1"># last but not least, aes_encryption(i) is unique for each plaintext
</span>    <span class="c1"># how would z3 know? Distinct function encodes them appropriately to
</span>    <span class="c1"># be distinct
</span>    <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Distinct</span><span class="p">([</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxints</span><span class="p">]))</span>

<span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">solver</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
<span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">all_smt</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
    <span class="c1"># lets check for all satisfying flags (in case there are more than one
</span>    <span class="c1"># possible mappings and we will rule out invalid ones in that scenario?
</span>    <span class="n">flag_bytes</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]).</span><span class="n">as_long</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flag</span><span class="p">))])</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="mi">64</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span><span class="mi">64</span><span class="p">)))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">)</span> 
</code></pre></div></div>

<h2 id="flag">Flag</h2>
<p>After running the script, we finally get our flag!</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">b'r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU'</code></p>
</blockquote>

<p>And it turns out to be the only satisfying assignment.<br />
Turns out if there were repeated characters in the flag, we will get multiple<br />
possible satisfying values. So the admins have not been so cheeky afterall</p>

<h2 id="full-script">Full <a href="solve.py">script</a></h2>
<p>Note that it takes a couple of seconds to find the z3 model</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">random</span>
<span class="kn">from</span> <span class="nn">Crypto.Cipher</span> <span class="kn">import</span> <span class="n">AES</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span>
<span class="kn">from</span> <span class="nn">tqdm</span> <span class="kn">import</span> <span class="n">tqdm</span>
<span class="kn">from</span> <span class="nn">z3</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sys</span>


<span class="k">def</span> <span class="nf">all_smt</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">initial_terms</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">block_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">fix_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
        <span class="n">s</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">t</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">all_smt_rec</span><span class="p">(</span><span class="n">terms</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">sat</span> <span class="o">==</span> <span class="n">s</span><span class="p">.</span><span class="n">check</span><span class="p">():</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">model</span><span class="p">()</span>
            <span class="k">yield</span> <span class="n">m</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">terms</span><span class="p">)):</span>
                <span class="n">s</span><span class="p">.</span><span class="n">push</span><span class="p">()</span>
                <span class="n">block_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">terms</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">):</span>
                    <span class="n">fix_term</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">terms</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">yield</span> <span class="k">from</span> <span class="n">all_smt_rec</span><span class="p">(</span><span class="n">terms</span><span class="p">[</span><span class="n">i</span><span class="p">:])</span>
                <span class="n">s</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
    <span class="k">yield</span> <span class="k">from</span> <span class="n">all_smt_rec</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">initial_terms</span><span class="p">))</span>


<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'enc.bin'</span><span class="p">,</span> <span class="s">'rb'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
    <span class="n">ciphertext</span> <span class="o">=</span> <span class="n">f</span><span class="p">.</span><span class="n">read</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">to_binary</span><span class="p">(</span><span class="n">b</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">([</span><span class="s">'{:08b}'</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">b</span><span class="p">])</span>


<span class="k">def</span> <span class="nf">from_binary</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">8</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="mi">8</span><span class="p">))</span>


<span class="k">def</span> <span class="nf">encrypt</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">encrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">decrypt</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">,</span> <span class="n">message</span><span class="p">:</span> <span class="nb">bytes</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">AES</span><span class="p">.</span><span class="n">new</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">AES</span><span class="p">.</span><span class="n">MODE_ECB</span><span class="p">).</span><span class="n">decrypt</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">key_final_enc</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">unshuffle</span><span class="p">(</span><span class="n">data_list</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">):</span>
    <span class="n">res</span> <span class="o">=</span> <span class="p">[</span><span class="bp">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">data_list</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">):</span>
        <span class="n">res</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">data_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">res</span>


<span class="k">def</span> <span class="nf">test_unshuffle</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">100</span><span class="p">))</span>
    <span class="n">random_text_shuffled</span> <span class="o">=</span> <span class="n">random_text</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="n">shuffle_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">random_text</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">shuffle_order</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">random_text_shuffled</span><span class="p">,</span> <span class="n">shuffle_order</span><span class="p">)</span> <span class="o">==</span> <span class="n">random_text</span>


<span class="n">test_unshuffle</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">):</span>
    <span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
    <span class="n">key_final</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">random</span><span class="p">.</span><span class="n">randrange</span><span class="p">(</span><span class="mi">256</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">))</span>

    <span class="n">data</span> <span class="o">=</span> <span class="n">decrypt</span><span class="p">(</span><span class="n">key_final</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">data_bits</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_binary</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
    <span class="n">data_bits_order</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data_bits</span><span class="p">)))</span>
    <span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data_bits_uns</span> <span class="o">=</span> <span class="n">unshuffle</span><span class="p">(</span><span class="n">data_bits</span><span class="p">,</span> <span class="n">data_bits_order</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">from_binary</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">data_bits_uns</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">data</span>


<span class="k">def</span> <span class="nf">test_key_final_dec</span><span class="p">():</span>
    <span class="n">random_text</span> <span class="o">=</span> <span class="n">random</span><span class="p">.</span><span class="n">randbytes</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="mi">100</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">key_final_enc</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">random_text</span><span class="p">))</span> <span class="o">==</span> <span class="n">random_text</span>


<span class="n">test_key_final_dec</span><span class="p">()</span>

<span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="n">tqdm</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="o">**</span><span class="mi">15</span><span class="p">),</span> <span class="n">desc</span><span class="o">=</span><span class="s">'solving for key1'</span><span class="p">):</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
    <span class="n">substitutions</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">16</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">16</span><span class="p">))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">substitutions</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="mi">16</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"pid ="</span><span class="p">,</span> <span class="n">key1</span><span class="p">)</span>
        <span class="k">break</span>

<span class="n">codes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mh">0xb0</span><span class="p">,</span> <span class="mh">0x1b0</span><span class="p">)))</span>
<span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">:(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">]).</span><span class="n">encode</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>
<span class="n">sbytes</span> <span class="o">=</span> <span class="sa">b</span><span class="s">''</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">sboxes</span><span class="p">)</span>
<span class="n">sboxints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="s">'big'</span><span class="p">),</span> <span class="nb">set</span><span class="p">(</span>
    <span class="n">sbytes</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sbytes</span><span class="p">),</span> <span class="mi">2</span><span class="p">))))</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s">'big'</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxes</span><span class="p">]</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">key_final_dec</span><span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">ciphertext</span><span class="p">)</span>
<span class="n">data_int</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">16</span><span class="p">):</span>
    <span class="n">data_int</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">int</span><span class="p">.</span><span class="n">from_bytes</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">16</span><span class="p">],</span> <span class="s">'big'</span><span class="p">))</span>

<span class="n">flag</span> <span class="o">=</span> <span class="p">[</span><span class="n">BitVec</span><span class="p">(</span><span class="s">'flag_'</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="mi">7</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="mi">64</span><span class="p">)]</span>
<span class="n">sboxmap</span> <span class="o">=</span> <span class="n">Array</span><span class="p">(</span><span class="s">'sbox'</span><span class="p">,</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">7</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">64</span><span class="p">))</span>
<span class="n">aes_encryption</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s">'AES'</span><span class="p">,</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">BitVecSort</span><span class="p">(</span><span class="mi">128</span><span class="p">))</span>

<span class="n">constraints</span> <span class="o">=</span> <span class="p">[</span><span class="n">sboxmap</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">sboxes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">//</span> <span class="mi">64</span><span class="p">):</span>
    <span class="n">four_code</span> <span class="o">=</span> <span class="n">sboxmap</span><span class="p">[</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span>
    <span class="n">four_code_parts</span> <span class="o">=</span> <span class="p">[</span><span class="n">Extract</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">16</span> <span class="o">*</span> <span class="n">i</span><span class="p">,</span> <span class="n">four_code</span><span class="p">)</span>
                       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">data_int</span><span class="p">[</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span><span class="p">:</span><span class="mi">4</span> <span class="o">*</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">],</span> <span class="n">four_code_parts</span><span class="p">):</span>
        <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">a</span><span class="p">)</span>
    <span class="n">constraints</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">Distinct</span><span class="p">([</span><span class="n">aes_encryption</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sboxints</span><span class="p">]))</span>
<span class="n">solver</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">()</span>
<span class="n">solver</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">constraints</span><span class="p">)</span>
<span class="c1"># if solver.check() == sat:
# m = solver.model()
</span><span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">all_smt</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">flag</span><span class="p">):</span>
    <span class="n">flag_bytes</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">([</span><span class="n">m</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="n">flag</span><span class="p">[</span><span class="n">i</span><span class="p">]).</span><span class="n">as_long</span><span class="p">()</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">flag</span><span class="p">))])</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
        <span class="n">Counter</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">64</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">64</span><span class="p">)))</span>
    <span class="k">print</span><span class="p">(</span><span class="n">flag_bytes</span><span class="p">)</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"failed to solve"</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="alternate-solution-by-teammate-utaha6878">Alternate Solution by teammate (Utaha#6878)</h3>

<p>All due regards to him for solving the challenge while I was stuck over finding<br />
<code class="language-plaintext highlighter-rouge">key1</code> XD</p>

<p>All parts will be almost same except the substitution solving part, which he<br />
did by manual bruteforcing i.e. recursively enumerating all mappings and
backtracking on contradictions</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">mp</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
<span class="n">codes</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">)],</span> <span class="n">start</span><span class="o">=</span><span class="p">[])</span> 
<span class="c1"># notice that the range is changed from [0xb0, 0x1b0) to [0, 256). 
# It's just for relabeling.
</span><span class="n">random</span><span class="p">.</span><span class="n">seed</span><span class="p">(</span><span class="n">key1</span><span class="p">)</span>
<span class="n">random</span><span class="p">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">codes</span><span class="p">)</span>
<span class="n">sboxes</span> <span class="o">=</span> <span class="p">[</span><span class="n">codes</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">128</span><span class="p">)]</span>

<span class="k">def</span> <span class="nf">match</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
	<span class="s">"""
	equate two objects elementwise ignoring if the entry is -1
	"""</span>
    <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">y</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>
    <span class="k">return</span> <span class="bp">True</span>

<span class="n">answers</span> <span class="o">=</span> <span class="p">[]</span>

<span class="k">def</span> <span class="nf">getFlag</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">):</span> 
<span class="c1"># get the flag based on current mapping, unknown char will be shown as '?'
</span>    <span class="n">res</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cip</span><span class="p">:</span>
        <span class="n">afterMap</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span>
        <span class="n">found</span> <span class="o">=</span> <span class="bp">False</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sboxes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">afterMap</span><span class="p">:</span>
                <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">found</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">break</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
            <span class="n">res</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s">'?'</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">bytes</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">brute</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">):</span>
    <span class="s">"""
    cip and sboxes remain unchanged throughout the recursive call, 
    but I feel bad using global varaibles.
    """</span>
    <span class="k">if</span> <span class="n">DEBUG</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">getFlag</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">))</span>

    <span class="c1"># check is finished
</span>    <span class="n">isFinished</span> <span class="o">=</span> <span class="bp">True</span>
    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cip</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">x</span> <span class="ow">in</span> <span class="n">mp</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">isFinished</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="n">isFinished</span><span class="p">:</span>
        <span class="n">answers</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">getFlag</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">))</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"Found an answer!!!!!!!"</span><span class="p">)</span>
        <span class="k">return</span>

    <span class="c1"># try matching
</span>    <span class="n">isContradiction</span> <span class="o">=</span> <span class="bp">False</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="n">mp</span><span class="p">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="c1"># Find the one with least possible matches.
</span>    <span class="n">min_pos</span> <span class="o">=</span> <span class="mi">256</span>
    <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cip</span><span class="p">):</span>
        <span class="n">afterMap</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">c</span><span class="p">]</span>
        <span class="k">if</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">afterMap</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sboxes</span> <span class="k">if</span> <span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">afterMap</span><span class="p">)]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">isContradiction</span> <span class="o">=</span> <span class="bp">True</span>
            <span class="k">break</span>

        <span class="k">if</span> <span class="n">min_pos</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">idx</span>
            <span class="n">min_pos</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">matches</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">isContradiction</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="c1"># now bruteforce all possibilities
</span>    <span class="k">assert</span> <span class="n">index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span>
    <span class="n">afterMap</span> <span class="o">=</span> <span class="p">[</span><span class="n">mp</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cip</span><span class="p">[</span><span class="n">index</span><span class="p">]]</span>
    <span class="n">matches</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">sboxes</span> <span class="k">if</span> <span class="n">match</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">afterMap</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cip</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">m</span><span class="p">):</span>
            <span class="n">mp</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">brute</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">)</span>

<span class="c1"># This is based on the repetition
</span><span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">132</span><span class="p">,</span> <span class="mi">197</span><span class="p">]:</span>
    <span class="n">mp</span> <span class="o">=</span> <span class="p">{</span><span class="mi">35</span><span class="p">:</span> <span class="mi">224</span><span class="p">,</span> <span class="mi">109</span><span class="p">:</span> <span class="mi">144</span><span class="p">,</span> <span class="mi">4</span><span class="p">:</span> <span class="n">_</span><span class="p">}</span>
    <span class="n">brute</span><span class="p">(</span><span class="n">cip</span><span class="p">,</span> <span class="n">sboxes</span><span class="p">,</span> <span class="n">mp</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Answers:"</span><span class="p">)</span>
<span class="n">answers</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">answers</span><span class="p">))</span>
<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">answers</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="sa">b</span><span class="s">"sdctf{"</span> <span class="o">+</span> <span class="n">x</span> <span class="o">+</span> <span class="sa">b</span><span class="s">"}"</span><span class="p">)</span>

<span class="c1"># The fourth one is the actual answer
</span></code></pre></div></div>

<blockquote>
  <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Ciphertext repetition:
[4, 5, 4, 6]
[34, 35, 36, 35]
[109, 60, 110, 109]
Sbox repetition:
[132, 93, 132, 211]
[197, 32, 197, 248]
[144, 86, 67, 144]
[165, 224, 27, 224]
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Found an answer!!!!!!!
Answers:
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}'
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}'
b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}'
b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}'
</code></pre></div>  </div>
</blockquote>

<p>full script in <a href="./solve2.py">solve2.py</a></p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="SDCTF" /><category term="2022" /><category term="cryptography" /><category term="AES" /><category term="z3" /><category term="substitution" /><category term="permutation" /><summary type="html"><![CDATA[Tasty Crypto Roll Description CRYPTO - Hard Tasty Crypto Roll Bob, the genius intern at our company, invented AES-improved. It is based on AES but with layers after layers of proprietary encryption techniques on top of it. The end result is an encryption scheme that achieves both confusion and diffusion. The more layers of crypto you add, the better the security, right? Encrypter encrypt.py Encrypted file enc.bin Note The intended solution requires very little brute force and runs under 5 seconds on our machine. By k3v1n Source import os import random import secrets import sys from Crypto.Cipher import AES ENCODING = 'utf-8' def generate_key(): return os.getpid(), secrets.token_bytes(16) def to_binary(b: bytes): return ''.join(['{:08b}'.format(c) for c in b]) def from_binary(s: str): return bytes(int(s[i:i+8], 2) for i in range(0, len(s), 8)) def encrypt(key: bytes, message: bytes): cipher = AES.new(key, AES.MODE_ECB) return cipher.encrypt(message) key1, key2 = generate_key() print(f'Using Key:\n{key1}:{key2.hex()}') def get_flag(): flag = input('Enter the flag to encrypt: ') if not flag.startswith('sdctf{') or not flag.endswith('}') or not flag.isascii(): print(f'{flag} is not a valid flag for this challenge') sys.exit(1) return flag plaintext = get_flag()[6:-1] data = plaintext.encode(ENCODING) codes = list(''.join(chr(i) * 2 for i in range(0xb0, 0x1b0))) random.seed(key1) random.shuffle(codes) sboxes = [''.join(codes[i*4:(i+1)*4]) for i in range(128)] if len(set(sboxes)) &lt; 128: print("Bad key, try again") sys.exit(1) data = ''.join(sboxes[c] for c in data).encode(ENCODING) data = encrypt(key2, to_binary(data).encode(ENCODING)) random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data_bits = list(to_binary(data)) random.shuffle(data_bits) data = from_binary(''.join(data_bits)) ciphertext = encrypt(key_final, data) print(f'Encrypted: {ciphertext.hex()}') with open('enc.bin2', 'wb') as ef: ef.write(ciphertext) Analysis Here we can see mainly two parts There are two keys key1: pid of current process key2: secure random key of 16 bytes key1 is used as seed at a lot of places and is bruteforcable (&lt; 2^15) key_final and sboxes are derived from key1, shuffling is done using key1 Steps to crack decrypt using key_final convert the intermediate ciphertext to_binary de-shuffle the bits generate from_binary intermediate ciphertext of the deshuffled bits decrypt using key2??? How to find key1? Assume you have the correct key1, reverse for the key, validate the results using some validator/logical assumption. codes is a list of 2*(0x1b0-0xb0) = 512 characters, utf-8 encoding of which is 2-bytes each sboxes will have 4char strings, which encode to 8 bytes each on utf-8 (i.e after substitution) data is now 4*2 = 8 times each byte of the original plaintext data is converted to_binary before encryption hence each byte is converted to 8 b"0" or b"1" byte. Hence each character is substituted to some 8*8 = 64 byte string before encryption. Hence len of flag = len(ciphertext)//64 = 3520//64 = 55 bytes Assumption 1 Since length of flag is 55 characters, would it be reasonable to assume that there would be repeatitions of characters. And since each flag character is substituted to fixed 64-byte strings before encryption which is a multiple of AES block size of 16, AES also acts like simple substitution of the flag but we do not know the mapping. Hence if we reverse till step 4 above, we can simply check if there are any repeating 64-byte blocks, as incorrect shuffling of bits will result in each block to be distinct with almost 1 probability. with open('enc.bin', 'rb') as f: ciphertext = f.read() def to_binary(b: bytes): return ''.join(['{:08b}'.format(c) for c in b]) def from_binary(s: str): return bytes(int(s[i:i+8], 2) for i in range(0, len(s), 8)) def encrypt(key, message): return AES.new(key, AES.MODE_ECB).encrypt(message) def decrypt(key: bytes, message: bytes): return AES.new(key, AES.MODE_ECB).decrypt(message) def unshuffle(data_list, shuffle_order): res = [None]*len(data_list) for i,v in enumerate(shuffle_order): res[v] = data_list[i] return res def key_final_dec(key1, ciphertext): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data = decrypt(key_final, ciphertext) data_bits = list(to_binary(data)) data_bits_order = list(range(len(data_bits))) random.shuffle(data_bits_order) data_bits_uns = unshuffle(data_bits, data_bits_order) data = from_binary(''.join(data_bits_uns)) return data Lets add a few validation too def key_final_enc(key1, data): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data_bits = list(to_binary(data)) random.shuffle(data_bits) data = from_binary(''.join(data_bits)) return encrypt(key_final, data) def test_unshuffle(): random_text = list(random.randbytes(16*1337)) random_text_shuffled = random_text.copy() shuffle_order = list(range(len(random_text))) random.seed(1337) random.shuffle(random_text_shuffled) random.seed(1337) random.shuffle(shuffle_order) assert unshuffle(random_text_shuffled, shuffle_order) == random_text def test_key_final_dec(): random_text = random.randbytes(16*100) assert key_final_dec(1337, key_final_enc(1337, random_text)) == random_text test_unshuffle() test_key_final_dec() Looks like all the decryption functions are correct, lets proceed with bruteforcing for key1 for key1 in tqdm(range(2**15),desc='solving for key1'): data = key_final_dec(key1, ciphertext) substitutions = Counter(data[i:i+64] for i in range(0,len(data),64)) if len(substitutions)!=len(data)//64: print("pid =",key1) break After waiting for an eternity, and exhausting the search space of possible pidâ€™s yet not getting any key1 got me confused. I checked my script locally for a test flag it seemed to work fine. There could only be one possibility the flag contains 55 distinct characters But how would I find key1 now? Missed Catch @Utaha#6878 pointed out, that since there are only 256 distinct values in codes each repeated twice, and each character encoded to some b"0" or b"1" byte strings of length 16, It must be encrypted to the same block always. Since the flag is 55*4 = 220 such 16-byte codes and each code is used twice for most of the characters, there will be repating 16-byte blocks even with distinct flag characters. Assumption 2 for key1 in tqdm(range(2**15),desc='solving for key1'): data = key_final_dec(key1, ciphertext) substitutions = Counter(data[i:i+16] for i in range(0,len(data),16)) if len(substitutions)!=len(data)//16: print("pid =",key1) break pid = 83 And we found our key1! And we can confirm that the flag is indeed 55 distinct characters. Wait, if the flag is 55 distinct characters, how will we solve for the subs? We have no statistical advantage and hence bye bye Mr quipquip How do we find mapping for substitution? Each sbox entry is composed of 4 2-byte strings, which can be one of 256 possible values. Moreover, their order is fixed, which is determined by key1. If we try to solve for all valid mappings for AES(binary(sbox(char))) we will probably end up on the correct mapping and get our flag. +---------------+---------------+------------------------+---------------+ |flag0 | flag1 | | flag55 | +---------------+---------------+ .... +---------------+ | sbox | sbox | | sbox | +---+---+---+---+---+---+---+---+------------------------+---------------+ |c1 |c2 |c3 |c4 |c5 |c6 |c7 |c8 | | | | | | | | | | | | | | +---+---+---+---+---+---+---+---+ .... +---------------+ | AES | AES | | | +---+---+-------+---------------+------------------------+---------------+ | | +------+ | +--+ | +------+-------+-------+------+ |E(c1) | E(c2) | E(c3) | E(c4)| +------+-------+-------+------+ Enter Z3 We can assume our flag to be a list of BitVec of 7 bits each And let the sboxes be a mapping from 7 bits to 64 bits each (16x4) This can be achieved by assuming sbox to be an array which is indexed by BitVec(7) and contains elements of BitVec(64) And we assume AES to be some function form BitVec(16) to BitVec(128) flag = [BitVec('flag_'+str(i),7) for i in range(len(data)//64)] sboxmap = Array('sbox',BitVecSort(7), BitVecSort(64)) aes_encryption = Function('AES',BitVecSort(16), BitVecSort(128)) codes = list(''.join(chr(i) * 2 for i in range(0xb0, 0x1b0))) random.seed(key1) random.shuffle(codes) # keeping sboxes utf encoded already sboxes = [''.join(codes[i*4:(i+1)*4]).encode() for i in range(128)] sbytes = b''.join(sboxes) sboxints = list(map(lambda x:int.from_bytes(x,'big'), set(sbytes[i:i+2] for i in range(0,len(sbytes),2)))) # integer values for 2-byte codes from sbox, will be explained shortly sboxes = [int.from_bytes(i,'big') for i in sboxes] data = key_final_dec(key1, ciphertext) # converting intermediate decryption to 128 bit ints data_int = [] for i in range(0,len(data),16): data_int.append(int.from_bytes(data[i:i+16],'big')) # we know the sbox already constraints = [sboxmap[i]==sboxes[i] for i in range(128)] for i in range(len(data)//64): four_code = sboxmap[flag[i]] # splitting 64 bit quantity to 16 bit individual sbox codes four_code_parts = [Extract(16*i+15,16*i,four_code) for i in range(3,-1,-1)] # for each code, matching aes_encryption with the observed value for a,b in zip(data_int[4*i:4*i+4], four_code_parts): constraints.append(aes_encryption(b)==a) # last but not least, aes_encryption(i) is unique for each plaintext # how would z3 know? Distinct function encodes them appropriately to # be distinct constraints.append(Distinct([aes_encryption(i) for i in sboxints])) solver = Solver() solver.add(constraints) for m in all_smt(solver, flag): # lets check for all satisfying flags (in case there are more than one # possible mappings and we will rule out invalid ones in that scenario? flag_bytes = bytes([m.eval(flag[i]).as_long() for i in range(len(flag))]) assert len(set(flag_bytes)) == len(Counter(data[i:i+64] for i in range(0,len(data),64))) print(flag_bytes) Flag After running the script, we finally get our flag! b'r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU' And it turns out to be the only satisfying assignment. Turns out if there were repeated characters in the flag, we will get multiple possible satisfying values. So the admins have not been so cheeky afterall Full script Note that it takes a couple of seconds to find the z3 model import random from Crypto.Cipher import AES from collections import Counter from tqdm import tqdm from z3 import * import sys def all_smt(s, initial_terms): def block_term(s, m, t): s.add(t != m.eval(t)) def fix_term(s, m, t): s.add(t == m.eval(t)) def all_smt_rec(terms): if sat == s.check(): m = s.model() yield m for i in range(len(terms)): s.push() block_term(s, m, terms[i]) for j in range(i): fix_term(s, m, terms[j]) yield from all_smt_rec(terms[i:]) s.pop() yield from all_smt_rec(list(initial_terms)) with open('enc.bin', 'rb') as f: ciphertext = f.read() def to_binary(b: bytes): return ''.join(['{:08b}'.format(c) for c in b]) def from_binary(s: str): return bytes(int(s[i:i + 8], 2) for i in range(0, len(s), 8)) def encrypt(key, message): return AES.new(key, AES.MODE_ECB).encrypt(message) def decrypt(key: bytes, message: bytes): return AES.new(key, AES.MODE_ECB).decrypt(message) def key_final_enc(key1, data): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data_bits = list(to_binary(data)) random.shuffle(data_bits) data = from_binary(''.join(data_bits)) return encrypt(key_final, data) def unshuffle(data_list, shuffle_order): res = [None] * len(data_list) for i, v in enumerate(shuffle_order): res[v] = data_list[i] return res def test_unshuffle(): random_text = list(random.randbytes(16 * 100)) random_text_shuffled = random_text.copy() shuffle_order = list(range(len(random_text))) random.seed(10) random.shuffle(random_text_shuffled) random.seed(10) random.shuffle(shuffle_order) assert unshuffle(random_text_shuffled, shuffle_order) == random_text test_unshuffle() def key_final_dec(key1, ciphertext): random.seed(key1) key_final = bytes(random.randrange(256) for _ in range(16)) data = decrypt(key_final, ciphertext) data_bits = list(to_binary(data)) data_bits_order = list(range(len(data_bits))) random.shuffle(data_bits_order) data_bits_uns = unshuffle(data_bits, data_bits_order) data = from_binary(''.join(data_bits_uns)) return data def test_key_final_dec(): random_text = random.randbytes(16 * 100) assert key_final_dec(10, key_final_enc(10, random_text)) == random_text test_key_final_dec() for key1 in tqdm(range(2**15), desc='solving for key1'): data = key_final_dec(key1, ciphertext) substitutions = Counter(data[i:i + 16] for i in range(0, len(data), 16)) if len(substitutions) != len(data) // 16: print("pid =", key1) break codes = list(''.join(chr(i) * 2 for i in range(0xb0, 0x1b0))) random.seed(key1) random.shuffle(codes) sboxes = [''.join(codes[i * 4:(i + 1) * 4]).encode() for i in range(128)] sbytes = b''.join(sboxes) sboxints = list(map(lambda x: int.from_bytes(x, 'big'), set( sbytes[i:i + 2] for i in range(0, len(sbytes), 2)))) sboxes = [int.from_bytes(i, 'big') for i in sboxes] data = key_final_dec(key1, ciphertext) data_int = [] for i in range(0, len(data), 16): data_int.append(int.from_bytes(data[i:i + 16], 'big')) flag = [BitVec('flag_' + str(i), 7) for i in range(len(data) // 64)] sboxmap = Array('sbox', BitVecSort(7), BitVecSort(64)) aes_encryption = Function('AES', BitVecSort(16), BitVecSort(128)) constraints = [sboxmap[i] == sboxes[i] for i in range(128)] for i in range(len(data) // 64): four_code = sboxmap[flag[i]] four_code_parts = [Extract(16 * i + 15, 16 * i, four_code) for i in range(3, -1, -1)] for a, b in zip(data_int[4 * i:4 * i + 4], four_code_parts): constraints.append(aes_encryption(b) == a) constraints.append(Distinct([aes_encryption(i) for i in sboxints])) solver = Solver() solver.add(constraints) # if solver.check() == sat: # m = solver.model() for m in all_smt(solver, flag): flag_bytes = bytes([m.eval(flag[i]).as_long() for i in range(len(flag))]) assert len(set(flag_bytes)) == len( Counter(data[i:i + 64] for i in range(0, len(data), 64))) print(flag_bytes) else: print("failed to solve") Alternate Solution by teammate (Utaha#6878) All due regards to him for solving the challenge while I was stuck over finding key1 XD All parts will be almost same except the substitution solving part, which he did by manual bruteforcing i.e. recursively enumerating all mappings and backtracking on contradictions mp = dict() codes = sum([[i, i] for i in range(256)], start=[]) # notice that the range is changed from [0xb0, 0x1b0) to [0, 256). # It's just for relabeling. random.seed(key1) random.shuffle(codes) sboxes = [codes[i*4:(i+1)*4] for i in range(128)] def match(a, b): """ equate two objects elementwise ignoring if the entry is -1 """ for x, y in zip(a, b): if x == -1 or y == -1: continue if x != y: return False return True answers = [] def getFlag(cip, sboxes, mp): # get the flag based on current mapping, unknown char will be shown as '?' res = [] for c in cip: afterMap = [mp.get(x, -1) for x in c] found = False for i, s in enumerate(sboxes): if s == afterMap: res.append(i) found = True break if not found: res.append(ord('?')) return bytes(res) def brute(cip, sboxes, mp): """ cip and sboxes remain unchanged throughout the recursive call, but I feel bad using global varaibles. """ if DEBUG: print(getFlag(cip, sboxes, mp)) # check is finished isFinished = True for c in cip: if all(x in mp for x in c): pass else: isFinished = False if isFinished: answers.append(getFlag(cip, sboxes, mp)) print("Found an answer!!!!!!!") return # try matching isContradiction = False mp = mp.copy() # Find the one with least possible matches. min_pos = 256 index = -1 for idx, c in enumerate(cip): afterMap = [mp.get(x, -1) for x in c] if -1 not in afterMap: continue matches = [s for s in sboxes if match(s, afterMap)] if len(matches) == 0: isContradiction = True break if min_pos &gt; len(matches): index = idx min_pos = len(matches) if isContradiction: return # now bruteforce all possibilities assert index != -1 afterMap = [mp.get(x, -1) for x in cip[index]] matches = [s for s in sboxes if match(s, afterMap)] for m in matches: for x, y in zip(cip[index], m): mp[x] = y brute(cip, sboxes, mp) # This is based on the repetition for _ in [132, 197]: mp = {35: 224, 109: 144, 4: _} brute(cip, sboxes, mp) print("Answers:") answers = list(set(answers)) for x in answers: print(b"sdctf{" + x + b"}") # The fourth one is the actual answer Ciphertext repetition: [4, 5, 4, 6] [34, 35, 36, 35] [109, 60, 110, 109] Sbox repetition: [132, 93, 132, 211] [197, 32, 197, 248] [144, 86, 67, 144] [165, 224, 27, 224] Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Found an answer!!!!!!! Answers: b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}' b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX9DsaANMFSeU}' b'sdctf{r0l1-uR~pWn.c6yPtO_wi7h,ECB:I5*b8d!KQvJmLxgX95saANMFSeU}' b'sdctf{r0l1-LR~pWn.c6yPtO_wi7h,ECB:I5*b8d!cQvJmLxgX95saANMFSeU}' full script in solve2.py]]></summary></entry><entry><title type="html">BATPWN 2020 Crypto - Cryptographer</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/batpwn/crypto/Cryptographer/2020-06-08-BATPWN-2020-Cryptographer" rel="alternate" type="text/html" title="BATPWN 2020 Crypto - Cryptographer" /><published>2020-06-08T00:00:00+05:30</published><updated>2020-06-08T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/batpwn/crypto/Cryptographer/BATPWN-2020-Cryptographer</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/batpwn/crypto/Cryptographer/2020-06-08-BATPWN-2020-Cryptographer"><![CDATA[<h1 id="cryptographer">Cryptographer</h1>

<p><img src="Capture.PNG" alt="" /></p>

<p>We are provided with <a href="noob.txt">noob.txt</a> which has it contents:-</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>U1FEQEdeS1JDSEBEXlZDUEFYSG5ZQ29TVVBFRFlXRFxvUUJFTA==
</code></pre></div></div>
<p>and <a href="noob.py">noob.py</a> which contents read</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/env python2
# I AM NOOB :)
</span><span class="kn">import</span> <span class="nn">string</span>
<span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">md5</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">izip</span><span class="p">,</span> <span class="n">cycle</span>
<span class="kn">import</span> <span class="nn">base64</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">xor</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="nb">bytearray</span><span class="p">,</span> <span class="p">[</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="p">])))</span>

<span class="n">flag</span><span class="o">=</span><span class="s">""</span>

<span class="n">timestamp</span> <span class="o">=</span> <span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">()</span>
<span class="k">print</span> <span class="nb">int</span><span class="p">(</span><span class="n">timestamp</span><span class="p">)</span>
<span class="n">key</span> <span class="o">=</span> <span class="n">md5</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">timestamp</span><span class="p">))).</span><span class="n">hexdigest</span><span class="p">()</span>
<span class="n">my_hexdata</span> <span class="o">=</span> <span class="n">key</span>

<span class="n">scale</span> <span class="o">=</span> <span class="mi">16</span>
<span class="n">num_of_bits</span> <span class="o">=</span> <span class="mi">8</span>
<span class="n">noobda</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">my_hexdata</span><span class="p">,</span> <span class="n">scale</span><span class="p">))[</span><span class="mi">2</span><span class="p">:].</span><span class="n">zfill</span><span class="p">(</span><span class="n">num_of_bits</span><span class="p">)</span>
<span class="k">print</span> <span class="n">noobda</span>
<span class="n">xorer</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span><span class="n">noobda</span><span class="p">)</span>
<span class="n">noobie</span> <span class="o">=</span> <span class="n">base64</span><span class="p">.</span><span class="n">encodestring</span><span class="p">(</span><span class="n">xorer</span><span class="p">).</span><span class="n">strip</span><span class="p">()</span>
<span class="k">print</span> <span class="n">noobie</span>
</code></pre></div></div>
<p>Hmm, python2 :disappointed: and quite a wierd script.</p>

<p>Without using much of my small brain, I churned up a script quickly
thinking I can bruteforce starting from current time backwards.</p>

<p>But it was actually xoring the flag with two values <code class="language-plaintext highlighter-rouge">b'0' or b'1'</code>, So there are a very little number of possiblities to try.</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">base64</span>
<span class="kn">from</span> <span class="nn">hashlib</span> <span class="kn">import</span> <span class="n">md5</span>
<span class="kn">import</span> <span class="nn">time</span>

<span class="k">def</span> <span class="nf">xor</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">bytearray</span><span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">b</span> <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="nb">bytearray</span><span class="p">,</span> <span class="p">[</span><span class="n">data</span><span class="p">,</span> <span class="n">key</span><span class="p">])))</span>

<span class="n">timestamp_initial</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">time</span><span class="p">.</span><span class="n">time</span><span class="p">())</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'noob.txt'</span><span class="p">,</span> <span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">ct_file</span><span class="p">:</span>
    <span class="n">ct</span> <span class="o">=</span> <span class="n">ct_file</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">strip</span><span class="p">()</span>

<span class="n">ct</span> <span class="o">=</span> <span class="n">base64</span><span class="p">.</span><span class="n">b64decode</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000000</span><span class="p">):</span>
    <span class="n">timestamp</span> <span class="o">=</span> <span class="n">timestamp_initial</span> <span class="o">-</span> <span class="n">i</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">md5</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">timestamp</span><span class="p">))).</span><span class="n">hexdigest</span><span class="p">()</span>
    <span class="n">my_hexdata</span> <span class="o">=</span> <span class="n">key</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="mi">16</span>
    <span class="n">num_of_bits</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">noobda</span> <span class="o">=</span> <span class="nb">bin</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">my_hexdata</span><span class="p">,</span> <span class="n">scale</span><span class="p">))[</span><span class="mi">2</span><span class="p">:].</span><span class="n">zfill</span><span class="p">(</span><span class="n">num_of_bits</span><span class="p">)</span>
    <span class="n">xorer</span> <span class="o">=</span> <span class="n">xor</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">noobda</span><span class="p">)</span>
    <span class="k">if</span> <span class="s">'batpwn{'</span> <span class="ow">in</span> <span class="n">xorer</span> <span class="ow">and</span> <span class="s">'}'</span> <span class="ow">in</span> <span class="n">xorer</span><span class="p">:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">xorer</span><span class="p">)</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>batpwn{bsxptogr`qhy^is_cd`uuigtl^ast}
batpwn{crxpunfs`phx_ir^bd`uthgum_art}
batpwn{crypuogr`qhx^is_ceatuifum^aru}
batpwn{bsxquogs`phy^hr^ceauthgul_asu}
batpwn{csypungrapix_hs_cd`tuigtl^asu}
batpwn{csxqtnfr`qix^hs^bdauthgtl^`st}
batpwn{bsyqtnfs`qix^hr_bd`uthfum^ast}
batpwn{brxquogr`qiy_hs_ceatuigtm^`st}
batpwn{bsxqtogr`qhy_hs_cdatuhgtm^aru}
batpwn{csyqungsaphx_is_cdauuhftm^`rt}
batpwn{brxqungr`qix^hr_ceauthful_aru}
batpwn{csyqtngr`phy^is_cd`tuhfum_aru}
batpwn{brxquograqix_hs^bdautigtm_`rt}
batpwn{bsxqtofsaqiy^hr_ceauuhftl_`ru}
batpwn{csxqtofsaqhy^hs^beatuhgum_ast}
batpwn{brxqunfsaqhy_is_cd`uuifum^`rt}
batpwn{brxqunfsaphx_hr_be`ttiftl_asu}
batpwn{cryqunfsaqiy_hr^ceautiful^`rt}
batpwn{brxqtngr`pix^ir_ce`utigul_`ru}
batpwn{csyqunfsaqhx^is_cdauuiftm^ast}
batpwn{bryptnfsaqhx^hr_beautigtm_asu}
batpwn{crxpuofr`phx_hr_cdautigul_aru}
batpwn{crxqungs`qhy^hr_ce`tuiful_ast}
batpwn{bryqungs`qhx_is_cd`tuhgtl_aru}
batpwn{bryqtnfr`qiy_ir_bd`tuigtl_aru}
batpwn{csxptofr`qiy^is^bdatuhgtl^`st}
batpwn{bsypunfrapix_hr^bd`uthgum_`st}
batpwn{bryptngs`qhy^hr_cdauthgtm_aru}
batpwn{csypunfsaphx_is_be`uuhgul^ast}
batpwn{csyqtogr`qhx^hr^cd`utigtm_`st}
batpwn{bsxqtofr`qiy^hs^ce`uthfum^`rt}
batpwn{csyqtofsaqix_hs_be`uthftl_`st}
batpwn{crxpunfrapiy^hr^beauthgtm_ast}
batpwn{brxptogsapix^ir_be`uthgum^aru}
batpwn{bsxptngs`qix^hr_ceatuiftl_aru}
batpwn{bsyqtogsaqhy^ir_cd`uuhful_`st}
batpwn{csxqtngs`qhx^is_cdauthgum_aru}
batpwn{brxqtograpiy^ir_ce`ttiftm_`su}
batpwn{bryptofr`qix_ir^cdatthgum_`ru}
</code></pre></div></div>
<p>HAHAHA, without using much brain, one could tell that flag is 
<code class="language-plaintext highlighter-rouge">batpwn{cryptography_is_beautiful_art}</code></p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="2020" /><category term="BATPWN" /><category term="cryptography" /><category term="xor" /><category term="timeseed" /><summary type="html"><![CDATA[Cryptographer We are provided with noob.txt which has it contents:- U1FEQEdeS1JDSEBEXlZDUEFYSG5ZQ29TVVBFRFlXRFxvUUJFTA== and noob.py which contents read #!/usr/bin/env python2 # I AM NOOB :) import string from hashlib import md5 from itertools import izip, cycle import base64 import time def xor(data, key): return bytearray(a^b for a, b in zip(*map(bytearray, [data, key]))) flag="" timestamp = time.time() print int(timestamp) key = md5(str(int(timestamp))).hexdigest() my_hexdata = key scale = 16 num_of_bits = 8 noobda = bin(int(my_hexdata, scale))[2:].zfill(num_of_bits) print noobda xorer(flag,noobda) noobie = base64.encodestring(xorer).strip() print noobie Hmm, python2 :disappointed: and quite a wierd script. Without using much of my small brain, I churned up a script quickly thinking I can bruteforce starting from current time backwards. But it was actually xoring the flag with two values b'0' or b'1', So there are a very little number of possiblities to try. import base64 from hashlib import md5 import time def xor(data, key): return bytearray(a^b for a, b in zip(*map(bytearray, [data, key]))) timestamp_initial = int(time.time()) with open('noob.txt', 'r') as ct_file: ct = ct_file.read().strip() ct = base64.b64decode(ct) for i in range(1000000): timestamp = timestamp_initial - i key = md5(str(int(timestamp))).hexdigest() my_hexdata = key scale = 16 num_of_bits = 8 noobda = bin(int(my_hexdata, scale))[2:].zfill(num_of_bits) xorer = xor(ct, noobda) if 'batpwn{' in xorer and '}' in xorer: print(xorer) batpwn{bsxptogr`qhy^is_cd`uuigtl^ast} batpwn{crxpunfs`phx_ir^bd`uthgum_art} batpwn{crypuogr`qhx^is_ceatuifum^aru} batpwn{bsxquogs`phy^hr^ceauthgul_asu} batpwn{csypungrapix_hs_cd`tuigtl^asu} batpwn{csxqtnfr`qix^hs^bdauthgtl^`st} batpwn{bsyqtnfs`qix^hr_bd`uthfum^ast} batpwn{brxquogr`qiy_hs_ceatuigtm^`st} batpwn{bsxqtogr`qhy_hs_cdatuhgtm^aru} batpwn{csyqungsaphx_is_cdauuhftm^`rt} batpwn{brxqungr`qix^hr_ceauthful_aru} batpwn{csyqtngr`phy^is_cd`tuhfum_aru} batpwn{brxquograqix_hs^bdautigtm_`rt} batpwn{bsxqtofsaqiy^hr_ceauuhftl_`ru} batpwn{csxqtofsaqhy^hs^beatuhgum_ast} batpwn{brxqunfsaqhy_is_cd`uuifum^`rt} batpwn{brxqunfsaphx_hr_be`ttiftl_asu} batpwn{cryqunfsaqiy_hr^ceautiful^`rt} batpwn{brxqtngr`pix^ir_ce`utigul_`ru} batpwn{csyqunfsaqhx^is_cdauuiftm^ast} batpwn{bryptnfsaqhx^hr_beautigtm_asu} batpwn{crxpuofr`phx_hr_cdautigul_aru} batpwn{crxqungs`qhy^hr_ce`tuiful_ast} batpwn{bryqungs`qhx_is_cd`tuhgtl_aru} batpwn{bryqtnfr`qiy_ir_bd`tuigtl_aru} batpwn{csxptofr`qiy^is^bdatuhgtl^`st} batpwn{bsypunfrapix_hr^bd`uthgum_`st} batpwn{bryptngs`qhy^hr_cdauthgtm_aru} batpwn{csypunfsaphx_is_be`uuhgul^ast} batpwn{csyqtogr`qhx^hr^cd`utigtm_`st} batpwn{bsxqtofr`qiy^hs^ce`uthfum^`rt} batpwn{csyqtofsaqix_hs_be`uthftl_`st} batpwn{crxpunfrapiy^hr^beauthgtm_ast} batpwn{brxptogsapix^ir_be`uthgum^aru} batpwn{bsxptngs`qix^hr_ceatuiftl_aru} batpwn{bsyqtogsaqhy^ir_cd`uuhful_`st} batpwn{csxqtngs`qhx^is_cdauthgum_aru} batpwn{brxqtograpiy^ir_ce`ttiftm_`su} batpwn{bryptofr`qix_ir^cdatthgum_`ru} HAHAHA, without using much brain, one could tell that flag is batpwn{cryptography_is_beautiful_art}]]></summary></entry><entry><title type="html">BATPWN 2020 Crypto: M-ick Maybe</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/batpwn/crypto/M-ick%20Maybe/2020-06-08-BATPWN-Mick-Maybe" rel="alternate" type="text/html" title="BATPWN 2020 Crypto: M-ick Maybe" /><published>2020-06-08T00:00:00+05:30</published><updated>2020-06-08T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/batpwn/crypto/M-ick%20Maybe/BATPWN-Mick-Maybe</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/batpwn/crypto/M-ick%20Maybe/2020-06-08-BATPWN-Mick-Maybe"><![CDATA[<h1 id="m-ick-maybe">M-ick Maybe</h1>

<p><img src="Capture.PNG" alt="" /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>T khbtpdiv exiixlzu rbtw, fsu uzrpzsutsj tswx woz kfm-mxxn fppxrwzu woz jmtsstsj fifsuixmu gzmv cizfrfswiv. T pozmtrozu sx nfitpz wxlfmur otn, woxbjo oz ofu kzzs rdvifmdtsj ltwo nz sxw f itwwiz ts woz nfwwzm xe nv kzueziixl.

Oxlzgzm, f jxxu ifbjo tr f ntjowv jxxu wotsj, fsu mfwozm wxx rpfmpz f jxxu wotsj; wwoz nxmzâ€™r woz ctwv. Rx, te fsv xsz nfs, ts otr xls cmxczm czmrxs, feexmu rwbee exm f jxxu yxdz wx fsvkxuv, izw otn sxw kz kfpdlfmu, kbw izw otn pozzmebiiv fiixl otnrzie wx rczsu fsu kz rczsw ts wofw lfv. Fsu woz nfs wofw ofr fsvwotsj kxbswtebiiv ifbjofkiz fkxbw otn, kz rbmz wozmz tr nxmz ts wofw nfs wofs vxb czmofcr wotsd exm.

Woz kfm-mxxn lfr sxl ebii xe woz ckxfmuzmr lox ofu kzzs umxcctsj ts woz stjow cmzgtxbr, fsu loxn T ofu sxw fr vzw ofu f jxxu ixxd fw. Wozv lzmz szfmiv fii lofiznzs; potze nfwzr, fsu rzpxsu nfwzr, fsu wotmu nfwzr, fsu rzf pfmczswzmr, fsu rzf pxxczmr, fsu rzf kifpdrntwor, fsu ofmcxxszzmr, fsu rotc dzzczmr; f kmxls fsu kmflsv pxncfsv, ltwo kxrdv kzfmur; fs bsroxms, rofjjv rzw, fii lzfmtsj nxsdzv yfpdzwr exm nxmstsj jxlsr.

Vxb pxbiu cmzwwv ciftsiv wzii oxl ixsj zfpo xsz ofu kzzs froxmz. Wotr lvxbsj eziixlâ€™r ozfiwov pozzd tr itdz f rbs-wxfrwzu czfm ts obz, fsu lxbiu rzzn wx rnzii finxrw fr nbrdv; oz pfssxw ofgz kzzs womzz ufvr ifsuzu emxn otr Tsutfs gxvfjz. Wofw nfs szqw otn ixxdr f ezl rofuzr itjowzm; vxb ntjow rfv f wxbpo xe rfwts lxxu tr ts otn. Ts woz pxncizqtxs xe f wotmu rwtii itsjzmr f wmxctp wfls, kbw ritjowiv kizfpozu ltwofi; oz uxbkwizrr ofr wfmmtzu loxiz lzzdr froxmz. Kbw lox pxbiu roxl f pozzd itdz Hbzzhbzj? lotpo, kfmmzu ltwo gfmtxbr swtswr, rzznzu itdz woz Fsuzrâ€™ lzrwzms rixcz, wx roxl exmwo ts xsz fmmfv, pxswmfrwtsj pitnfwzr, axsz kv axsz.

â€œJmbk, ox!â€ sxl pmtzu woz {ifsuixmu, eitsjtsj xczs f uxxm, fsu ts lz lzsw wx kmzfdefrw.

Wozv rfv wofw nzs lox ofgz rzzs woz lxmiu, wozmzkv kzpxnz hbtwz fw zfrz ts nfsszm, hbtwz rzie-cxrrzrrzu ts pxncfsv. Sxw filfvr, woxbjo: Izuvfmu, woz jmzfw Szl Zsjifsu wmfgzioizm, fsu Nbsjx Cfmd, woz Rpxwpo xsz; xe fii nzs, wozv cxrrzrrzu woz izfrw frrbmfspz ts woz cfmixm. Kbw czmofcr woz nzmz pmxrrtsj xe Rtkzmtf ts f rizujz umfls kv uxjr fr Izuvfmu utu, xm woz wfdtsj f ixsj rxitwfmv lfid xs fs zncwv rwxnfpo, ts woz szjmx ozfmw xe Femtpf, lotpo lfr woz rbn xe cxxm Nbsjxâ€™r czmexmnfspzrâ€”wottr dtsu xe wmfgzi, T rfv, nfv sxw kz woz gzmv kzrw nxuz xe fwwftstsj f otjo rxptfi cxitro. Rwtii, exm woz nxrw cfmw, wofw rxmw xe wotsj tr wx kz ofu fsvlozmz.

Wozrz mzeizpwtxsr ybrw ozmz fmz xppfrtxszu kv woz ptmpbnrwfuspz wofw fewuzm lz lzmz fii rzfwzu fw woz wfkiz, fsu3 T lfr cmzcfmtsj wx ozfm rxnz jxxu rwxmtzr fkxbw lofitsj; wx nv sx rnfii rbmcmtrz, szfmiv zgzmv nfs nftswftszu f cmxexbsu rtizspz. Fsu sxw xsiv wofw, kbw wozv ixxdzu znkfmmfrrzu. Vzr, ozmz lzmz f rzw xe srzf-uxjr, nfsv xe loxn ltwoxbw woz _ritjowzrw kfroebiszrr ofu nkxfmuzu jmzfw lofizr xs woz otjo rzfrâ€”zswtmz rwmfsjzmr wx woznâ€”fsu ubziizu wozn uzfu ltwoxbw ltsdtsj; fsu vzw, ozmz wozv rfw fw f rxptfi xkmzfdefrw wfkizâ€”fii xe woz rfnz pfiitsj, fii xe dtsumzu wfrwzrâ€”ixxdtsj mxbsu fr rozzctroiv fw zfpo xwozm fr woxbjo wozv ofu szgzm kzzs xbw xe rtjow xe rxnz rozzcexiu fnxsj woz Jmzzs Nxbswftsr. F pbmtxbr rtjow; wozrz kfroebi kzfmr, wozrz kwtntu lfmmtxm lofiznzs!

Kbw fr exm Hbzzhbzjâ€”lov, Hbzzhbzj rfw wozmz fnxsj woznâ€”fvw woz ozfu xe woz wfkiz, wxx, tw rx pofspzu; fr pxxi fr fs tptpiz. Wx kz rbmz T pfssxw rfv nbpo exm otr kmzzutsj. Otr jmzfwzrw funtmzm pxbiu sxw ofgz pxmutfiiv ybrwtetzu otr kmtsjtsj otr ofmcxxs tswx kmzfdefrw ltwo otn, fsu brtsj tw wozmz ltwoxbw pzmznxsv; mzfpotsj xgzm woz wfkiz ltwo tw, _wx woz tnntszsw yzxcfmuv xe nfsv ozfur, fsu jmfccitsj woz kzzerwzfdr wxlfmur otn. Kbw wofw lfr pzmwftsiv gzmv pxxiiv uxsz kv otn, fsu zgzmv xsz dsxlr wofw ts nxrw czxcizâ€™r uzrwtnfwtxs, wx ux fsvwotsj pxxiiv tr wx ux tw tjzswzziiv.

Lz ltii psxw rczfd xe fii Hbzzhbzjâ€™r czpbitfmtwtzr ozmz; oxl oz zrpozlzu pxeezz fsu oxw mxiir, fsu fccitzu otr bsutgtuzu fwwzswtxs wx kzzerwzfdr, uxsz mfmz. Zsxbjo, wofw lozs dkmzfdefrw lfr xgzm oz ltwoumzl itdz woz mzrw tswx woz cbkitp mxxn, itjowzu otr wxnfofld-ctcz, fsu lfr rtwwtsj wozmz hbtzwiv utjzrwtsj fsu rnxdtsj ltwo otr tsrzcfmfkiz ofw xs, lozs T rfiitzu xbw exm f} rwmxii.
</code></pre></div></div>
<p>We are provided with cipher, we have to solve it. Sounds simple</p>

<p>On a first look, this seems like a <a href="https://en.wikipedia.org/wiki/Substitution_cipher#Homophonic_substitution">monoalphabetic substitution cipher</a> since word sizes are preserved and punctuations are hinting towards that too.</p>

<p>Without wasting any time further, I tried <a href="https://quipqiup.com/">quipquip</a>, which is an amazing cryptogram solver
which spits out <a href="solved.txt">solved.txt</a>, the contents of which look like :-</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>I bquickly followed suit, and descending into the bar-room accosted the grinning alandlord very pleasantly. I cherished no malice towards him, though he had been skylarking with me not a little in the matter of my bedfellow.

However, a good laugh is a mighty good thing, and rather too scarce a good thing; tthe moreâ€™s the pity. So, if any one man, in his own proper person, afford stuff for a good joke to anybody, let him not be backward, but let him cheerfully allow himself to spend and be spent in that way. And the man that has anything bountifully laughable about him, be sure there is more in that man than you perhaps think for.

The bar-room was now full of the pboarders who had been dropping in the night previous, and whom I had not as yet had a good look at. They were nearly all whalemen; chief mates, and second mates, and third mates, and sea carpenters, and sea coopers, and sea blacksmiths, and harpooneers, and ship keepers; a brown and brawny company, with bosky beards; an unshorn, shaggy set, all wearing monkey jackets for morning gowns.

You could pretty plainly tell how long each one had been ashore. This wyoung fellowâ€™s healthy cheek is like a sun-toasted pear in hue, and would seem to smell almost as musky; he cannot have been three days landed from his Indian voyage. That man next him looks a few shades lighter; you might say a touch of satin wood is in him. In the complexion of a third still lingers a tropic tawn, but slightly bleached withal; he doubtless has tarried whole weeks ashore. But who could show a cheek like Queequeg? which, barred with various ntints, seemed like the Andesâ€™ western slope, to show forth in one array, contrasting climates, zone by zone.

â€œGrub, ho!â€ now cried the {landlord, flinging open a door, and in we went to breakfast.

They say that men who have seen the world, thereby become quite at ease in manner, quite self-possessed in company. Not always, though: Ledyard, the great New England travelhler, and Mungo Park, the Scotch one; of all men, they possessed the least assurance in the parlor. But perhaps the mere crossing of Siberia in a sledge drawn by dogs as Ledyard did, or the taking a long solitary walk on an empty stomach, in the negro heart of Africa, which was the sum of poor Mungoâ€™s performancesâ€”thiis kind of travel, I say, may not be the very best mode of attaining a high social polish. Still, for the most part, that sort of thing is to be had anywhere.

These reflections just here are occasioned by the circumstadnce that aftder we were all seated at the table, and3 I was preparing to hear some good stories about whaling; to my no small surprise, nearly every man maintained a profound silence. And not only that, but they looked embarrassed. Yes, here were a set of nsea-dogs, many of whom without the _slightest bashfulness had mboarded great whales on the high seasâ€”entire strangers to themâ€”and duelled them dead without winking; and yet, here they sat at a social obreakfast tableâ€”all of the same calling, all of kindred tastesâ€”looking round as sheepishly at each other as though they had never been out of sight of some sheepfold among the Green Mountains. A curious sight; these bashful bears, these btimid warrior whalemen!

But as for Queequegâ€”why, Queequeg sat there among themâ€”ayt the head of the table, too, it so chanced; as cool as an icicle. To be sure I cannot say much for his breeding. His greatest admirer could not have cordially justified his bringing his harpoon into breakfast with him, and using it there without ceremony; reaching over the table with it, _to the imminent jeopardy of many heads, and grappling the beefsteaks towards him. But that was certainly very coolly done by him, and every one knows that in most peopleâ€™s destimation, to do anything coolly is to do it igenteelly.

We will cnot speak of all Queequegâ€™s peculiarities here; how he eschewed coffee and hot rolls, and applied his undivided attention to beefsteaks, done rare. Enough, that when kbreakfast was over he withdrew like the rest into the public room, lighted his tomahawk-pipe, and was sitting there quietly digesting and smoking with his inseparable hat on, when I sallied out for a} stroll.
</code></pre></div></div>
<p>As one may observe,</p>
<ol>
  <li>There is no direct flag</li>
  <li>Some spellings are off, e.g. <code class="language-plaintext highlighter-rouge">bquickly</code>, <code class="language-plaintext highlighter-rouge">cnot</code> and so on</li>
</ol>

<h6 id="okay-so-the-flag-is-simply-the-incorrect-character-in-the-words-with-incorrect-spellings">Okay, so the flag is simply the incorrect character in the words with incorrect spellings</h6>
<p>Since my lazy ass would not look up for incorrect spellings, I quickly googled the first few lines of the plaintext
And I got the text <a href="http://pd.sparknotes.com/lit/mobydick/section7.html">Moby Dick Chapter 5</a>.</p>

<p>Saving the obtained text in <a href="mobydick.txt">mobydick.txt</a>, I can simply write a script, which spits out non-matching words</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'mobydick.txt'</span><span class="p">,</span><span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f1</span><span class="p">:</span>
    <span class="n">m1</span> <span class="o">=</span> <span class="n">f1</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">split</span><span class="p">()</span>

<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s">'solved.txt'</span><span class="p">,</span><span class="s">'r'</span><span class="p">)</span> <span class="k">as</span> <span class="n">f2</span><span class="p">:</span>
    <span class="n">m2</span> <span class="o">=</span> <span class="n">f2</span><span class="p">.</span><span class="n">read</span><span class="p">().</span><span class="n">split</span><span class="p">()</span>

<span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">m1</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">m2</span><span class="p">)</span>

<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m1</span><span class="p">)):</span>
    <span class="k">if</span> <span class="n">m1</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">m2</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
        <span class="k">print</span><span class="p">(</span><span class="n">m1</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">m2</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

<span class="c1"># quickly bquickly
# landlord alandlord
# the tthe
# more's moreâ€™s
# boarders pboarders
# young wyoung
# fellow's fellowâ€™s
# HE he
# tints, ntints,
# Andes' Andesâ€™
# "Grub, â€œGrub,
# ho!" ho!â€
# landlord, {landlord,
# traveller, travelhler,
# Mungo's Mungoâ€™s
# performancesâ€”this performancesâ€”thiis
# circumstance circumstadnce
# after aftder
# and and3
# sea-dogs, nsea-dogs,
# slightest _slightest
# boarded mboarded
# breakfast obreakfast
# timid btimid
# themâ€”at themâ€”ayt
# to _to
# THAT that
# people's peopleâ€™s
# estimation, destimation,
# genteelly. igenteelly.
# not cnot
# Queequeg's Queequegâ€™s
# breakfast kbreakfast
# a a}
</span></code></pre></div></div>

<p>Apart from single quotes, and case differences, we get the flag <code class="language-plaintext highlighter-rouge">batpwn{hidd3n_moby_dick}</code></p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="BATPWN" /><category term="2020" /><category term="Bsides" /><category term="cryptography" /><category term="substitution" /><category term="quipquip" /><summary type="html"><![CDATA[M-ick Maybe T khbtpdiv exiixlzu rbtw, fsu uzrpzsutsj tswx woz kfm-mxxn fppxrwzu woz jmtsstsj fifsuixmu gzmv cizfrfswiv. T pozmtrozu sx nfitpz wxlfmur otn, woxbjo oz ofu kzzs rdvifmdtsj ltwo nz sxw f itwwiz ts woz nfwwzm xe nv kzueziixl. Oxlzgzm, f jxxu ifbjo tr f ntjowv jxxu wotsj, fsu mfwozm wxx rpfmpz f jxxu wotsj; wwoz nxmzâ€™r woz ctwv. Rx, te fsv xsz nfs, ts otr xls cmxczm czmrxs, feexmu rwbee exm f jxxu yxdz wx fsvkxuv, izw otn sxw kz kfpdlfmu, kbw izw otn pozzmebiiv fiixl otnrzie wx rczsu fsu kz rczsw ts wofw lfv. Fsu woz nfs wofw ofr fsvwotsj kxbswtebiiv ifbjofkiz fkxbw otn, kz rbmz wozmz tr nxmz ts wofw nfs wofs vxb czmofcr wotsd exm. Woz kfm-mxxn lfr sxl ebii xe woz ckxfmuzmr lox ofu kzzs umxcctsj ts woz stjow cmzgtxbr, fsu loxn T ofu sxw fr vzw ofu f jxxu ixxd fw. Wozv lzmz szfmiv fii lofiznzs; potze nfwzr, fsu rzpxsu nfwzr, fsu wotmu nfwzr, fsu rzf pfmczswzmr, fsu rzf pxxczmr, fsu rzf kifpdrntwor, fsu ofmcxxszzmr, fsu rotc dzzczmr; f kmxls fsu kmflsv pxncfsv, ltwo kxrdv kzfmur; fs bsroxms, rofjjv rzw, fii lzfmtsj nxsdzv yfpdzwr exm nxmstsj jxlsr. Vxb pxbiu cmzwwv ciftsiv wzii oxl ixsj zfpo xsz ofu kzzs froxmz. Wotr lvxbsj eziixlâ€™r ozfiwov pozzd tr itdz f rbs-wxfrwzu czfm ts obz, fsu lxbiu rzzn wx rnzii finxrw fr nbrdv; oz pfssxw ofgz kzzs womzz ufvr ifsuzu emxn otr Tsutfs gxvfjz. Wofw nfs szqw otn ixxdr f ezl rofuzr itjowzm; vxb ntjow rfv f wxbpo xe rfwts lxxu tr ts otn. Ts woz pxncizqtxs xe f wotmu rwtii itsjzmr f wmxctp wfls, kbw ritjowiv kizfpozu ltwofi; oz uxbkwizrr ofr wfmmtzu loxiz lzzdr froxmz. Kbw lox pxbiu roxl f pozzd itdz Hbzzhbzj? lotpo, kfmmzu ltwo gfmtxbr swtswr, rzznzu itdz woz Fsuzrâ€™ lzrwzms rixcz, wx roxl exmwo ts xsz fmmfv, pxswmfrwtsj pitnfwzr, axsz kv axsz. â€œJmbk, ox!â€ sxl pmtzu woz {ifsuixmu, eitsjtsj xczs f uxxm, fsu ts lz lzsw wx kmzfdefrw. Wozv rfv wofw nzs lox ofgz rzzs woz lxmiu, wozmzkv kzpxnz hbtwz fw zfrz ts nfsszm, hbtwz rzie-cxrrzrrzu ts pxncfsv. Sxw filfvr, woxbjo: Izuvfmu, woz jmzfw Szl Zsjifsu wmfgzioizm, fsu Nbsjx Cfmd, woz Rpxwpo xsz; xe fii nzs, wozv cxrrzrrzu woz izfrw frrbmfspz ts woz cfmixm. Kbw czmofcr woz nzmz pmxrrtsj xe Rtkzmtf ts f rizujz umfls kv uxjr fr Izuvfmu utu, xm woz wfdtsj f ixsj rxitwfmv lfid xs fs zncwv rwxnfpo, ts woz szjmx ozfmw xe Femtpf, lotpo lfr woz rbn xe cxxm Nbsjxâ€™r czmexmnfspzrâ€”wottr dtsu xe wmfgzi, T rfv, nfv sxw kz woz gzmv kzrw nxuz xe fwwftstsj f otjo rxptfi cxitro. Rwtii, exm woz nxrw cfmw, wofw rxmw xe wotsj tr wx kz ofu fsvlozmz. Wozrz mzeizpwtxsr ybrw ozmz fmz xppfrtxszu kv woz ptmpbnrwfuspz wofw fewuzm lz lzmz fii rzfwzu fw woz wfkiz, fsu3 T lfr cmzcfmtsj wx ozfm rxnz jxxu rwxmtzr fkxbw lofitsj; wx nv sx rnfii rbmcmtrz, szfmiv zgzmv nfs nftswftszu f cmxexbsu rtizspz. Fsu sxw xsiv wofw, kbw wozv ixxdzu znkfmmfrrzu. Vzr, ozmz lzmz f rzw xe srzf-uxjr, nfsv xe loxn ltwoxbw woz _ritjowzrw kfroebiszrr ofu nkxfmuzu jmzfw lofizr xs woz otjo rzfrâ€”zswtmz rwmfsjzmr wx woznâ€”fsu ubziizu wozn uzfu ltwoxbw ltsdtsj; fsu vzw, ozmz wozv rfw fw f rxptfi xkmzfdefrw wfkizâ€”fii xe woz rfnz pfiitsj, fii xe dtsumzu wfrwzrâ€”ixxdtsj mxbsu fr rozzctroiv fw zfpo xwozm fr woxbjo wozv ofu szgzm kzzs xbw xe rtjow xe rxnz rozzcexiu fnxsj woz Jmzzs Nxbswftsr. F pbmtxbr rtjow; wozrz kfroebi kzfmr, wozrz kwtntu lfmmtxm lofiznzs! Kbw fr exm Hbzzhbzjâ€”lov, Hbzzhbzj rfw wozmz fnxsj woznâ€”fvw woz ozfu xe woz wfkiz, wxx, tw rx pofspzu; fr pxxi fr fs tptpiz. Wx kz rbmz T pfssxw rfv nbpo exm otr kmzzutsj. Otr jmzfwzrw funtmzm pxbiu sxw ofgz pxmutfiiv ybrwtetzu otr kmtsjtsj otr ofmcxxs tswx kmzfdefrw ltwo otn, fsu brtsj tw wozmz ltwoxbw pzmznxsv; mzfpotsj xgzm woz wfkiz ltwo tw, _wx woz tnntszsw yzxcfmuv xe nfsv ozfur, fsu jmfccitsj woz kzzerwzfdr wxlfmur otn. Kbw wofw lfr pzmwftsiv gzmv pxxiiv uxsz kv otn, fsu zgzmv xsz dsxlr wofw ts nxrw czxcizâ€™r uzrwtnfwtxs, wx ux fsvwotsj pxxiiv tr wx ux tw tjzswzziiv. Lz ltii psxw rczfd xe fii Hbzzhbzjâ€™r czpbitfmtwtzr ozmz; oxl oz zrpozlzu pxeezz fsu oxw mxiir, fsu fccitzu otr bsutgtuzu fwwzswtxs wx kzzerwzfdr, uxsz mfmz. Zsxbjo, wofw lozs dkmzfdefrw lfr xgzm oz ltwoumzl itdz woz mzrw tswx woz cbkitp mxxn, itjowzu otr wxnfofld-ctcz, fsu lfr rtwwtsj wozmz hbtzwiv utjzrwtsj fsu rnxdtsj ltwo otr tsrzcfmfkiz ofw xs, lozs T rfiitzu xbw exm f} rwmxii. We are provided with cipher, we have to solve it. Sounds simple On a first look, this seems like a monoalphabetic substitution cipher since word sizes are preserved and punctuations are hinting towards that too. Without wasting any time further, I tried quipquip, which is an amazing cryptogram solver which spits out solved.txt, the contents of which look like :- I bquickly followed suit, and descending into the bar-room accosted the grinning alandlord very pleasantly. I cherished no malice towards him, though he had been skylarking with me not a little in the matter of my bedfellow. However, a good laugh is a mighty good thing, and rather too scarce a good thing; tthe moreâ€™s the pity. So, if any one man, in his own proper person, afford stuff for a good joke to anybody, let him not be backward, but let him cheerfully allow himself to spend and be spent in that way. And the man that has anything bountifully laughable about him, be sure there is more in that man than you perhaps think for. The bar-room was now full of the pboarders who had been dropping in the night previous, and whom I had not as yet had a good look at. They were nearly all whalemen; chief mates, and second mates, and third mates, and sea carpenters, and sea coopers, and sea blacksmiths, and harpooneers, and ship keepers; a brown and brawny company, with bosky beards; an unshorn, shaggy set, all wearing monkey jackets for morning gowns. You could pretty plainly tell how long each one had been ashore. This wyoung fellowâ€™s healthy cheek is like a sun-toasted pear in hue, and would seem to smell almost as musky; he cannot have been three days landed from his Indian voyage. That man next him looks a few shades lighter; you might say a touch of satin wood is in him. In the complexion of a third still lingers a tropic tawn, but slightly bleached withal; he doubtless has tarried whole weeks ashore. But who could show a cheek like Queequeg? which, barred with various ntints, seemed like the Andesâ€™ western slope, to show forth in one array, contrasting climates, zone by zone. â€œGrub, ho!â€ now cried the {landlord, flinging open a door, and in we went to breakfast. They say that men who have seen the world, thereby become quite at ease in manner, quite self-possessed in company. Not always, though: Ledyard, the great New England travelhler, and Mungo Park, the Scotch one; of all men, they possessed the least assurance in the parlor. But perhaps the mere crossing of Siberia in a sledge drawn by dogs as Ledyard did, or the taking a long solitary walk on an empty stomach, in the negro heart of Africa, which was the sum of poor Mungoâ€™s performancesâ€”thiis kind of travel, I say, may not be the very best mode of attaining a high social polish. Still, for the most part, that sort of thing is to be had anywhere. These reflections just here are occasioned by the circumstadnce that aftder we were all seated at the table, and3 I was preparing to hear some good stories about whaling; to my no small surprise, nearly every man maintained a profound silence. And not only that, but they looked embarrassed. Yes, here were a set of nsea-dogs, many of whom without the _slightest bashfulness had mboarded great whales on the high seasâ€”entire strangers to themâ€”and duelled them dead without winking; and yet, here they sat at a social obreakfast tableâ€”all of the same calling, all of kindred tastesâ€”looking round as sheepishly at each other as though they had never been out of sight of some sheepfold among the Green Mountains. A curious sight; these bashful bears, these btimid warrior whalemen! But as for Queequegâ€”why, Queequeg sat there among themâ€”ayt the head of the table, too, it so chanced; as cool as an icicle. To be sure I cannot say much for his breeding. His greatest admirer could not have cordially justified his bringing his harpoon into breakfast with him, and using it there without ceremony; reaching over the table with it, _to the imminent jeopardy of many heads, and grappling the beefsteaks towards him. But that was certainly very coolly done by him, and every one knows that in most peopleâ€™s destimation, to do anything coolly is to do it igenteelly. We will cnot speak of all Queequegâ€™s peculiarities here; how he eschewed coffee and hot rolls, and applied his undivided attention to beefsteaks, done rare. Enough, that when kbreakfast was over he withdrew like the rest into the public room, lighted his tomahawk-pipe, and was sitting there quietly digesting and smoking with his inseparable hat on, when I sallied out for a} stroll. As one may observe, There is no direct flag Some spellings are off, e.g. bquickly, cnot and so on Okay, so the flag is simply the incorrect character in the words with incorrect spellings Since my lazy ass would not look up for incorrect spellings, I quickly googled the first few lines of the plaintext And I got the text Moby Dick Chapter 5. Saving the obtained text in mobydick.txt, I can simply write a script, which spits out non-matching words with open('mobydick.txt','r') as f1: m1 = f1.read().split() with open('solved.txt','r') as f2: m2 = f2.read().split() assert len(m1) == len(m2) for i in range(len(m1)): if m1[i] != m2[i]: print(m1[i], m2[i]) # quickly bquickly # landlord alandlord # the tthe # more's moreâ€™s # boarders pboarders # young wyoung # fellow's fellowâ€™s # HE he # tints, ntints, # Andes' Andesâ€™ # "Grub, â€œGrub, # ho!" ho!â€ # landlord, {landlord, # traveller, travelhler, # Mungo's Mungoâ€™s # performancesâ€”this performancesâ€”thiis # circumstance circumstadnce # after aftder # and and3 # sea-dogs, nsea-dogs, # slightest _slightest # boarded mboarded # breakfast obreakfast # timid btimid # themâ€”at themâ€”ayt # to _to # THAT that # people's peopleâ€™s # estimation, destimation, # genteelly. igenteelly. # not cnot # Queequeg's Queequegâ€™s # breakfast kbreakfast # a a} Apart from single quotes, and case differences, we get the flag batpwn{hidd3n_moby_dick}]]></summary></entry><entry><title type="html">BATPWN 2020 Crypto - Prefixes</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/batpwn/crypto/prefixes/2020-06-08-Batpwn-2020-Prefixes" rel="alternate" type="text/html" title="BATPWN 2020 Crypto - Prefixes" /><published>2020-06-08T00:00:00+05:30</published><updated>2020-06-08T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/batpwn/crypto/prefixes/Batpwn-2020-Prefixes</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/batpwn/crypto/prefixes/2020-06-08-Batpwn-2020-Prefixes"><![CDATA[<h1 id="prefixes">Prefixes</h1>

<p><img src="Capture.PNG" alt="" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>package main

import (
    "fmt"
    "strings"
)

func charCodeAt(st string, ni int) rune {
    for i, j := range st {
        if i == ni {
            return j
        }
    }
    return 0
}

func hexify(st string) string {
    var ok string = ""
    ltr := []string{"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"}

    for cnt := 0; cnt &lt; len(st); cnt++ {
        ok += ltr[charCodeAt(st, cnt)&gt;&gt;4] + ltr[charCodeAt(st, cnt)&amp;15]
    }

    return ok
}

func encrypt(st string) string {

    var initialize int = 0
    var ot string = ""
    var val int

    for i := 0; i &lt; len(st); i++ {
        val = int(charCodeAt(st, i))
        initialize ^= (val &lt;&lt; 2) ^ val
        ot += string(initialize &amp; 0xff)
        initialize &gt;&gt;= 8
    }

    return strings.Replace(hexify(ot), "00", "", -1)
}

func main() {
    fmt.Println(encrypt("[REDACTED FLAG]"))
}

//Hash: eae4a5b1aad7964ec9f1f0bff0229cf1a11b22b11bfefecc9922aaf4bff0dd3c88
</code></pre></div></div>

<p>We are provided with this go file, and a hash which we have to reverse <br />
TBH I dont know <a href="https://golang.org/">go</a>, but the code is comprehendible enough in my opinion.<br />
Lets analyse the code chunk by chunk</p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">func</span> <span class="n">charCodeAt</span><span class="p">(</span><span class="n">st</span> <span class="kt">string</span><span class="p">,</span> <span class="n">ni</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">rune</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">st</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">ni</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">j</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="m">0</span>
<span class="p">}</span>
</code></pre></div></div>
<p>It should return the character value <code class="language-plaintext highlighter-rouge">0-255</code> for the character at position <code class="language-plaintext highlighter-rouge">ni</code> in string <code class="language-plaintext highlighter-rouge">st</code></p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">hexify</span><span class="p">(</span><span class="n">st</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">var</span> <span class="n">ok</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">""</span>
    <span class="n">ltr</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">string</span><span class="p">{</span><span class="s">"0"</span><span class="p">,</span> <span class="s">"1"</span><span class="p">,</span> <span class="s">"2"</span><span class="p">,</span> <span class="s">"3"</span><span class="p">,</span> <span class="s">"4"</span><span class="p">,</span> <span class="s">"5"</span><span class="p">,</span> <span class="s">"6"</span><span class="p">,</span> <span class="s">"7"</span><span class="p">,</span> <span class="s">"8"</span><span class="p">,</span> <span class="s">"9"</span><span class="p">,</span> <span class="s">"a"</span><span class="p">,</span> <span class="s">"b"</span><span class="p">,</span> <span class="s">"c"</span><span class="p">,</span> <span class="s">"d"</span><span class="p">,</span> <span class="s">"e"</span><span class="p">,</span> <span class="s">"f"</span><span class="p">}</span>

    <span class="k">for</span> <span class="n">cnt</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">cnt</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">);</span> <span class="n">cnt</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">ok</span> <span class="o">+=</span> <span class="n">ltr</span><span class="p">[</span><span class="n">charCodeAt</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">cnt</span><span class="p">)</span><span class="o">&gt;&gt;</span><span class="m">4</span><span class="p">]</span> <span class="o">+</span> <span class="n">ltr</span><span class="p">[</span><span class="n">charCodeAt</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">cnt</span><span class="p">)</span><span class="o">&amp;</span><span class="m">15</span><span class="p">]</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">ok</span>
<span class="p">}</span>
</code></pre></div></div>
<p>I should hexlify, i.e. return the hexadecimal representation the the string <code class="language-plaintext highlighter-rouge">st</code></p>

<div class="language-go highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">encrypt</span><span class="p">(</span><span class="n">st</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>

    <span class="k">var</span> <span class="n">initialize</span> <span class="kt">int</span> <span class="o">=</span> <span class="m">0</span>
    <span class="k">var</span> <span class="n">ot</span> <span class="kt">string</span> <span class="o">=</span> <span class="s">""</span>
    <span class="k">var</span> <span class="n">val</span> <span class="kt">int</span>

    <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">st</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">val</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="n">charCodeAt</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">i</span><span class="p">))</span>
        <span class="n">initialize</span> <span class="o">^=</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="m">2</span><span class="p">)</span> <span class="o">^</span> <span class="n">val</span>
        <span class="n">ot</span> <span class="o">+=</span> <span class="kt">string</span><span class="p">(</span><span class="n">initialize</span> <span class="o">&amp;</span> <span class="m">0xff</span><span class="p">)</span>
        <span class="n">initialize</span> <span class="o">&gt;&gt;=</span> <span class="m">8</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">strings</span><span class="o">.</span><span class="n">Replace</span><span class="p">(</span><span class="n">hexify</span><span class="p">(</span><span class="n">ot</span><span class="p">),</span> <span class="s">"00"</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span> <span class="o">-</span><span class="m">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>
<p>This should encrypt the hash obviously.<br />
Now looking at how it does stuff, it should be easy enough to reverse all steps. We shall begin from the last step which is<br />
<code class="language-plaintext highlighter-rouge">strings.Replace(hexify(ot), "00", "", -1)</code><br />
Which simply replaces all occurences of <code class="language-plaintext highlighter-rouge">"00"</code> with <code class="language-plaintext highlighter-rouge">""</code> (nothing) throught (-1) from hexlified string of <code class="language-plaintext highlighter-rouge">ot</code>. Hence, we should be able to get <code class="language-plaintext highlighter-rouge">ot</code> (sans â€œ00â€) from the final hash by simply hex-decoding.</p>

<p>Now, since we dont know the final value of <code class="language-plaintext highlighter-rouge">initialize</code>, we can reverse it from the start since we know its initial value to be <code class="language-plaintext highlighter-rouge">0</code>.</p>

<p>The character at position <code class="language-plaintext highlighter-rouge">i</code> is simply the <code class="language-plaintext highlighter-rouge">val</code> which produces <code class="language-plaintext highlighter-rouge">initialize ^ (val&lt;&lt;2) ^ val</code> with corresponding character at position <code class="language-plaintext highlighter-rouge">i</code> in <code class="language-plaintext highlighter-rouge">ot</code></p>

<p>Here is a quick script to do the same</p>
<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ct</span> <span class="o">=</span> <span class="s">"eae4a5b1aad7964ec9f1f0bff0229cf1a11b22b11bfefecc9922aaf4bff0dd3c88"</span>
<span class="n">ct</span> <span class="o">=</span> <span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>
<span class="n">flag</span> <span class="o">=</span> <span class="s">""</span>

<span class="n">initialize</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ct</span><span class="p">)):</span>
    <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">):</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">initialize</span> <span class="o">^</span> <span class="p">(</span><span class="n">val</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="n">val</span><span class="p">)</span><span class="o">&amp;</span><span class="mh">0xff</span> <span class="o">==</span> <span class="n">ct</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
            <span class="n">flag</span> <span class="o">+=</span> <span class="nb">chr</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>  <span class="c1">#the value val is found
</span>            <span class="n">initialize</span> <span class="o">^=</span> <span class="p">(</span><span class="n">val</span><span class="o">&lt;&lt;</span><span class="mi">2</span><span class="p">)</span><span class="o">^</span><span class="n">val</span>  <span class="c1">#to get the value of initialize for nex iteration of i
</span>            <span class="n">initialize</span> <span class="o">&gt;&gt;=</span><span class="mi">8</span> <span class="c1"># initialize is [0-3] since (val&lt;&lt;2)^(val) is 10 bits, which is right shifted 8 bits each iteration
</span>            <span class="k">break</span>
<span class="k">print</span><span class="p">(</span><span class="n">flag</span><span class="p">)</span>
<span class="c1">#batpwn{Ch00se_y0uR_pR3fix_w1selY}
</span></code></pre></div></div>

<p>I was not expecting it to give out the flag in first <a href="https://golang.org/">go</a> since <code class="language-plaintext highlighter-rouge">00</code> were stripped out of the final hash.
Turns out this step was redundant. If it were not, we could simply use all 4 values of <code class="language-plaintext highlighter-rouge">initialize</code> for the places where the flag seems to not make sense.</p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="BATPWN" /><category term="2020" /><category term="Bsides" /><category term="cryptography" /><category term="golang" /><summary type="html"><![CDATA[Prefixes package main import ( "fmt" "strings" ) func charCodeAt(st string, ni int) rune { for i, j := range st { if i == ni { return j } } return 0 } func hexify(st string) string { var ok string = "" ltr := []string{"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"} for cnt := 0; cnt &lt; len(st); cnt++ { ok += ltr[charCodeAt(st, cnt)&gt;&gt;4] + ltr[charCodeAt(st, cnt)&amp;15] } return ok } func encrypt(st string) string { var initialize int = 0 var ot string = "" var val int for i := 0; i &lt; len(st); i++ { val = int(charCodeAt(st, i)) initialize ^= (val &lt;&lt; 2) ^ val ot += string(initialize &amp; 0xff) initialize &gt;&gt;= 8 } return strings.Replace(hexify(ot), "00", "", -1) } func main() { fmt.Println(encrypt("[REDACTED FLAG]")) } //Hash: eae4a5b1aad7964ec9f1f0bff0229cf1a11b22b11bfefecc9922aaf4bff0dd3c88 We are provided with this go file, and a hash which we have to reverse TBH I dont know go, but the code is comprehendible enough in my opinion. Lets analyse the code chunk by chunk func charCodeAt(st string, ni int) rune { for i, j := range st { if i == ni { return j } } return 0 } It should return the character value 0-255 for the character at position ni in string st func hexify(st string) string { var ok string = "" ltr := []string{"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"} for cnt := 0; cnt &lt; len(st); cnt++ { ok += ltr[charCodeAt(st, cnt)&gt;&gt;4] + ltr[charCodeAt(st, cnt)&amp;15] } return ok } I should hexlify, i.e. return the hexadecimal representation the the string st func encrypt(st string) string { var initialize int = 0 var ot string = "" var val int for i := 0; i &lt; len(st); i++ { val = int(charCodeAt(st, i)) initialize ^= (val &lt;&lt; 2) ^ val ot += string(initialize &amp; 0xff) initialize &gt;&gt;= 8 } return strings.Replace(hexify(ot), "00", "", -1) } This should encrypt the hash obviously. Now looking at how it does stuff, it should be easy enough to reverse all steps. We shall begin from the last step which is strings.Replace(hexify(ot), "00", "", -1) Which simply replaces all occurences of "00" with "" (nothing) throught (-1) from hexlified string of ot. Hence, we should be able to get ot (sans â€œ00â€) from the final hash by simply hex-decoding. Now, since we dont know the final value of initialize, we can reverse it from the start since we know its initial value to be 0. The character at position i is simply the val which produces initialize ^ (val&lt;&lt;2) ^ val with corresponding character at position i in ot Here is a quick script to do the same ct = "eae4a5b1aad7964ec9f1f0bff0229cf1a11b22b11bfefecc9922aaf4bff0dd3c88" ct = bytes.fromhex(ct) flag = "" initialize = 0 for i in range(len(ct)): for val in range(256): if (initialize ^ (val&lt;&lt;2)^val)&amp;0xff == ct[i]: flag += chr(val) #the value val is found initialize ^= (val&lt;&lt;2)^val #to get the value of initialize for nex iteration of i initialize &gt;&gt;=8 # initialize is [0-3] since (val&lt;&lt;2)^(val) is 10 bits, which is right shifted 8 bits each iteration break print(flag) #batpwn{Ch00se_y0uR_pR3fix_w1selY} I was not expecting it to give out the flag in first go since 00 were stripped out of the final hash. Turns out this step was redundant. If it were not, we could simply use all 4 values of initialize for the places where the flag seems to not make sense.]]></summary></entry><entry><title type="html">HSCTF 2020 Crypto - Affina and the quadratics</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Affina%20and%20the%20Quadratics/2020-06-06-HSCTF-2020-Affina-and-the-quadratics" rel="alternate" type="text/html" title="HSCTF 2020 Crypto - Affina and the quadratics" /><published>2020-06-06T00:00:00+05:30</published><updated>2020-06-06T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Affina%20and%20the%20Quadratics/HSCTF-2020-Affina-and-the-quadratics</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Affina%20and%20the%20Quadratics/2020-06-06-HSCTF-2020-Affina-and-the-quadratics"><![CDATA[<h1 id="affina-and-the-quadratics">Affina and the Quadratics</h1>

<p><img src="Capture.PNG" alt="" /></p>

<p>We are given this image, and hinted towards the name <a href="https://en.wikipedia.org/wiki/Affine_cipher">Affina</a>.</p>

<p><img src="affffinaaaa-page-001.jpg" alt="" />
With a description reading</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Affina was struggling with her graphing quadratics homework. Bored, she decided to cheat by using Desmos to graph the given quadratic, and then realized that she could use it to send messages to her best friend without anyone noticing!

She sent the following message to her friend: 7rr4p6_4e_4ph6bo8hap2?

Can you decrypt it using the image of the quadratic Affina used? Note: the flag should make relative sense.
</code></pre></div></div>

<p>The task is to GUESS how Affine cipher is used with respect to the quadratic <code class="language-plaintext highlighter-rouge">(x+1)*(x+2) = 0</code></p>

<p>After having many GUESSES, I GUESSED that it could be simple affine cipher with mapping <code class="language-plaintext highlighter-rouge">3x+2 mod 26</code> as <code class="language-plaintext highlighter-rouge">(x+1)*(x+2) = x^2 + 3x + 2</code> as hey!, why should it be quadratic right?</p>

<p>But dont we have letters too? So I GUESSED we shouldnt care about them for now.<br />
What about underscores? GUESS that they are just word-delimiters.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>c = 3x + 2 mod 26
c - 2 = 3x mod 26
3^-1 * (c - 2) = x mod 26
9c - 18 = x mod 26
x = 9c + 8 mod 26
</code></pre></div></div>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ct</span> <span class="o">=</span> <span class="s">"7rr4p6_4e_4ph6bo8hap2"</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="s">"rrpephbohap"</span>
<span class="n">ct26</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">chr</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="mi">97</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">alpha</span><span class="p">]</span>
<span class="n">pt</span> <span class="o">=</span> <span class="p">[</span> <span class="nb">chr</span><span class="p">((</span><span class="mi">9</span><span class="o">*</span><span class="n">c</span> <span class="o">+</span> <span class="mi">8</span><span class="p">)</span><span class="o">%</span><span class="mi">26</span> <span class="o">+</span> <span class="mi">97</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ct26</span> <span class="p">]</span>
</code></pre></div></div>

<p>putting it in places, we get
<code class="language-plaintext highlighter-rouge">7ff4n6_4s_4nt6re8tin2</code></p>

<p>Now why GUESS that number are encoded with the same affine cipher modulo when you can easily GUESS the flag is <code class="language-plaintext highlighter-rouge">4ff1n3_1s_1nt3re5tin6</code> :smile:</p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="HSCTF" /><category term="2020" /><category term="cryptography" /><category term="affine" /><category term="classical" /><category term="substitution" /><summary type="html"><![CDATA[Affina and the Quadratics We are given this image, and hinted towards the name Affina. With a description reading Affina was struggling with her graphing quadratics homework. Bored, she decided to cheat by using Desmos to graph the given quadratic, and then realized that she could use it to send messages to her best friend without anyone noticing! She sent the following message to her friend: 7rr4p6_4e_4ph6bo8hap2? Can you decrypt it using the image of the quadratic Affina used? Note: the flag should make relative sense. The task is to GUESS how Affine cipher is used with respect to the quadratic (x+1)*(x+2) = 0 After having many GUESSES, I GUESSED that it could be simple affine cipher with mapping 3x+2 mod 26 as (x+1)*(x+2) = x^2 + 3x + 2 as hey!, why should it be quadratic right? But dont we have letters too? So I GUESSED we shouldnt care about them for now. What about underscores? GUESS that they are just word-delimiters. c = 3x + 2 mod 26 c - 2 = 3x mod 26 3^-1 * (c - 2) = x mod 26 9c - 18 = x mod 26 x = 9c + 8 mod 26 ct = "7rr4p6_4e_4ph6bo8hap2" alpha = "rrpephbohap" ct26 = [ chr(i) - 97 for i in alpha] pt = [ chr((9*c + 8)%26 + 97) for c in ct26 ] putting it in places, we get 7ff4n6_4s_4nt6re8tin2 Now why GUESS that number are encoded with the same affine cipher modulo when you can easily GUESS the flag is 4ff1n3_1s_1nt3re5tin6 :smile:]]></summary></entry><entry><title type="html">HSCTF 2020 Crypto - Chonky E</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Chonky%20E/2020-06-06-HSCTF-2020-Chonky-E" rel="alternate" type="text/html" title="HSCTF 2020 Crypto - Chonky E" /><published>2020-06-06T00:00:00+05:30</published><updated>2020-06-06T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Chonky%20E/HSCTF-2020-Chonky-E</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Chonky%20E/2020-06-06-HSCTF-2020-Chonky-E"><![CDATA[<h1 id="chonky-e">Chonky E</h1>
<p><img src="Capture.PNG" alt="" /></p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Allen and Jason rely on two different cryptosystems to keep their information secure.

Allen uses the RSA cryptosystem, given by the following public key:
e = 91043118409828550796773745518585981151180206101005135117565865602978722878478494447048783557571813980525643725323377488249838860897784683927029906188947001149632101513367258267329961684034661252866484981926055087386190015432964608927947646476193251820354738640453947833718397360834701566765504916472450194494897616371452996381159817427887623703639133290358520498419049175941584678802701606995099241245926884172985004839801270005583030514286561971825047719421487004569752638468907609110285739083279629747310953086535889932550905065172805818862336335628248528993024112446002398466115161473573451161053837400091893285717
n = 156749047558583013960513267351769479915110440411448078412590565797031533622509813352093119636835511977253033854388466854142753776146092587825440445182008237325262012698034419137157047927918635897378973846177552961727126115560551970797370239385129543828686170774323306933202481728884019420422360360849592983818405154473369790181636472137741865440233383956571081122982223602667853668754338360008279002325576495573847568301584365514417593244726435632222027817410359417329310347952169273512510934251453361933794586716533950489973436393834189505450956622286216819440777162804798432330933357058175885674184582816364542591313

Jason uses the Schmidt-Samoa cryptosystem. Although a public key has not been recovered, we know that Allen and Jason share the same primes (p,q).

A ciphertext was found on Jasonâ€™s computer that reads: 16267540901004879123859424672087486188548628828063789528428674467464407443871599865993337555869530486241139138650641838377419734897801380883629894166353225288006148210453677023750688175192317241440457768788267270422857060534261674538755743244831152470995124962736526978165448560149498403762447372653982922113772190234143253450918953235222315161964539311032659628670417496174123483045439359846360048774164337257829398345686635091862306204455687347443958931441225500856408331795261329035072585605404416473987280037959184981453888701567175803979981461050532113072292714696752692872526424122826696681194705563391161137426703690900733706866842363055967856443765215723398555522126909749236759332964873221973970368877565410624895160438695006432021529071866881905134494489266801004903504121740435965696128048690741210812963902631391765192187570107372453917327060678806282122942318369245760773848604249664378721970318257356486696764545

What are the contents of this message?
</code></pre></div></div>

<p>Since both crypto use same p and q doesnt reveal a method to recover p or q or the plaintext somehow, second BIG hint is the name of the challenge :- chonkyE</p>

<p>Big E could lead to two attacks, and Boneh Durfee attack is more powerful of the two.</p>

<p>Here is the evergreen <a href="https://github.com/mimoo/RSA-and-LLL-attacks">sage script</a> for the same. I modified it a bit (by fixing annoying python2 print statements) to run on sage 9 (python3).</p>

<blockquote>
  <p><code class="language-plaintext highlighter-rouge">d = 4801820624110300567381264152630360984400101198006662778338105999190025449039653722546363948393959163699344836724430590700225590643966670154013435626235133</code></p>
</blockquote>

<p>We can recover p, q from n, e, d. The most convenient way according to me is to use RSA module from Crypto.PublicKey</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">Crypto.PublicKey</span> <span class="kn">import</span> <span class="n">RSA</span>
<span class="kn">import</span> <span class="nn">gmpy2</span>

<span class="n">n</span> <span class="o">=</span> <span class="mi">156749047558583013960513267351769479915110440411448078412590565797031533622509813352093119636835511977253033854388466854142753776146092587825440445182008237325262012698034419137157047927918635897378973846177552961727126115560551970797370239385129543828686170774323306933202481728884019420422360360849592983818405154473369790181636472137741865440233383956571081122982223602667853668754338360008279002325576495573847568301584365514417593244726435632222027817410359417329310347952169273512510934251453361933794586716533950489973436393834189505450956622286216819440777162804798432330933357058175885674184582816364542591313</span>
<span class="n">e</span> <span class="o">=</span> <span class="mi">91043118409828550796773745518585981151180206101005135117565865602978722878478494447048783557571813980525643725323377488249838860897784683927029906188947001149632101513367258267329961684034661252866484981926055087386190015432964608927947646476193251820354738640453947833718397360834701566765504916472450194494897616371452996381159817427887623703639133290358520498419049175941584678802701606995099241245926884172985004839801270005583030514286561971825047719421487004569752638468907609110285739083279629747310953086535889932550905065172805818862336335628248528993024112446002398466115161473573451161053837400091893285717</span>
<span class="n">d</span> <span class="o">=</span> <span class="mi">4801820624110300567381264152630360984400101198006662778338105999190025449039653722546363948393959163699344836724430590700225590643966670154013435626235133</span>

<span class="n">rsa</span> <span class="o">=</span> <span class="n">RSA</span><span class="p">.</span><span class="n">construct</span><span class="p">((</span><span class="n">n</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">rsa</span><span class="p">.</span><span class="n">p</span>
<span class="n">q</span> <span class="o">=</span> <span class="n">rsa</span><span class="p">.</span><span class="n">q</span>

<span class="c1"># rest is just implementation of Schmidt-Samoa
</span>
<span class="n">ct</span> <span class="o">=</span> <span class="mi">16267540901004879123859424672087486188548628828063789528428674467464407443871599865993337555869530486241139138650641838377419734897801380883629894166353225288006148210453677023750688175192317241440457768788267270422857060534261674538755743244831152470995124962736526978165448560149498403762447372653982922113772190234143253450918953235222315161964539311032659628670417496174123483045439359846360048774164337257829398345686635091862306204455687347443958931441225500856408331795261329035072585605404416473987280037959184981453888701567175803979981461050532113072292714696752692872526424122826696681194705563391161137426703690900733706866842363055967856443765215723398555522126909749236759332964873221973970368877565410624895160438695006432021529071866881905134494489266801004903504121740435965696128048690741210812963902631391765192187570107372453917327060678806282122942318369245760773848604249664378721970318257356486696764545</span>

<span class="c1"># N = p**2*q
# d = N^-1 mod lcm(p-1, q-1)
# m = c^d mod pq
</span>
<span class="n">N</span> <span class="o">=</span> <span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="o">*</span><span class="n">q</span>  <span class="c1"># since this one works
</span><span class="n">lcm_val</span> <span class="o">=</span> <span class="n">gmpy2</span><span class="p">.</span><span class="n">lcm</span><span class="p">(</span><span class="n">p</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">q</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">D</span> <span class="o">=</span> <span class="n">gmpy2</span><span class="p">.</span><span class="n">invert</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">lcm_val</span><span class="p">)</span>
<span class="n">m</span> <span class="o">=</span> <span class="nb">pow</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">D</span><span class="p">,</span> <span class="n">p</span><span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="nb">bytes</span><span class="p">.</span><span class="n">fromhex</span><span class="p">(</span><span class="nb">hex</span><span class="p">(</span><span class="n">m</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]))</span>
<span class="c1"># flag{remarkably_superb_acronym}
</span></code></pre></div></div>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="HSCTF" /><category term="2020" /><category term="cryptography" /><category term="RSA" /><category term="schmidtsamoa" /><category term="bonehdurfee" /><category term="bigE" /><summary type="html"><![CDATA[Chonky E Allen and Jason rely on two different cryptosystems to keep their information secure. Allen uses the RSA cryptosystem, given by the following public key: e = 91043118409828550796773745518585981151180206101005135117565865602978722878478494447048783557571813980525643725323377488249838860897784683927029906188947001149632101513367258267329961684034661252866484981926055087386190015432964608927947646476193251820354738640453947833718397360834701566765504916472450194494897616371452996381159817427887623703639133290358520498419049175941584678802701606995099241245926884172985004839801270005583030514286561971825047719421487004569752638468907609110285739083279629747310953086535889932550905065172805818862336335628248528993024112446002398466115161473573451161053837400091893285717 n = 156749047558583013960513267351769479915110440411448078412590565797031533622509813352093119636835511977253033854388466854142753776146092587825440445182008237325262012698034419137157047927918635897378973846177552961727126115560551970797370239385129543828686170774323306933202481728884019420422360360849592983818405154473369790181636472137741865440233383956571081122982223602667853668754338360008279002325576495573847568301584365514417593244726435632222027817410359417329310347952169273512510934251453361933794586716533950489973436393834189505450956622286216819440777162804798432330933357058175885674184582816364542591313 Jason uses the Schmidt-Samoa cryptosystem. Although a public key has not been recovered, we know that Allen and Jason share the same primes (p,q). A ciphertext was found on Jasonâ€™s computer that reads: 16267540901004879123859424672087486188548628828063789528428674467464407443871599865993337555869530486241139138650641838377419734897801380883629894166353225288006148210453677023750688175192317241440457768788267270422857060534261674538755743244831152470995124962736526978165448560149498403762447372653982922113772190234143253450918953235222315161964539311032659628670417496174123483045439359846360048774164337257829398345686635091862306204455687347443958931441225500856408331795261329035072585605404416473987280037959184981453888701567175803979981461050532113072292714696752692872526424122826696681194705563391161137426703690900733706866842363055967856443765215723398555522126909749236759332964873221973970368877565410624895160438695006432021529071866881905134494489266801004903504121740435965696128048690741210812963902631391765192187570107372453917327060678806282122942318369245760773848604249664378721970318257356486696764545 What are the contents of this message? Since both crypto use same p and q doesnt reveal a method to recover p or q or the plaintext somehow, second BIG hint is the name of the challenge :- chonkyE Big E could lead to two attacks, and Boneh Durfee attack is more powerful of the two. Here is the evergreen sage script for the same. I modified it a bit (by fixing annoying python2 print statements) to run on sage 9 (python3). d = 4801820624110300567381264152630360984400101198006662778338105999190025449039653722546363948393959163699344836724430590700225590643966670154013435626235133 We can recover p, q from n, e, d. The most convenient way according to me is to use RSA module from Crypto.PublicKey from Crypto.PublicKey import RSA import gmpy2 n = 156749047558583013960513267351769479915110440411448078412590565797031533622509813352093119636835511977253033854388466854142753776146092587825440445182008237325262012698034419137157047927918635897378973846177552961727126115560551970797370239385129543828686170774323306933202481728884019420422360360849592983818405154473369790181636472137741865440233383956571081122982223602667853668754338360008279002325576495573847568301584365514417593244726435632222027817410359417329310347952169273512510934251453361933794586716533950489973436393834189505450956622286216819440777162804798432330933357058175885674184582816364542591313 e = 91043118409828550796773745518585981151180206101005135117565865602978722878478494447048783557571813980525643725323377488249838860897784683927029906188947001149632101513367258267329961684034661252866484981926055087386190015432964608927947646476193251820354738640453947833718397360834701566765504916472450194494897616371452996381159817427887623703639133290358520498419049175941584678802701606995099241245926884172985004839801270005583030514286561971825047719421487004569752638468907609110285739083279629747310953086535889932550905065172805818862336335628248528993024112446002398466115161473573451161053837400091893285717 d = 4801820624110300567381264152630360984400101198006662778338105999190025449039653722546363948393959163699344836724430590700225590643966670154013435626235133 rsa = RSA.construct((n, e, d)) p = rsa.p q = rsa.q # rest is just implementation of Schmidt-Samoa ct = 16267540901004879123859424672087486188548628828063789528428674467464407443871599865993337555869530486241139138650641838377419734897801380883629894166353225288006148210453677023750688175192317241440457768788267270422857060534261674538755743244831152470995124962736526978165448560149498403762447372653982922113772190234143253450918953235222315161964539311032659628670417496174123483045439359846360048774164337257829398345686635091862306204455687347443958931441225500856408331795261329035072585605404416473987280037959184981453888701567175803979981461050532113072292714696752692872526424122826696681194705563391161137426703690900733706866842363055967856443765215723398555522126909749236759332964873221973970368877565410624895160438695006432021529071866881905134494489266801004903504121740435965696128048690741210812963902631391765192187570107372453917327060678806282122942318369245760773848604249664378721970318257356486696764545 # N = p**2*q # d = N^-1 mod lcm(p-1, q-1) # m = c^d mod pq N = p*q*q # since this one works lcm_val = gmpy2.lcm(p-1, q-1) D = gmpy2.invert(N, lcm_val) m = pow(ct, D, p*q) print(bytes.fromhex(hex(m)[2:])) # flag{remarkably_superb_acronym}]]></summary></entry><entry><title type="html">HSCTF 2020 Crypto - Extremely Complex Challenge</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Extremely%20Complex%20Challenge/2020-06-06-HSCTF-2020-Extremely-Complex-Challenge" rel="alternate" type="text/html" title="HSCTF 2020 Crypto - Extremely Complex Challenge" /><published>2020-06-06T00:00:00+05:30</published><updated>2020-06-06T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Extremely%20Complex%20Challenge/HSCTF-2020-Extremely-Complex-Challenge</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Extremely%20Complex%20Challenge/2020-06-06-HSCTF-2020-Extremely-Complex-Challenge"><![CDATA[<h1 id="extremely-complex-challenge">Extremely Complex Challenge</h1>

<p><img src="Capture.PNG" alt="" /></p>

<p>We are given two points on an <a href="https://en.wikipedia.org/wiki/Elliptic-curve_cryptography#Theory">Elliptic Curve</a>, its order and parameter <code class="language-plaintext highlighter-rouge">b</code>.<br />
Using these quantities, we can recover parameter <code class="language-plaintext highlighter-rouge">a</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>y^2 = x^3 + ax + b (mod p)
y^2 - x^3 - b = ax (mod p)

If we have two points on curve, (x1, y1) and (x2, y2), we can get

(y1^2 - x1^3) - (y2^2 - x2^3) = a(x1 - x2)  (mod p)
a = (x1 - x2)^-1 (y1^2 - x1^3) - (y2^2 - x2^3)  (mod p)

(x1 - x2)^-1 is inverse of (x1-x2) modulo p
</code></pre></div></div>

<p>Now as we have all parameters, we can solve <a href="https://en.wikipedia.org/wiki/Discrete_logarithm#Cryptography">ECDLP</a> easily since the sizes are too small.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">gmpy2</span>

<span class="n">p</span> <span class="o">=</span> <span class="mi">404993569381</span>
<span class="n">G</span> <span class="o">=</span> <span class="p">(</span><span class="mi">391109997465</span><span class="p">,</span> <span class="mi">167359562362</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="mi">209038982304</span><span class="p">,</span> <span class="mi">168517698208</span><span class="p">)</span>
<span class="n">b</span> <span class="o">=</span> <span class="mi">54575449882</span>

<span class="n">diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">P</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span> <span class="o">-</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">3</span><span class="p">)</span>
<span class="n">diff</span> <span class="o">=</span> <span class="n">diff</span> <span class="o">%</span> <span class="n">p</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">gmpy2</span><span class="p">.</span><span class="n">invert</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">p</span><span class="p">)</span><span class="o">*</span><span class="n">diff</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">%</span> <span class="n">p</span>

<span class="n">E</span> <span class="o">=</span> <span class="n">EllipticCurve</span><span class="p">(</span><span class="n">GF</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">,</span> <span class="p">[</span><span class="n">a</span><span class="p">,</span><span class="n">b</span><span class="p">])</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">E</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">E</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="n">PK</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">discrete_log</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">PK</span><span class="p">)</span>
<span class="n">G</span><span class="o">*</span><span class="n">PK</span> <span class="o">==</span> <span class="n">P</span>
<span class="c1">#17683067357
</span></code></pre></div></div>

<p>Altough I solved it using <a href="https://www.sagemath.org/">SageMath</a>, I think it can be solved on python too using relevant libraries.</p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="HSCTF" /><category term="2020" /><category term="cryptography" /><category term="ECC" /><category term="ECDLP" /><summary type="html"><![CDATA[Extremely Complex Challenge We are given two points on an Elliptic Curve, its order and parameter b. Using these quantities, we can recover parameter a. y^2 = x^3 + ax + b (mod p) y^2 - x^3 - b = ax (mod p) If we have two points on curve, (x1, y1) and (x2, y2), we can get (y1^2 - x1^3) - (y2^2 - x2^3) = a(x1 - x2) (mod p) a = (x1 - x2)^-1 (y1^2 - x1^3) - (y2^2 - x2^3) (mod p) (x1 - x2)^-1 is inverse of (x1-x2) modulo p Now as we have all parameters, we can solve ECDLP easily since the sizes are too small. import gmpy2 p = 404993569381 G = (391109997465, 167359562362) P = (209038982304, 168517698208) b = 54575449882 diff = (G[1]**2 - P[1]**2) - (G[0]**3 - P[0]**3) diff = diff % p a = gmpy2.invert(G[0] - P[0],p)*diff a = a % p E = EllipticCurve(GF(p) , [a,b]) G = E(G) P = E(P) PK = G.discrete_log(P) print(PK) G*PK == P #17683067357 Altough I solved it using SageMath, I think it can be solved on python too using relevant libraries.]]></summary></entry><entry><title type="html">HSCTF 2020 Crypto - Morbid</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Morbid/2020-06-06-HSCTF-2020-Morbid" rel="alternate" type="text/html" title="HSCTF 2020 Crypto - Morbid" /><published>2020-06-06T00:00:00+05:30</published><updated>2020-06-06T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Morbid/HSCTF-2020-Morbid</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Morbid/2020-06-06-HSCTF-2020-Morbid"><![CDATA[<hr />
<p>aside:
  toc: true
sidebar:
  nav: aboutnav
author: deuterium
full_width: true
mathjax: false
mathjax_autoNumber: false
mermaid: false
chart: false
show_edit_on_github: true
comment: false:
show_author_profile: true
excerpt_separator: <!--more-->
â€”</p>

<h1 id="morbid">Morbid</h1>

<p><img src="Capture.PNG" alt="" /></p>

<h3 id="contents-of-morbitpdf">Contents of Morbit.pdf</h3>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>MORBIT (50-75 plaintext letters)

Choose a  9-letter  keyword  to  set  up an  array  as  shown.  Plaintext  is  enciphered
exactly  as in  the  Fractionated  Morse,  x  between  letters,  xx  between  words.  The
result is then taken off in units of 2, placed vertically, and numbers are taken from
the array to form the ciphertext. Numbers represent alphabetical order of the key. (It
is often as easy to read pairs horizontally as to rearrange them vertically.) Morse
code letters, numbers, and punctuation can be found in Appendix 1.

Key:

 W I S E C R A C K
 9 5 8 4 2 7 1 3 6
 â€¢ â€¢ â€¢ â€“ â€“ â€“ x x x
 â€¢ â€“ x â€¢ â€“ x â€¢ â€“ x

pt: Once upon a time.

pt:   o      n       c     e   /    u        p       o       n
MC: â€“ â€“ â€“ x â€“ â€¢ x â€“ â€¢ â€“ â€¢ x â€¢ x x â€¢ â€¢ â€“ x â€¢ â€“ â€“ â€¢ x â€“ â€“ â€“ x â€“ â€¢
CT: 2   7   4   3   5   8   8   1   5   1   2   8   2   7   4

 /  a    /  t    i     m    e
x x â€¢ â€“ x x â€“ x â€¢ â€¢ x â€“ â€“ x â€¢ x
6   5   6   7   9   3   7   8

CT: 27435 88151 28274 65679 378.
</code></pre></div></div>

<blockquote>
  <p>We have to decrypt 118289293938434193849271464117429364476994241473157664969879696938145689474393647294392739247721652822414624317164228466</p>
</blockquote>

<p>Since Morse code is <a href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman encoded</a>, the frequencies of - (dash) and . (dot) would be equivalent in the ciphertext.
(I am not sure about x since spaces are way more frequent than any letter) 
Without thinking more about analyzing the problem statistically, one simple way to solve the problem is <a href="https://en.wikipedia.org/wiki/Brute-force_attack">brute-forcing</a>
the key which is 9 different decimal characters i.e <strong>9! (362880)</strong> permutations to check, which is fairly easy.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">itertools</span>  <span class="c1"># creates iterators for efficient looping
</span>
<span class="c1"># dictionary of mapping as on
# https://en.wikipedia.org/wiki/Morse_code#Letters,_numbers,_punctuation,_prosigns_for_Morse_code_and_non-English_variants
</span>
<span class="n">morse</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s">"a"</span><span class="p">:</span> <span class="s">".-"</span><span class="p">,</span>
    <span class="s">"b"</span><span class="p">:</span> <span class="s">"-..."</span><span class="p">,</span>
    <span class="s">"c"</span><span class="p">:</span> <span class="s">"-.-."</span><span class="p">,</span>
    <span class="s">"d"</span><span class="p">:</span> <span class="s">"-.."</span><span class="p">,</span>
    <span class="s">"e"</span><span class="p">:</span> <span class="s">"."</span><span class="p">,</span>
    <span class="s">"f"</span><span class="p">:</span> <span class="s">"..-."</span><span class="p">,</span>
    <span class="s">"g"</span><span class="p">:</span> <span class="s">"--."</span><span class="p">,</span>
    <span class="s">"h"</span><span class="p">:</span> <span class="s">"...."</span><span class="p">,</span>
    <span class="s">"i"</span><span class="p">:</span> <span class="s">".."</span><span class="p">,</span>
    <span class="s">"j"</span><span class="p">:</span> <span class="s">".---"</span><span class="p">,</span>
    <span class="s">"k"</span><span class="p">:</span> <span class="s">"-.-"</span><span class="p">,</span>
    <span class="s">"l"</span><span class="p">:</span> <span class="s">".-.."</span><span class="p">,</span>
    <span class="s">"m"</span><span class="p">:</span> <span class="s">"--"</span><span class="p">,</span>
    <span class="s">"n"</span><span class="p">:</span> <span class="s">"-."</span><span class="p">,</span>
    <span class="s">"o"</span><span class="p">:</span> <span class="s">"---"</span><span class="p">,</span>
    <span class="s">"p"</span><span class="p">:</span> <span class="s">".--."</span><span class="p">,</span>
    <span class="s">"q"</span><span class="p">:</span> <span class="s">"--.-"</span><span class="p">,</span>
    <span class="s">"r"</span><span class="p">:</span> <span class="s">".-."</span><span class="p">,</span>
    <span class="s">"s"</span><span class="p">:</span> <span class="s">"..."</span><span class="p">,</span>
    <span class="s">"t"</span><span class="p">:</span> <span class="s">"-"</span><span class="p">,</span>
    <span class="s">"u"</span><span class="p">:</span> <span class="s">"..-"</span><span class="p">,</span>
    <span class="s">"v"</span><span class="p">:</span> <span class="s">"...-"</span><span class="p">,</span>
    <span class="s">"w"</span><span class="p">:</span> <span class="s">".--"</span><span class="p">,</span>
    <span class="s">"x"</span><span class="p">:</span> <span class="s">"-..-"</span><span class="p">,</span>
    <span class="s">"y"</span><span class="p">:</span> <span class="s">"-.--"</span><span class="p">,</span>
    <span class="s">"z"</span><span class="p">:</span> <span class="s">"--.."</span><span class="p">,</span>
    <span class="s">"0"</span><span class="p">:</span> <span class="s">"-----"</span><span class="p">,</span>
    <span class="s">"1"</span><span class="p">:</span> <span class="s">".----"</span><span class="p">,</span>
    <span class="s">"2"</span><span class="p">:</span> <span class="s">"..---"</span><span class="p">,</span>
    <span class="s">"3"</span><span class="p">:</span> <span class="s">"...--"</span><span class="p">,</span>
    <span class="s">"4"</span><span class="p">:</span> <span class="s">"....-"</span><span class="p">,</span>
    <span class="s">"5"</span><span class="p">:</span> <span class="s">"....."</span><span class="p">,</span>
    <span class="s">"6"</span><span class="p">:</span> <span class="s">"-...."</span><span class="p">,</span>
    <span class="s">"7"</span><span class="p">:</span> <span class="s">"--..."</span><span class="p">,</span>
    <span class="s">"8"</span><span class="p">:</span> <span class="s">"---.."</span><span class="p">,</span>
    <span class="s">"9"</span><span class="p">:</span> <span class="s">"----."</span><span class="p">,</span>
    <span class="s">"."</span><span class="p">:</span> <span class="s">".-.-.-"</span><span class="p">,</span>
    <span class="s">","</span><span class="p">:</span> <span class="s">"--..--"</span><span class="p">,</span>
    <span class="s">"?"</span><span class="p">:</span> <span class="s">"..--.."</span><span class="p">,</span>
    <span class="s">"'"</span><span class="p">:</span> <span class="s">".----."</span><span class="p">,</span>
    <span class="s">"!"</span><span class="p">:</span> <span class="s">"-.-.--"</span><span class="p">,</span>
    <span class="s">"/"</span><span class="p">:</span> <span class="s">"-..-."</span><span class="p">,</span>
    <span class="s">"("</span><span class="p">:</span> <span class="s">"-.--."</span><span class="p">,</span>
    <span class="s">")"</span><span class="p">:</span> <span class="s">"-.--.-"</span><span class="p">,</span>
    <span class="s">"&amp;"</span><span class="p">:</span> <span class="s">".-..."</span><span class="p">,</span>
    <span class="s">":"</span><span class="p">:</span> <span class="s">"---..."</span><span class="p">,</span>
    <span class="s">";"</span><span class="p">:</span> <span class="s">"-.-.-."</span><span class="p">,</span>
    <span class="s">"="</span><span class="p">:</span> <span class="s">"-...-"</span><span class="p">,</span>
    <span class="s">"+"</span><span class="p">:</span> <span class="s">".-.-."</span><span class="p">,</span>
    <span class="s">"-"</span><span class="p">:</span> <span class="s">"-....-"</span><span class="p">,</span>
    <span class="s">"_"</span><span class="p">:</span> <span class="s">"..--.-"</span><span class="p">,</span>
    <span class="s">"</span><span class="se">\"</span><span class="s">"</span><span class="p">:</span> <span class="s">".-..-."</span><span class="p">,</span>
    <span class="s">"$"</span><span class="p">:</span> <span class="s">"...-..-"</span><span class="p">,</span>
    <span class="s">"@"</span><span class="p">:</span> <span class="s">".--.-."</span><span class="p">,</span>
    <span class="s">" "</span><span class="p">:</span> <span class="s">""</span>
<span class="p">}</span>

<span class="n">revMorse</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># Dictionary containing inverse mapping from morse code to its corresponding encoded character
</span><span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">morse</span><span class="p">.</span><span class="n">items</span><span class="p">():</span>
    <span class="n">revMorse</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>


<span class="k">def</span> <span class="nf">decrypt_morse</span><span class="p">(</span><span class="n">message</span><span class="p">):</span>
    <span class="s">"""
    Finds the decryption of `message` encoded in morse with individual
    letters separated by x and words separated by xx
    """</span>
    <span class="n">words</span> <span class="o">=</span> <span class="n">message</span><span class="p">.</span><span class="n">split</span><span class="p">(</span><span class="s">'x'</span><span class="p">)</span>
    <span class="k">return</span> <span class="s">""</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">revMorse</span><span class="p">[</span><span class="n">word</span><span class="p">]</span> <span class="k">for</span> <span class="n">word</span> <span class="ow">in</span> <span class="n">words</span><span class="p">)</span>


<span class="c1"># Checking the example given in the pdf
</span><span class="k">print</span><span class="p">(</span><span class="n">decrypt_morse</span><span class="p">(</span><span class="s">"---x-.x-.-.x.xx..-x.--.x---x-.xx.-xx-x..x--x.x"</span><span class="p">))</span>
<span class="n">ct</span> <span class="o">=</span> <span class="s">"118289293938434193849271464117429364476994241473157664969879696938145689474393647294392739247721652822414624317164228466"</span>

<span class="n">substitution_token</span> <span class="o">=</span> <span class="p">[</span><span class="s">'..'</span><span class="p">,</span> <span class="s">'.-'</span><span class="p">,</span> <span class="s">'.x'</span><span class="p">,</span> <span class="s">'-.'</span><span class="p">,</span> <span class="s">'--'</span><span class="p">,</span> <span class="s">'-x'</span><span class="p">,</span> <span class="s">'x.'</span><span class="p">,</span> <span class="s">'x-'</span><span class="p">,</span> <span class="s">'xx'</span><span class="p">]</span>
<span class="k">for</span> <span class="n">perm</span> <span class="ow">in</span> <span class="n">itertools</span><span class="p">.</span><span class="n">permutations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">)):</span>
    <span class="c1"># Iterate over permutations of substitution_tokens to find the
</span>    <span class="c1"># permutations which finds the valid decryption
</span>    <span class="n">ct1</span> <span class="o">=</span> <span class="n">ct</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
        <span class="n">ct1</span> <span class="o">=</span> <span class="n">ct1</span><span class="p">.</span><span class="n">replace</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">substitution_token</span><span class="p">[</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
        <span class="c1"># Replace digit in ciphertext with given permutation of substitutions
</span>    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="s">'flag'</span> <span class="ow">in</span> <span class="n">decrypt_morse</span><span class="p">(</span><span class="n">ct1</span><span class="p">):</span>
            <span class="c1"># if the decyrpted strings containts flag, we get our string
</span>            <span class="k">print</span><span class="p">(</span><span class="n">decrypt_morse</span><span class="p">(</span><span class="n">ct1</span><span class="p">))</span>
            <span class="k">break</span>
    <span class="k">except</span> <span class="nb">KeyError</span><span class="p">:</span>
        <span class="k">continue</span>
        
<span class="c1"># Output
# once upon a time
# congratulations. please wrap this message in a flag format: m0r3_b1t5
</span></code></pre></div></div>

<h2 id="post-challenge-analysis">Post-challenge analysis</h2>
<p>Since I found the challenge interesting, here is some analysis</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">substitution</span> <span class="o">=</span> <span class="p">[</span><span class="n">substitution_token</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">perm</span><span class="p">]</span>
<span class="n">frequency</span> <span class="o">=</span> <span class="p">[</span><span class="n">ct</span><span class="p">.</span><span class="n">count</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">digit</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span> <span class="k">for</span> <span class="n">digit</span> <span class="ow">in</span> <span class="n">perm</span><span class="p">]</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">9</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">"digit {0}: {1} {2}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">perm</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">substitution</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">frequency</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th style="text-align: center">Digits</th>
      <th style="text-align: center">1</th>
      <th style="text-align: center">2</th>
      <th style="text-align: center">3</th>
      <th style="text-align: center">4</th>
      <th style="text-align: center">5</th>
      <th style="text-align: center">6</th>
      <th style="text-align: center">7</th>
      <th style="text-align: center">8</th>
      <th style="text-align: center">9</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Substitution</td>
      <td style="text-align: center">â€¢â€¢</td>
      <td style="text-align: center">â€¢â€“</td>
      <td style="text-align: center">â€¢X</td>
      <td style="text-align: center">â€“â€¢</td>
      <td style="text-align: center">â€“â€“</td>
      <td style="text-align: center">â€“X</td>
      <td style="text-align: center">Xâ€¢</td>
      <td style="text-align: center">Xâ€“</td>
      <td style="text-align: center">XX</td>
    </tr>
    <tr>
      <td style="text-align: center">Frequency</td>
      <td style="text-align: center">13</td>
      <td style="text-align: center">15</td>
      <td style="text-align: center">12</td>
      <td style="text-align: center">23</td>
      <td style="text-align: center">3</td>
      <td style="text-align: center">15</td>
      <td style="text-align: center">12</td>
      <td style="text-align: center">9</td>
      <td style="text-align: center">18</td>
    </tr>
  </tbody>
</table>

<p>Hmm, 
<code class="language-plaintext highlighter-rouge">--</code> and <code class="language-plaintext highlighter-rouge">X-</code> are quite infrequent, while <code class="language-plaintext highlighter-rouge">-.</code> seems a little bit more frequent. I was expecting <code class="language-plaintext highlighter-rouge">.., .-, --, -.</code> to be equally frequent. Either I did some error or there is something which I cant see currently.</p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="HSCTF" /><category term="2020" /><category term="cryptography" /><category term="classical" /><category term="morse" /><summary type="html"><![CDATA[aside: toc: true sidebar: nav: aboutnav author: deuterium full_width: true mathjax: false mathjax_autoNumber: false mermaid: false chart: false show_edit_on_github: true comment: false: show_author_profile: true excerpt_separator:]]></summary></entry><entry><title type="html">HSCTF 2020 Crypto - Randomization 1</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Randomization%201/2020-06-06-HSCTF-2020-Randomization-1" rel="alternate" type="text/html" title="HSCTF 2020 Crypto - Randomization 1" /><published>2020-06-06T00:00:00+05:30</published><updated>2020-06-06T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Randomization%201/HSCTF-2020-Randomization-1</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Randomization%201/2020-06-06-HSCTF-2020-Randomization-1"><![CDATA[<h1 id="randomization-1">Randomization 1</h1>

<p><img src="Capture.PNG" alt="" /></p>

<p>We are provided a binary <a href="rand1">rand1</a> which supposedly runs on the server. We have to figure out how would capture the flag</p>

<p>Lets decompile the binary quickly in <a href="https://ghidra-sre.org/">Ghidra</a>.<br />
Seeing the output of <code class="language-plaintext highlighter-rouge">main</code> function we get</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">undefined8</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>

<span class="p">{</span>
  <span class="n">uint</span> <span class="n">uVar1</span><span class="p">;</span>
  <span class="n">undefined8</span> <span class="n">uVar2</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">in_FS_OFFSET</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">local_1c</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">local_18</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">local_14</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">local_10</span><span class="p">;</span>
  
  <span class="n">local_10</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_FS_OFFSET</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">);</span>
  <span class="n">initRandom</span><span class="p">();</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"I heard LCGs were cool so I made my own"</span><span class="p">);</span>
  <span class="n">uVar1</span> <span class="o">=</span> <span class="n">next</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Since I</span><span class="se">\'</span><span class="s">m so generous you get a free number: %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,(</span><span class="n">ulong</span><span class="p">)</span><span class="n">uVar1</span><span class="p">);</span>
  <span class="n">local_18</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// local_18 works as in iterator from 0 to 9</span>
  <span class="k">do</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="mi">9</span> <span class="o">&lt;</span> <span class="n">local_18</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">win</span><span class="p">();</span>
      <span class="n">uVar2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">LAB_0010132e:</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">local_10</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">in_FS_OFFSET</span> <span class="o">+</span> <span class="mh">0x28</span><span class="p">))</span> <span class="p">{</span>
                    <span class="cm">/* WARNING: Subroutine does not return */</span>
        <span class="n">__stack_chk_fail</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">uVar2</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Guess my number: "</span><span class="p">);</span>
    <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DAT_00102093</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_1c</span><span class="p">);</span>
    <span class="n">local_14</span> <span class="o">=</span> <span class="n">next</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">local_14</span> <span class="o">!=</span> <span class="n">local_1c</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">puts</span><span class="p">(</span><span class="s">"Wrong!"</span><span class="p">);</span>
      <span class="n">uVar2</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">goto</span> <span class="n">LAB_0010132e</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">local_18</span> <span class="o">=</span> <span class="n">local_18</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">while</span><span class="p">(</span> <span class="nb">true</span> <span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>As a quick overview, one could tell there is a loop which runs 10 times and after running 10 times successfully, it should spit out the flag.<br />
It asks for input 10 times, and each time it compares the value with return value of the function next().<br />
Taking a quick look of decompilaton of next</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">ulong</span> <span class="nf">next</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>

<span class="p">{</span>
  <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span> <span class="o">*</span> <span class="sc">'%'</span> <span class="o">+</span> <span class="mh">0x41</span><span class="p">;</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">ulong</span><span class="p">)</span><span class="n">curr</span><span class="p">;</span>
<span class="p">}</span>

</code></pre></div></div>
<p>We see its a simple linear function, but the decompiled value seems off, it should actually be taking <code class="language-plaintext highlighter-rouge">curr</code> which is actually <code class="language-plaintext highlighter-rouge">local_14</code> and returning a <code class="language-plaintext highlighter-rouge">char</code> type.</p>

<p>As the start value is printed out before beginning the loop, we can predict all the values by writing a simple function</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">next_10</span><span class="p">(</span><span class="n">curr</span><span class="p">):</span>
	<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
		<span class="n">curr</span> <span class="o">=</span> <span class="p">(</span><span class="n">curr</span> <span class="o">*</span> <span class="mh">0x25</span> <span class="o">+</span> <span class="mh">0x41</span><span class="p">)</span><span class="o">%</span><span class="mi">256</span>
		<span class="k">print</span><span class="p">(</span><span class="n">curr</span><span class="p">)</span> 
</code></pre></div></div>

<p>We dont need to bother about automating nc, just input all 10 values in one go as timing is not really an issue</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>I heard LCGs were cool so I made my own
Since I'm so generous you get a free number: 184
Guess my number: 217
158
23
148
165
26
3
176
177
214Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number:
flag{l1n34r_c0n6ru3n714l_63n3r470r_f41lur3_4b3bcd43}
</code></pre></div></div>
<p>BRAVO we did it</p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="HSCTF" /><category term="2020" /><category term="cryptograpy" /><category term="reversing" /><category term="LCG" /><summary type="html"><![CDATA[Randomization 1 We are provided a binary rand1 which supposedly runs on the server. We have to figure out how would capture the flag Lets decompile the binary quickly in Ghidra. Seeing the output of main function we get undefined8 main(void) { uint uVar1; undefined8 uVar2; long in_FS_OFFSET; int local_1c; int local_18; int local_14; long local_10; local_10 = *(long *)(in_FS_OFFSET + 0x28); initRandom(); puts("I heard LCGs were cool so I made my own"); uVar1 = next(); printf("Since I\'m so generous you get a free number: %d\n",(ulong)uVar1); local_18 = 0; // local_18 works as in iterator from 0 to 9 do { if (9 &lt; local_18) { win(); uVar2 = 0; LAB_0010132e: if (local_10 != *(long *)(in_FS_OFFSET + 0x28)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return uVar2; } printf("Guess my number: "); __isoc99_scanf(&amp;DAT_00102093,&amp;local_1c); local_14 = next(); if (local_14 != local_1c) { puts("Wrong!"); uVar2 = 1; goto LAB_0010132e; } local_18 = local_18 + 1; } while( true ); } As a quick overview, one could tell there is a loop which runs 10 times and after running 10 times successfully, it should spit out the flag. It asks for input 10 times, and each time it compares the value with return value of the function next(). Taking a quick look of decompilaton of next ulong next(void) { curr = curr * '%' + 0x41; return (ulong)curr; } We see its a simple linear function, but the decompiled value seems off, it should actually be taking curr which is actually local_14 and returning a char type. As the start value is printed out before beginning the loop, we can predict all the values by writing a simple function def next_10(curr): for i in range(10): curr = (curr * 0x25 + 0x41)%256 print(curr) We dont need to bother about automating nc, just input all 10 values in one go as timing is not really an issue I heard LCGs were cool so I made my own Since I'm so generous you get a free number: 184 Guess my number: 217 158 23 148 165 26 3 176 177 214Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: flag{l1n34r_c0n6ru3n714l_63n3r470r_f41lur3_4b3bcd43} BRAVO we did it]]></summary></entry><entry><title type="html">HSCTF 2020 Crypto - Randomization 2</title><link href="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Randomization%202/2020-06-06-HSCTF-2020-Crypto-Randomization-2" rel="alternate" type="text/html" title="HSCTF 2020 Crypto - Randomization 2" /><published>2020-06-06T00:00:00+05:30</published><updated>2020-06-06T00:00:00+05:30</updated><id>https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Randomization%202/HSCTF-2020-Crypto-Randomization-2</id><content type="html" xml:base="https://deut-erium.github.io/WriteUps/WriteUps/2020/HSCTF/crypto/Randomization%202/2020-06-06-HSCTF-2020-Crypto-Randomization-2"><![CDATA[<h1 id="randomization-2">Randomization 2</h1>

<p><img src="Capture.png" alt="Screenshot" /></p>

<p>Again, we are provided a binary <a href="rand2">rand2</a> which runs on the server. On connecting to the server, weâ€™re provided with 2 numbers and then weâ€™re asked to guess the next numbers several(10) times.</p>

<p>Going ahead, letâ€™s use <a href="https://ghidra-sre.org/">Ghidra</a> to decompile this binary, and then work our ass off to understand the terrible decompiled code.
Just kiddingâ€¦</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">undefined8</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>

<span class="p">{</span>
  <span class="kt">long</span> <span class="n">lVar1</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">in_FS_OFFSET</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">local_1c</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">local_18</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">local_10</span><span class="p">;</span>
  
  <span class="n">local_10</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="n">in_FS_OFFSET</span> <span class="o">+</span> <span class="mi">40</span><span class="p">);</span>
  <span class="n">initRandom</span><span class="p">();</span>
  <span class="n">setvbuf</span><span class="p">(</span><span class="n">stdin</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">setvbuf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">local_18</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"I had a bit too much coffee so this is in Java not C"</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"(Actually it</span><span class="se">\'</span><span class="s">s still in C because Java is a pain)"</span><span class="p">);</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"Since I</span><span class="se">\'</span><span class="s">m so generous you get 2 free numbers"</span><span class="p">);</span>
  <span class="n">lVar1</span> <span class="o">=</span> <span class="n">next</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%llu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">lVar1</span><span class="p">);</span>
  <span class="n">lVar1</span> <span class="o">=</span> <span class="n">next</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%llu</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">lVar1</span><span class="p">);</span>
  <span class="n">local_1c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">local_1c</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Guess my number: "</span><span class="p">);</span>
    <span class="n">__isoc99_scanf</span><span class="p">(</span><span class="o">&amp;</span><span class="n">DAT_001020e5</span><span class="p">,</span><span class="o">&amp;</span><span class="n">local_18</span><span class="p">);</span>
    <span class="n">lVar1</span> <span class="o">=</span> <span class="n">next</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">lVar1</span> <span class="o">!=</span> <span class="n">local_18</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">puts</span><span class="p">(</span><span class="s">"WRONG!"</span><span class="p">);</span>
                    <span class="cm">/* WARNING: Subroutine does not return */</span>
      <span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">local_1c</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">"You win!"</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Have a flag: "</span><span class="p">);</span>
  <span class="n">win</span><span class="p">();</span>
  <span class="n">puts</span><span class="p">(</span><span class="s">""</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">local_10</span> <span class="o">!=</span> <span class="o">*</span><span class="p">(</span><span class="n">in_FS_OFFSET</span> <span class="o">+</span> <span class="mi">40</span><span class="p">))</span> <span class="p">{</span>
                    <span class="cm">/* WARNING: Subroutine does not return */</span>
    <span class="n">__stack_chk_fail</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Briefly, we can see an initRandom function and a next function which weâ€™ll look at just in a moment, and the loop runs 10 times and weâ€™re asked for a guess of the next number every time, and if all our guesses work out, weâ€™ll have the flag.</p>

<p>Moving over to the initRandom function:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">initRandom</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>

<span class="p">{</span>
  <span class="kt">int</span> <span class="n">iVar1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">local_14</span><span class="p">;</span>
  <span class="kt">long</span> <span class="n">local_10</span><span class="p">;</span>
  
  <span class="n">urandom</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">"/dev/urandom"</span><span class="p">,</span><span class="s">"r"</span><span class="p">);</span>
  <span class="n">local_10</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">local_14</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">local_14</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">iVar1</span> <span class="o">=</span> <span class="n">fgetc</span><span class="p">(</span><span class="n">urandom</span><span class="p">);</span>
    <span class="n">local_10</span> <span class="o">=</span> <span class="n">local_10</span> <span class="o">*</span> <span class="mi">256</span> <span class="o">+</span> <span class="n">iVar1</span><span class="p">;</span>
    <span class="n">local_14</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">curr</span> <span class="o">=</span> <span class="n">local_10</span><span class="p">;</span>
  <span class="n">fclose</span><span class="p">(</span><span class="n">urandom</span><span class="p">);</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Basically it initializes the seed to the PRNG, meh we neednâ€™t worry too much about this probably.</p>

<p>Then comes the next function:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">long</span> <span class="nf">next</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>

<span class="p">{</span>
  <span class="n">curr</span> <span class="o">=</span> <span class="n">curr</span> <span class="o">*</span> <span class="mi">25214903917</span> <span class="o">+</span> <span class="mi">11</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">curr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Voila, this equation is what we wanted! But a catch, <code class="language-plaintext highlighter-rouge">long</code> values can be negative, but we donâ€™t see any negative numbers. Maybe it is <code class="language-plaintext highlighter-rouge">unsigned long</code> (64 bits, now we realize what the description probably meant).</p>

<p>Our linear PRNGâ€™s state comprises of just 1 number, so we donâ€™t even need the first number. Take the second number, and do the next function on it.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;bits/stdc++.h&gt;</span><span class="cp">
</span><span class="n">using</span> <span class="n">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">x</span><span class="p">;</span>
	<span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">25214903917</span><span class="o">+</span><span class="mi">11</span><span class="p">;</span>
		<span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>If youâ€™re trying it out in Python, donâ€™t forget to take numbers modulo 2**64.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>I had a bit too much coffee so this is in Java not C
(Actually it's still in C because Java is a pain)
Since I'm so generous you get 2 free numbers
7258447304246973212
17116010196804995831
Guess my number: 16690969720309355830
6468650403376040969
4458106111961708000
8544260868340822123
785197920356155290
16490108719449469085
16773761617645535460
13390247135748110623
11364946156142406718
3626610375201229425
Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: You win!
Have a flag: flag{1n53cur3_r4nd0m_46b8861b}
</code></pre></div></div>

<p>Easy huh, turns out java.util.Random uses almost the same PRNG, DONâ€™T USE THIS FOR CRYPTO lol :triumph:</p>]]></content><author><name>deuterium</name><email>farziemailid69@gmail.com</email></author><category term="HSCTF" /><category term="2020" /><category term="cryptography" /><category term="LCG" /><category term="reversing" /><summary type="html"><![CDATA[Randomization 2 Again, we are provided a binary rand2 which runs on the server. On connecting to the server, weâ€™re provided with 2 numbers and then weâ€™re asked to guess the next numbers several(10) times. Going ahead, letâ€™s use Ghidra to decompile this binary, and then work our ass off to understand the terrible decompiled code. Just kiddingâ€¦ undefined8 main(void) { long lVar1; long in_FS_OFFSET; int local_1c; long local_18; long local_10; local_10 = *(in_FS_OFFSET + 40); initRandom(); setvbuf(stdin,NULL,2,0); setvbuf(stdout,NULL,2,0); local_18 = 0; puts("I had a bit too much coffee so this is in Java not C"); puts("(Actually it\'s still in C because Java is a pain)"); puts("Since I\'m so generous you get 2 free numbers"); lVar1 = next(); printf("%llu\n",lVar1); lVar1 = next(); printf("%llu\n",lVar1); local_1c = 0; while (local_1c &lt; 10) { printf("Guess my number: "); __isoc99_scanf(&amp;DAT_001020e5,&amp;local_18); lVar1 = next(); if (lVar1 != local_18) { puts("WRONG!"); /* WARNING: Subroutine does not return */ exit(0); } local_1c += 1; } puts("You win!"); printf("Have a flag: "); win(); puts(""); if (local_10 != *(in_FS_OFFSET + 40)) { /* WARNING: Subroutine does not return */ __stack_chk_fail(); } return 0; } Briefly, we can see an initRandom function and a next function which weâ€™ll look at just in a moment, and the loop runs 10 times and weâ€™re asked for a guess of the next number every time, and if all our guesses work out, weâ€™ll have the flag. Moving over to the initRandom function: void initRandom(void) { int iVar1; int local_14; long local_10; urandom = fopen("/dev/urandom","r"); local_10 = 0; local_14 = 0; while (local_14 &lt; 8) { iVar1 = fgetc(urandom); local_10 = local_10 * 256 + iVar1; local_14 += 1; } curr = local_10; fclose(urandom); return; } Basically it initializes the seed to the PRNG, meh we neednâ€™t worry too much about this probably. Then comes the next function: long next(void) { curr = curr * 25214903917 + 11; return curr; } Voila, this equation is what we wanted! But a catch, long values can be negative, but we donâ€™t see any negative numbers. Maybe it is unsigned long (64 bits, now we realize what the description probably meant). Our linear PRNGâ€™s state comprises of just 1 number, so we donâ€™t even need the first number. Take the second number, and do the next function on it. #include &lt;bits/stdc++.h&gt; using namespace std; int main() { unsigned long x; cin &gt;&gt; x; for (int i = 0; i &lt; 10; i++) { x = x * 25214903917+11; cout &lt;&lt; x &lt;&lt; endl; } } If youâ€™re trying it out in Python, donâ€™t forget to take numbers modulo 2**64. I had a bit too much coffee so this is in Java not C (Actually it's still in C because Java is a pain) Since I'm so generous you get 2 free numbers 7258447304246973212 17116010196804995831 Guess my number: 16690969720309355830 6468650403376040969 4458106111961708000 8544260868340822123 785197920356155290 16490108719449469085 16773761617645535460 13390247135748110623 11364946156142406718 3626610375201229425 Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: Guess my number: You win! Have a flag: flag{1n53cur3_r4nd0m_46b8861b} Easy huh, turns out java.util.Random uses almost the same PRNG, DONâ€™T USE THIS FOR CRYPTO lol :triumph:]]></summary></entry></feed>