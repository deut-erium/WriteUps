from Crypto.Util.number import *
from z3 import *
p = 86160765871200393116432211865381287556448879131923154695356172713106176601077
b = 71198163834256441900788553646474983932569411761091772746766420811695841423780
m = 88219145192729480056743197897921789558305761774733086829638493717397473234815
t = 2**85
w0 = 401052873479535541023317092941219339820731562526505
w1 = 994046339364774179650447057905749575131331863844814

cons1 = ((2**170)*(w0**2)+b)%p
cons2 = ((2**86)*w0)%p
cons3 = ((2**85)*w1)%p
cons4 = (cons1-cons3)%p

#((2**85w0 + k0)**2 + b)%p == 2**85w1+k1
#( 2**170w0**2 + k0**2 + 2**86w0k0 + b )%p == 2**85w1+k1
#(cons1 + k0**2 + cons2k0)%p == cons3 + k1
#(cons4 + k0**2 + cons2k0)%p%t == k1
## v0 = 2**85w0+k0,v1 = 2**85w1+k1

## (k0+x)**2 + y %p == k1

k0,k1 = Ints('k0 k1')
constraints = [(k0*k0 + cons2*k0 + cons4)%p == k1,k0>=0,k1>=0,k0<t,k1<t]



nex_k1 = lambda k0:(k0*k0 + cons2*k0 + cons4)%p

def F(v):
    return (v*v+b)%p

def next_5_xor(k2):
    res = m
    v = (2**85*w1+k2)%p
    v = F(v)
    res^=v
    return long_to_bytes(res)
