import sys
sys.setrecursionlimit(10000)
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP

n = 0x8C6DDBF9A2DD53A2466FF61BB62CF5BE3AF89DE821BB75A581ABC8514A84392A6613EAA3269C159843EEF781DF5522A92D2D5ADC3C95A54C5FEB427D082C157D4F2DB6901411C0CE29F1571573FB488885EEC8D36F8C79482B5123A82047D79588A95FB2C1A1671042785F5D0C1469EBA21858D643F664659F9E6303395A05DABB0503F2E880A899A67E7840BD20FAC2831693620928D0C90C47ABD695D00D27E48E7862A3150159AC58E50B64D1C9D46CC7C6C195DF61EC0FEF79937F5545B08A53517382C07362FC8A2475A99E9CB41E4FC544A700E11CA23C658ADFCED9EEBB795E3AA5A332D1E39BC728D8E039F07D2B2BF93C4E1120A3D4CB1B7AE1E0D78CEAC37595F0BD994EC78EBF8D39C5FB12D803CDF9BB019A6FDA4D20BFFDE8FEF052A6189433EDCF94F6D7BB6A8D9CC1919650E0139B6F284D44BF1D672E5CE8A56F2E7BD3E2EBEE6FB7F631E0039CF5079ECF74B1C7565E6058B81F46B5B66EAF7F834E942CCE5A6CC3BD47EF4BD418B179C1114AA0FB68AB3FAA91EDBC510407E10524B3790F04E3B27E46EBC25E5BB2B934D4E46BF09405A567F3C7E77CE3F0AEE383BD0C8D72ECB2A399737C3FD279261BF27B7CCFEE8BB2141E202EFB78687D1585609AAF7C2C6F3597F84B003B55A9F2EAD1AEDFE00056CBB5509942C288DDD208FC05DA803335B5E062B2709EF59FD0E3D4EA217B8F295D4AC021FF37

x = 16158503035655503426113161923582139215996816729841729510388257123879913978158886398099119284865182008994209960822918533986492024494600106348146394391522057566608094710459034761239411826561975763233251722937911293380163746384471886598967490683174505277425790076708816190844068727460135370229854070720638780344789626637927699732624476246512446229279134683464388038627051524453190148083707025054101132463059634405171130015990728153311556498299145863647112326468089494225289395728401221863674961839497514512905495012562702779156196970731085339939466059770413224786385677222902726546438487688076765303358036256878804074494
e=65537

def factorize(n,x,bit_pos=0,candidates=[(0,0)]):
    cands = []
    mask = (1<<(bit_pos+1))-1
    for p,q in candidates:
        if n==p*q:
            return p,q
        for bit in range(2):
            p1 = (bit<<bit_pos)|p
            q1 = p1^(x&mask)
            if (p1*q1)&mask==n&mask:
                cands.append((p1,q1))
    return factorize(n,x,bit_pos+1,cands)

p,q = factorize(n,x)
d = pow(e,-1,(p-1)*(q-1))
key = RSA.construct((n,e,d,p,q))

with open('flag.enc','rb') as f:
    enc_flag = f.read()

cipher = PKCS1_OAEP.new(key)
print(cipher.decrypt(enc_flag))
#PCTF{who_needs_xor_when_you_can_add_and_subtract}
